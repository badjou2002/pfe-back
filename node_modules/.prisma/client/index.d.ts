
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Specialite
 * 
 */
export type Specialite = $Result.DefaultSelection<Prisma.$SpecialitePayload>
/**
 * Model Niveau
 * 
 */
export type Niveau = $Result.DefaultSelection<Prisma.$NiveauPayload>
/**
 * Model EspaceCours
 * 
 */
export type EspaceCours = $Result.DefaultSelection<Prisma.$EspaceCoursPayload>
/**
 * Model Theme
 * 
 */
export type Theme = $Result.DefaultSelection<Prisma.$ThemePayload>
/**
 * Model EspaceDepot
 * 
 */
export type EspaceDepot = $Result.DefaultSelection<Prisma.$EspaceDepotPayload>
/**
 * Model Ressource
 * 
 */
export type Ressource = $Result.DefaultSelection<Prisma.$RessourcePayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model BanqueQuestion
 * 
 */
export type BanqueQuestion = $Result.DefaultSelection<Prisma.$BanqueQuestionPayload>
/**
 * Model Reponse
 * 
 */
export type Reponse = $Result.DefaultSelection<Prisma.$ReponsePayload>
/**
 * Model Commentaire
 * 
 */
export type Commentaire = $Result.DefaultSelection<Prisma.$CommentairePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Etudiant
 * 
 */
export type Etudiant = $Result.DefaultSelection<Prisma.$EtudiantPayload>
/**
 * Model Enseingant
 * 
 */
export type Enseingant = $Result.DefaultSelection<Prisma.$EnseingantPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Gamification
 * 
 */
export type Gamification = $Result.DefaultSelection<Prisma.$GamificationPayload>
/**
 * Model Resultat
 * 
 */
export type Resultat = $Result.DefaultSelection<Prisma.$ResultatPayload>
/**
 * Model TestQuestion
 * 
 */
export type TestQuestion = $Result.DefaultSelection<Prisma.$TestQuestionPayload>
/**
 * Model Depot
 * 
 */
export type Depot = $Result.DefaultSelection<Prisma.$DepotPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TypeFile: {
  image: 'image',
  video: 'video',
  autre: 'autre'
};

export type TypeFile = (typeof TypeFile)[keyof typeof TypeFile]


export const RoleUser: {
  admin: 'admin',
  etudiant: 'etudiant',
  enseingant: 'enseingant'
};

export type RoleUser = (typeof RoleUser)[keyof typeof RoleUser]

}

export type TypeFile = $Enums.TypeFile

export const TypeFile: typeof $Enums.TypeFile

export type RoleUser = $Enums.RoleUser

export const RoleUser: typeof $Enums.RoleUser

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Specialites
 * const specialites = await prisma.specialite.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Specialites
   * const specialites = await prisma.specialite.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.specialite`: Exposes CRUD operations for the **Specialite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialites
    * const specialites = await prisma.specialite.findMany()
    * ```
    */
  get specialite(): Prisma.SpecialiteDelegate<ExtArgs>;

  /**
   * `prisma.niveau`: Exposes CRUD operations for the **Niveau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Niveaus
    * const niveaus = await prisma.niveau.findMany()
    * ```
    */
  get niveau(): Prisma.NiveauDelegate<ExtArgs>;

  /**
   * `prisma.espaceCours`: Exposes CRUD operations for the **EspaceCours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EspaceCours
    * const espaceCours = await prisma.espaceCours.findMany()
    * ```
    */
  get espaceCours(): Prisma.EspaceCoursDelegate<ExtArgs>;

  /**
   * `prisma.theme`: Exposes CRUD operations for the **Theme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Themes
    * const themes = await prisma.theme.findMany()
    * ```
    */
  get theme(): Prisma.ThemeDelegate<ExtArgs>;

  /**
   * `prisma.espaceDepot`: Exposes CRUD operations for the **EspaceDepot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EspaceDepots
    * const espaceDepots = await prisma.espaceDepot.findMany()
    * ```
    */
  get espaceDepot(): Prisma.EspaceDepotDelegate<ExtArgs>;

  /**
   * `prisma.ressource`: Exposes CRUD operations for the **Ressource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ressources
    * const ressources = await prisma.ressource.findMany()
    * ```
    */
  get ressource(): Prisma.RessourceDelegate<ExtArgs>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs>;

  /**
   * `prisma.banqueQuestion`: Exposes CRUD operations for the **BanqueQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BanqueQuestions
    * const banqueQuestions = await prisma.banqueQuestion.findMany()
    * ```
    */
  get banqueQuestion(): Prisma.BanqueQuestionDelegate<ExtArgs>;

  /**
   * `prisma.reponse`: Exposes CRUD operations for the **Reponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reponses
    * const reponses = await prisma.reponse.findMany()
    * ```
    */
  get reponse(): Prisma.ReponseDelegate<ExtArgs>;

  /**
   * `prisma.commentaire`: Exposes CRUD operations for the **Commentaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commentaires
    * const commentaires = await prisma.commentaire.findMany()
    * ```
    */
  get commentaire(): Prisma.CommentaireDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.etudiant`: Exposes CRUD operations for the **Etudiant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etudiants
    * const etudiants = await prisma.etudiant.findMany()
    * ```
    */
  get etudiant(): Prisma.EtudiantDelegate<ExtArgs>;

  /**
   * `prisma.enseingant`: Exposes CRUD operations for the **Enseingant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enseingants
    * const enseingants = await prisma.enseingant.findMany()
    * ```
    */
  get enseingant(): Prisma.EnseingantDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.gamification`: Exposes CRUD operations for the **Gamification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamifications
    * const gamifications = await prisma.gamification.findMany()
    * ```
    */
  get gamification(): Prisma.GamificationDelegate<ExtArgs>;

  /**
   * `prisma.resultat`: Exposes CRUD operations for the **Resultat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resultats
    * const resultats = await prisma.resultat.findMany()
    * ```
    */
  get resultat(): Prisma.ResultatDelegate<ExtArgs>;

  /**
   * `prisma.testQuestion`: Exposes CRUD operations for the **TestQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestQuestions
    * const testQuestions = await prisma.testQuestion.findMany()
    * ```
    */
  get testQuestion(): Prisma.TestQuestionDelegate<ExtArgs>;

  /**
   * `prisma.depot`: Exposes CRUD operations for the **Depot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Depots
    * const depots = await prisma.depot.findMany()
    * ```
    */
  get depot(): Prisma.DepotDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Specialite: 'Specialite',
    Niveau: 'Niveau',
    EspaceCours: 'EspaceCours',
    Theme: 'Theme',
    EspaceDepot: 'EspaceDepot',
    Ressource: 'Ressource',
    Test: 'Test',
    BanqueQuestion: 'BanqueQuestion',
    Reponse: 'Reponse',
    Commentaire: 'Commentaire',
    User: 'User',
    Etudiant: 'Etudiant',
    Enseingant: 'Enseingant',
    Admin: 'Admin',
    Gamification: 'Gamification',
    Resultat: 'Resultat',
    TestQuestion: 'TestQuestion',
    Depot: 'Depot'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'specialite' | 'niveau' | 'espaceCours' | 'theme' | 'espaceDepot' | 'ressource' | 'test' | 'banqueQuestion' | 'reponse' | 'commentaire' | 'user' | 'etudiant' | 'enseingant' | 'admin' | 'gamification' | 'resultat' | 'testQuestion' | 'depot'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Specialite: {
        payload: Prisma.$SpecialitePayload<ExtArgs>
        fields: Prisma.SpecialiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialiteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialiteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          findFirst: {
            args: Prisma.SpecialiteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialiteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          findMany: {
            args: Prisma.SpecialiteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>[]
          }
          create: {
            args: Prisma.SpecialiteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          createMany: {
            args: Prisma.SpecialiteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpecialiteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          update: {
            args: Prisma.SpecialiteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          deleteMany: {
            args: Prisma.SpecialiteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialiteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpecialiteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          aggregate: {
            args: Prisma.SpecialiteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpecialite>
          }
          groupBy: {
            args: Prisma.SpecialiteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpecialiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialiteCountArgs<ExtArgs>,
            result: $Utils.Optional<SpecialiteCountAggregateOutputType> | number
          }
        }
      }
      Niveau: {
        payload: Prisma.$NiveauPayload<ExtArgs>
        fields: Prisma.NiveauFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NiveauFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NiveauFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>
          }
          findFirst: {
            args: Prisma.NiveauFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NiveauFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>
          }
          findMany: {
            args: Prisma.NiveauFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>[]
          }
          create: {
            args: Prisma.NiveauCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>
          }
          createMany: {
            args: Prisma.NiveauCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NiveauDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>
          }
          update: {
            args: Prisma.NiveauUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>
          }
          deleteMany: {
            args: Prisma.NiveauDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NiveauUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NiveauUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NiveauPayload>
          }
          aggregate: {
            args: Prisma.NiveauAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNiveau>
          }
          groupBy: {
            args: Prisma.NiveauGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NiveauGroupByOutputType>[]
          }
          count: {
            args: Prisma.NiveauCountArgs<ExtArgs>,
            result: $Utils.Optional<NiveauCountAggregateOutputType> | number
          }
        }
      }
      EspaceCours: {
        payload: Prisma.$EspaceCoursPayload<ExtArgs>
        fields: Prisma.EspaceCoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspaceCoursFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspaceCoursFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>
          }
          findFirst: {
            args: Prisma.EspaceCoursFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspaceCoursFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>
          }
          findMany: {
            args: Prisma.EspaceCoursFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>[]
          }
          create: {
            args: Prisma.EspaceCoursCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>
          }
          createMany: {
            args: Prisma.EspaceCoursCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EspaceCoursDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>
          }
          update: {
            args: Prisma.EspaceCoursUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>
          }
          deleteMany: {
            args: Prisma.EspaceCoursDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EspaceCoursUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EspaceCoursUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceCoursPayload>
          }
          aggregate: {
            args: Prisma.EspaceCoursAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEspaceCours>
          }
          groupBy: {
            args: Prisma.EspaceCoursGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EspaceCoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspaceCoursCountArgs<ExtArgs>,
            result: $Utils.Optional<EspaceCoursCountAggregateOutputType> | number
          }
        }
      }
      Theme: {
        payload: Prisma.$ThemePayload<ExtArgs>
        fields: Prisma.ThemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findFirst: {
            args: Prisma.ThemeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findMany: {
            args: Prisma.ThemeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          create: {
            args: Prisma.ThemeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          createMany: {
            args: Prisma.ThemeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ThemeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          update: {
            args: Prisma.ThemeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          deleteMany: {
            args: Prisma.ThemeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ThemeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          aggregate: {
            args: Prisma.ThemeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTheme>
          }
          groupBy: {
            args: Prisma.ThemeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ThemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeCountArgs<ExtArgs>,
            result: $Utils.Optional<ThemeCountAggregateOutputType> | number
          }
        }
      }
      EspaceDepot: {
        payload: Prisma.$EspaceDepotPayload<ExtArgs>
        fields: Prisma.EspaceDepotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspaceDepotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspaceDepotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>
          }
          findFirst: {
            args: Prisma.EspaceDepotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspaceDepotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>
          }
          findMany: {
            args: Prisma.EspaceDepotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>[]
          }
          create: {
            args: Prisma.EspaceDepotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>
          }
          createMany: {
            args: Prisma.EspaceDepotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EspaceDepotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>
          }
          update: {
            args: Prisma.EspaceDepotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>
          }
          deleteMany: {
            args: Prisma.EspaceDepotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EspaceDepotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EspaceDepotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspaceDepotPayload>
          }
          aggregate: {
            args: Prisma.EspaceDepotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEspaceDepot>
          }
          groupBy: {
            args: Prisma.EspaceDepotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EspaceDepotGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspaceDepotCountArgs<ExtArgs>,
            result: $Utils.Optional<EspaceDepotCountAggregateOutputType> | number
          }
        }
      }
      Ressource: {
        payload: Prisma.$RessourcePayload<ExtArgs>
        fields: Prisma.RessourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RessourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RessourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          findFirst: {
            args: Prisma.RessourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RessourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          findMany: {
            args: Prisma.RessourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>[]
          }
          create: {
            args: Prisma.RessourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          createMany: {
            args: Prisma.RessourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RessourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          update: {
            args: Prisma.RessourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          deleteMany: {
            args: Prisma.RessourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RessourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RessourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          aggregate: {
            args: Prisma.RessourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRessource>
          }
          groupBy: {
            args: Prisma.RessourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RessourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RessourceCountArgs<ExtArgs>,
            result: $Utils.Optional<RessourceCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>,
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      BanqueQuestion: {
        payload: Prisma.$BanqueQuestionPayload<ExtArgs>
        fields: Prisma.BanqueQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BanqueQuestionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BanqueQuestionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>
          }
          findFirst: {
            args: Prisma.BanqueQuestionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BanqueQuestionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>
          }
          findMany: {
            args: Prisma.BanqueQuestionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>[]
          }
          create: {
            args: Prisma.BanqueQuestionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>
          }
          createMany: {
            args: Prisma.BanqueQuestionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BanqueQuestionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>
          }
          update: {
            args: Prisma.BanqueQuestionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>
          }
          deleteMany: {
            args: Prisma.BanqueQuestionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BanqueQuestionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BanqueQuestionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanqueQuestionPayload>
          }
          aggregate: {
            args: Prisma.BanqueQuestionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanqueQuestion>
          }
          groupBy: {
            args: Prisma.BanqueQuestionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BanqueQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BanqueQuestionCountArgs<ExtArgs>,
            result: $Utils.Optional<BanqueQuestionCountAggregateOutputType> | number
          }
        }
      }
      Reponse: {
        payload: Prisma.$ReponsePayload<ExtArgs>
        fields: Prisma.ReponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReponseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReponseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>
          }
          findFirst: {
            args: Prisma.ReponseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReponseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>
          }
          findMany: {
            args: Prisma.ReponseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>[]
          }
          create: {
            args: Prisma.ReponseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>
          }
          createMany: {
            args: Prisma.ReponseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReponseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>
          }
          update: {
            args: Prisma.ReponseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>
          }
          deleteMany: {
            args: Prisma.ReponseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReponseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReponseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReponsePayload>
          }
          aggregate: {
            args: Prisma.ReponseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReponse>
          }
          groupBy: {
            args: Prisma.ReponseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReponseCountArgs<ExtArgs>,
            result: $Utils.Optional<ReponseCountAggregateOutputType> | number
          }
        }
      }
      Commentaire: {
        payload: Prisma.$CommentairePayload<ExtArgs>
        fields: Prisma.CommentaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentaireFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentaireFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          findFirst: {
            args: Prisma.CommentaireFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentaireFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          findMany: {
            args: Prisma.CommentaireFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>[]
          }
          create: {
            args: Prisma.CommentaireCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          createMany: {
            args: Prisma.CommentaireCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentaireDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          update: {
            args: Prisma.CommentaireUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          deleteMany: {
            args: Prisma.CommentaireDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentaireUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentaireUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          aggregate: {
            args: Prisma.CommentaireAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommentaire>
          }
          groupBy: {
            args: Prisma.CommentaireGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentaireCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentaireCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Etudiant: {
        payload: Prisma.$EtudiantPayload<ExtArgs>
        fields: Prisma.EtudiantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtudiantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtudiantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          findFirst: {
            args: Prisma.EtudiantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtudiantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          findMany: {
            args: Prisma.EtudiantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>[]
          }
          create: {
            args: Prisma.EtudiantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          createMany: {
            args: Prisma.EtudiantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EtudiantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          update: {
            args: Prisma.EtudiantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          deleteMany: {
            args: Prisma.EtudiantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EtudiantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EtudiantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          aggregate: {
            args: Prisma.EtudiantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEtudiant>
          }
          groupBy: {
            args: Prisma.EtudiantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EtudiantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtudiantCountArgs<ExtArgs>,
            result: $Utils.Optional<EtudiantCountAggregateOutputType> | number
          }
        }
      }
      Enseingant: {
        payload: Prisma.$EnseingantPayload<ExtArgs>
        fields: Prisma.EnseingantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnseingantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnseingantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>
          }
          findFirst: {
            args: Prisma.EnseingantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnseingantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>
          }
          findMany: {
            args: Prisma.EnseingantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>[]
          }
          create: {
            args: Prisma.EnseingantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>
          }
          createMany: {
            args: Prisma.EnseingantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnseingantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>
          }
          update: {
            args: Prisma.EnseingantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>
          }
          deleteMany: {
            args: Prisma.EnseingantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnseingantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnseingantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnseingantPayload>
          }
          aggregate: {
            args: Prisma.EnseingantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnseingant>
          }
          groupBy: {
            args: Prisma.EnseingantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnseingantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnseingantCountArgs<ExtArgs>,
            result: $Utils.Optional<EnseingantCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Gamification: {
        payload: Prisma.$GamificationPayload<ExtArgs>
        fields: Prisma.GamificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GamificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GamificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          findFirst: {
            args: Prisma.GamificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GamificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          findMany: {
            args: Prisma.GamificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>[]
          }
          create: {
            args: Prisma.GamificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          createMany: {
            args: Prisma.GamificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GamificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          update: {
            args: Prisma.GamificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          deleteMany: {
            args: Prisma.GamificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GamificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GamificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          aggregate: {
            args: Prisma.GamificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGamification>
          }
          groupBy: {
            args: Prisma.GamificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GamificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GamificationCountArgs<ExtArgs>,
            result: $Utils.Optional<GamificationCountAggregateOutputType> | number
          }
        }
      }
      Resultat: {
        payload: Prisma.$ResultatPayload<ExtArgs>
        fields: Prisma.ResultatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>
          }
          findFirst: {
            args: Prisma.ResultatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>
          }
          findMany: {
            args: Prisma.ResultatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>[]
          }
          create: {
            args: Prisma.ResultatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>
          }
          createMany: {
            args: Prisma.ResultatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResultatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>
          }
          update: {
            args: Prisma.ResultatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>
          }
          deleteMany: {
            args: Prisma.ResultatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResultatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResultatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResultatPayload>
          }
          aggregate: {
            args: Prisma.ResultatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResultat>
          }
          groupBy: {
            args: Prisma.ResultatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResultatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultatCountArgs<ExtArgs>,
            result: $Utils.Optional<ResultatCountAggregateOutputType> | number
          }
        }
      }
      TestQuestion: {
        payload: Prisma.$TestQuestionPayload<ExtArgs>
        fields: Prisma.TestQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestQuestionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestQuestionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>
          }
          findFirst: {
            args: Prisma.TestQuestionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestQuestionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>
          }
          findMany: {
            args: Prisma.TestQuestionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>[]
          }
          create: {
            args: Prisma.TestQuestionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>
          }
          createMany: {
            args: Prisma.TestQuestionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TestQuestionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>
          }
          update: {
            args: Prisma.TestQuestionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>
          }
          deleteMany: {
            args: Prisma.TestQuestionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TestQuestionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TestQuestionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestQuestionPayload>
          }
          aggregate: {
            args: Prisma.TestQuestionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTestQuestion>
          }
          groupBy: {
            args: Prisma.TestQuestionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TestQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestQuestionCountArgs<ExtArgs>,
            result: $Utils.Optional<TestQuestionCountAggregateOutputType> | number
          }
        }
      }
      Depot: {
        payload: Prisma.$DepotPayload<ExtArgs>
        fields: Prisma.DepotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>
          }
          findFirst: {
            args: Prisma.DepotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>
          }
          findMany: {
            args: Prisma.DepotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>[]
          }
          create: {
            args: Prisma.DepotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>
          }
          createMany: {
            args: Prisma.DepotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DepotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>
          }
          update: {
            args: Prisma.DepotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>
          }
          deleteMany: {
            args: Prisma.DepotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DepotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DepotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepotPayload>
          }
          aggregate: {
            args: Prisma.DepotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDepot>
          }
          groupBy: {
            args: Prisma.DepotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DepotGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepotCountArgs<ExtArgs>,
            result: $Utils.Optional<DepotCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SpecialiteCountOutputType
   */

  export type SpecialiteCountOutputType = {
    Niveau: number
  }

  export type SpecialiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Niveau?: boolean | SpecialiteCountOutputTypeCountNiveauArgs
  }

  // Custom InputTypes

  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialiteCountOutputType
     */
    select?: SpecialiteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeCountNiveauArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NiveauWhereInput
  }



  /**
   * Count Type NiveauCountOutputType
   */

  export type NiveauCountOutputType = {
    EspaceCours: number
  }

  export type NiveauCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EspaceCours?: boolean | NiveauCountOutputTypeCountEspaceCoursArgs
  }

  // Custom InputTypes

  /**
   * NiveauCountOutputType without action
   */
  export type NiveauCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NiveauCountOutputType
     */
    select?: NiveauCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NiveauCountOutputType without action
   */
  export type NiveauCountOutputTypeCountEspaceCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspaceCoursWhereInput
  }



  /**
   * Count Type EspaceCoursCountOutputType
   */

  export type EspaceCoursCountOutputType = {
    Theme: number
    BanqueQuestion: number
    Gamification: number
  }

  export type EspaceCoursCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Theme?: boolean | EspaceCoursCountOutputTypeCountThemeArgs
    BanqueQuestion?: boolean | EspaceCoursCountOutputTypeCountBanqueQuestionArgs
    Gamification?: boolean | EspaceCoursCountOutputTypeCountGamificationArgs
  }

  // Custom InputTypes

  /**
   * EspaceCoursCountOutputType without action
   */
  export type EspaceCoursCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCoursCountOutputType
     */
    select?: EspaceCoursCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EspaceCoursCountOutputType without action
   */
  export type EspaceCoursCountOutputTypeCountThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
  }


  /**
   * EspaceCoursCountOutputType without action
   */
  export type EspaceCoursCountOutputTypeCountBanqueQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanqueQuestionWhereInput
  }


  /**
   * EspaceCoursCountOutputType without action
   */
  export type EspaceCoursCountOutputTypeCountGamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamificationWhereInput
  }



  /**
   * Count Type ThemeCountOutputType
   */

  export type ThemeCountOutputType = {
    EspaceDepot: number
    Ressource: number
    Test: number
  }

  export type ThemeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EspaceDepot?: boolean | ThemeCountOutputTypeCountEspaceDepotArgs
    Ressource?: boolean | ThemeCountOutputTypeCountRessourceArgs
    Test?: boolean | ThemeCountOutputTypeCountTestArgs
  }

  // Custom InputTypes

  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeCountOutputType
     */
    select?: ThemeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeCountEspaceDepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspaceDepotWhereInput
  }


  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeCountRessourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RessourceWhereInput
  }


  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeCountTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
  }



  /**
   * Count Type EspaceDepotCountOutputType
   */

  export type EspaceDepotCountOutputType = {
    Depot: number
  }

  export type EspaceDepotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Depot?: boolean | EspaceDepotCountOutputTypeCountDepotArgs
  }

  // Custom InputTypes

  /**
   * EspaceDepotCountOutputType without action
   */
  export type EspaceDepotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepotCountOutputType
     */
    select?: EspaceDepotCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EspaceDepotCountOutputType without action
   */
  export type EspaceDepotCountOutputTypeCountDepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepotWhereInput
  }



  /**
   * Count Type RessourceCountOutputType
   */

  export type RessourceCountOutputType = {
    Commentaire: number
  }

  export type RessourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Commentaire?: boolean | RessourceCountOutputTypeCountCommentaireArgs
  }

  // Custom InputTypes

  /**
   * RessourceCountOutputType without action
   */
  export type RessourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RessourceCountOutputType
     */
    select?: RessourceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RessourceCountOutputType without action
   */
  export type RessourceCountOutputTypeCountCommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }



  /**
   * Count Type TestCountOutputType
   */

  export type TestCountOutputType = {
    Resultat: number
    TestQuestion: number
  }

  export type TestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Resultat?: boolean | TestCountOutputTypeCountResultatArgs
    TestQuestion?: boolean | TestCountOutputTypeCountTestQuestionArgs
  }

  // Custom InputTypes

  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCountOutputType
     */
    select?: TestCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountResultatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultatWhereInput
  }


  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountTestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestQuestionWhereInput
  }



  /**
   * Count Type BanqueQuestionCountOutputType
   */

  export type BanqueQuestionCountOutputType = {
    Reponse: number
    TestQuestion: number
  }

  export type BanqueQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Reponse?: boolean | BanqueQuestionCountOutputTypeCountReponseArgs
    TestQuestion?: boolean | BanqueQuestionCountOutputTypeCountTestQuestionArgs
  }

  // Custom InputTypes

  /**
   * BanqueQuestionCountOutputType without action
   */
  export type BanqueQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestionCountOutputType
     */
    select?: BanqueQuestionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BanqueQuestionCountOutputType without action
   */
  export type BanqueQuestionCountOutputTypeCountReponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReponseWhereInput
  }


  /**
   * BanqueQuestionCountOutputType without action
   */
  export type BanqueQuestionCountOutputTypeCountTestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestQuestionWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Commentaire: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Commentaire?: boolean | UserCountOutputTypeCountCommentaireArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }



  /**
   * Count Type EtudiantCountOutputType
   */

  export type EtudiantCountOutputType = {
    Gamification: number
    Resultat: number
    Depot: number
  }

  export type EtudiantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Gamification?: boolean | EtudiantCountOutputTypeCountGamificationArgs
    Resultat?: boolean | EtudiantCountOutputTypeCountResultatArgs
    Depot?: boolean | EtudiantCountOutputTypeCountDepotArgs
  }

  // Custom InputTypes

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantCountOutputType
     */
    select?: EtudiantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountGamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamificationWhereInput
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountResultatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultatWhereInput
  }


  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountDepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepotWhereInput
  }



  /**
   * Count Type EnseingantCountOutputType
   */

  export type EnseingantCountOutputType = {
    EspaceCours: number
  }

  export type EnseingantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EspaceCours?: boolean | EnseingantCountOutputTypeCountEspaceCoursArgs
  }

  // Custom InputTypes

  /**
   * EnseingantCountOutputType without action
   */
  export type EnseingantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnseingantCountOutputType
     */
    select?: EnseingantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EnseingantCountOutputType without action
   */
  export type EnseingantCountOutputTypeCountEspaceCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspaceCoursWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Specialite
   */

  export type AggregateSpecialite = {
    _count: SpecialiteCountAggregateOutputType | null
    _avg: SpecialiteAvgAggregateOutputType | null
    _sum: SpecialiteSumAggregateOutputType | null
    _min: SpecialiteMinAggregateOutputType | null
    _max: SpecialiteMaxAggregateOutputType | null
  }

  export type SpecialiteAvgAggregateOutputType = {
    id: number | null
  }

  export type SpecialiteSumAggregateOutputType = {
    id: number | null
  }

  export type SpecialiteMinAggregateOutputType = {
    id: number | null
    nom: string | null
    image: string | null
  }

  export type SpecialiteMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    image: string | null
  }

  export type SpecialiteCountAggregateOutputType = {
    id: number
    nom: number
    image: number
    _all: number
  }


  export type SpecialiteAvgAggregateInputType = {
    id?: true
  }

  export type SpecialiteSumAggregateInputType = {
    id?: true
  }

  export type SpecialiteMinAggregateInputType = {
    id?: true
    nom?: true
    image?: true
  }

  export type SpecialiteMaxAggregateInputType = {
    id?: true
    nom?: true
    image?: true
  }

  export type SpecialiteCountAggregateInputType = {
    id?: true
    nom?: true
    image?: true
    _all?: true
  }

  export type SpecialiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialite to aggregate.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialites
    **/
    _count?: true | SpecialiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialiteMaxAggregateInputType
  }

  export type GetSpecialiteAggregateType<T extends SpecialiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialite[P]>
      : GetScalarType<T[P], AggregateSpecialite[P]>
  }




  export type SpecialiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialiteWhereInput
    orderBy?: SpecialiteOrderByWithAggregationInput | SpecialiteOrderByWithAggregationInput[]
    by: SpecialiteScalarFieldEnum[] | SpecialiteScalarFieldEnum
    having?: SpecialiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialiteCountAggregateInputType | true
    _avg?: SpecialiteAvgAggregateInputType
    _sum?: SpecialiteSumAggregateInputType
    _min?: SpecialiteMinAggregateInputType
    _max?: SpecialiteMaxAggregateInputType
  }

  export type SpecialiteGroupByOutputType = {
    id: number
    nom: string
    image: string
    _count: SpecialiteCountAggregateOutputType | null
    _avg: SpecialiteAvgAggregateOutputType | null
    _sum: SpecialiteSumAggregateOutputType | null
    _min: SpecialiteMinAggregateOutputType | null
    _max: SpecialiteMaxAggregateOutputType | null
  }

  type GetSpecialiteGroupByPayload<T extends SpecialiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialiteGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialiteGroupByOutputType[P]>
        }
      >
    >


  export type SpecialiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    image?: boolean
    Niveau?: boolean | Specialite$NiveauArgs<ExtArgs>
    _count?: boolean | SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialite"]>

  export type SpecialiteSelectScalar = {
    id?: boolean
    nom?: boolean
    image?: boolean
  }

  export type SpecialiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Niveau?: boolean | Specialite$NiveauArgs<ExtArgs>
    _count?: boolean | SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SpecialitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialite"
    objects: {
      Niveau: Prisma.$NiveauPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      image: string
    }, ExtArgs["result"]["specialite"]>
    composites: {}
  }


  type SpecialiteGetPayload<S extends boolean | null | undefined | SpecialiteDefaultArgs> = $Result.GetResult<Prisma.$SpecialitePayload, S>

  type SpecialiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpecialiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpecialiteCountAggregateInputType | true
    }

  export interface SpecialiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialite'], meta: { name: 'Specialite' } }
    /**
     * Find zero or one Specialite that matches the filter.
     * @param {SpecialiteFindUniqueArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecialiteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteFindUniqueArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Specialite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpecialiteFindUniqueOrThrowArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpecialiteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Specialite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindFirstArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecialiteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindFirstArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Specialite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindFirstOrThrowArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpecialiteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Specialites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialites
     * const specialites = await prisma.specialite.findMany()
     * 
     * // Get first 10 Specialites
     * const specialites = await prisma.specialite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialiteWithIdOnly = await prisma.specialite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecialiteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Specialite.
     * @param {SpecialiteCreateArgs} args - Arguments to create a Specialite.
     * @example
     * // Create one Specialite
     * const Specialite = await prisma.specialite.create({
     *   data: {
     *     // ... data to create a Specialite
     *   }
     * })
     * 
    **/
    create<T extends SpecialiteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteCreateArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Specialites.
     *     @param {SpecialiteCreateManyArgs} args - Arguments to create many Specialites.
     *     @example
     *     // Create many Specialites
     *     const specialite = await prisma.specialite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecialiteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Specialite.
     * @param {SpecialiteDeleteArgs} args - Arguments to delete one Specialite.
     * @example
     * // Delete one Specialite
     * const Specialite = await prisma.specialite.delete({
     *   where: {
     *     // ... filter to delete one Specialite
     *   }
     * })
     * 
    **/
    delete<T extends SpecialiteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteDeleteArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Specialite.
     * @param {SpecialiteUpdateArgs} args - Arguments to update one Specialite.
     * @example
     * // Update one Specialite
     * const specialite = await prisma.specialite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecialiteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteUpdateArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Specialites.
     * @param {SpecialiteDeleteManyArgs} args - Arguments to filter Specialites to delete.
     * @example
     * // Delete a few Specialites
     * const { count } = await prisma.specialite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecialiteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialiteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialites
     * const specialite = await prisma.specialite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecialiteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialite.
     * @param {SpecialiteUpsertArgs} args - Arguments to update or create a Specialite.
     * @example
     * // Update or create a Specialite
     * const specialite = await prisma.specialite.upsert({
     *   create: {
     *     // ... data to create a Specialite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialite we want to update
     *   }
     * })
    **/
    upsert<T extends SpecialiteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialiteUpsertArgs<ExtArgs>>
    ): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Specialites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteCountArgs} args - Arguments to filter Specialites to count.
     * @example
     * // Count the number of Specialites
     * const count = await prisma.specialite.count({
     *   where: {
     *     // ... the filter for the Specialites we want to count
     *   }
     * })
    **/
    count<T extends SpecialiteCountArgs>(
      args?: Subset<T, SpecialiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialiteAggregateArgs>(args: Subset<T, SpecialiteAggregateArgs>): Prisma.PrismaPromise<GetSpecialiteAggregateType<T>>

    /**
     * Group by Specialite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialiteGroupByArgs['orderBy'] }
        : { orderBy?: SpecialiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialite model
   */
  readonly fields: SpecialiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Niveau<T extends Specialite$NiveauArgs<ExtArgs> = {}>(args?: Subset<T, Specialite$NiveauArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Specialite model
   */ 
  interface SpecialiteFieldRefs {
    readonly id: FieldRef<"Specialite", 'Int'>
    readonly nom: FieldRef<"Specialite", 'String'>
    readonly image: FieldRef<"Specialite", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Specialite findUnique
   */
  export type SpecialiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite findUniqueOrThrow
   */
  export type SpecialiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite findFirst
   */
  export type SpecialiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialites.
     */
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Specialite findFirstOrThrow
   */
  export type SpecialiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialites.
     */
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Specialite findMany
   */
  export type SpecialiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialites to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }


  /**
   * Specialite create
   */
  export type SpecialiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialite.
     */
    data: XOR<SpecialiteCreateInput, SpecialiteUncheckedCreateInput>
  }


  /**
   * Specialite createMany
   */
  export type SpecialiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialites.
     */
    data: SpecialiteCreateManyInput | SpecialiteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Specialite update
   */
  export type SpecialiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialite.
     */
    data: XOR<SpecialiteUpdateInput, SpecialiteUncheckedUpdateInput>
    /**
     * Choose, which Specialite to update.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite updateMany
   */
  export type SpecialiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialites.
     */
    data: XOR<SpecialiteUpdateManyMutationInput, SpecialiteUncheckedUpdateManyInput>
    /**
     * Filter which Specialites to update
     */
    where?: SpecialiteWhereInput
  }


  /**
   * Specialite upsert
   */
  export type SpecialiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialite to update in case it exists.
     */
    where: SpecialiteWhereUniqueInput
    /**
     * In case the Specialite found by the `where` argument doesn't exist, create a new Specialite with this data.
     */
    create: XOR<SpecialiteCreateInput, SpecialiteUncheckedCreateInput>
    /**
     * In case the Specialite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialiteUpdateInput, SpecialiteUncheckedUpdateInput>
  }


  /**
   * Specialite delete
   */
  export type SpecialiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter which Specialite to delete.
     */
    where: SpecialiteWhereUniqueInput
  }


  /**
   * Specialite deleteMany
   */
  export type SpecialiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialites to delete
     */
    where?: SpecialiteWhereInput
  }


  /**
   * Specialite.Niveau
   */
  export type Specialite$NiveauArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    where?: NiveauWhereInput
    orderBy?: NiveauOrderByWithRelationInput | NiveauOrderByWithRelationInput[]
    cursor?: NiveauWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NiveauScalarFieldEnum | NiveauScalarFieldEnum[]
  }


  /**
   * Specialite without action
   */
  export type SpecialiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialiteInclude<ExtArgs> | null
  }



  /**
   * Model Niveau
   */

  export type AggregateNiveau = {
    _count: NiveauCountAggregateOutputType | null
    _avg: NiveauAvgAggregateOutputType | null
    _sum: NiveauSumAggregateOutputType | null
    _min: NiveauMinAggregateOutputType | null
    _max: NiveauMaxAggregateOutputType | null
  }

  export type NiveauAvgAggregateOutputType = {
    id: number | null
    num: number | null
    specialiteId: number | null
  }

  export type NiveauSumAggregateOutputType = {
    id: number | null
    num: number | null
    specialiteId: number | null
  }

  export type NiveauMinAggregateOutputType = {
    id: number | null
    num: number | null
    specialiteId: number | null
  }

  export type NiveauMaxAggregateOutputType = {
    id: number | null
    num: number | null
    specialiteId: number | null
  }

  export type NiveauCountAggregateOutputType = {
    id: number
    num: number
    specialiteId: number
    _all: number
  }


  export type NiveauAvgAggregateInputType = {
    id?: true
    num?: true
    specialiteId?: true
  }

  export type NiveauSumAggregateInputType = {
    id?: true
    num?: true
    specialiteId?: true
  }

  export type NiveauMinAggregateInputType = {
    id?: true
    num?: true
    specialiteId?: true
  }

  export type NiveauMaxAggregateInputType = {
    id?: true
    num?: true
    specialiteId?: true
  }

  export type NiveauCountAggregateInputType = {
    id?: true
    num?: true
    specialiteId?: true
    _all?: true
  }

  export type NiveauAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Niveau to aggregate.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: NiveauOrderByWithRelationInput | NiveauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Niveaus
    **/
    _count?: true | NiveauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NiveauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NiveauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NiveauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NiveauMaxAggregateInputType
  }

  export type GetNiveauAggregateType<T extends NiveauAggregateArgs> = {
        [P in keyof T & keyof AggregateNiveau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNiveau[P]>
      : GetScalarType<T[P], AggregateNiveau[P]>
  }




  export type NiveauGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NiveauWhereInput
    orderBy?: NiveauOrderByWithAggregationInput | NiveauOrderByWithAggregationInput[]
    by: NiveauScalarFieldEnum[] | NiveauScalarFieldEnum
    having?: NiveauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NiveauCountAggregateInputType | true
    _avg?: NiveauAvgAggregateInputType
    _sum?: NiveauSumAggregateInputType
    _min?: NiveauMinAggregateInputType
    _max?: NiveauMaxAggregateInputType
  }

  export type NiveauGroupByOutputType = {
    id: number
    num: number
    specialiteId: number
    _count: NiveauCountAggregateOutputType | null
    _avg: NiveauAvgAggregateOutputType | null
    _sum: NiveauSumAggregateOutputType | null
    _min: NiveauMinAggregateOutputType | null
    _max: NiveauMaxAggregateOutputType | null
  }

  type GetNiveauGroupByPayload<T extends NiveauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NiveauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NiveauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NiveauGroupByOutputType[P]>
            : GetScalarType<T[P], NiveauGroupByOutputType[P]>
        }
      >
    >


  export type NiveauSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    num?: boolean
    specialiteId?: boolean
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    EspaceCours?: boolean | Niveau$EspaceCoursArgs<ExtArgs>
    _count?: boolean | NiveauCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["niveau"]>

  export type NiveauSelectScalar = {
    id?: boolean
    num?: boolean
    specialiteId?: boolean
  }

  export type NiveauInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    EspaceCours?: boolean | Niveau$EspaceCoursArgs<ExtArgs>
    _count?: boolean | NiveauCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NiveauPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Niveau"
    objects: {
      specialite: Prisma.$SpecialitePayload<ExtArgs>
      EspaceCours: Prisma.$EspaceCoursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      num: number
      specialiteId: number
    }, ExtArgs["result"]["niveau"]>
    composites: {}
  }


  type NiveauGetPayload<S extends boolean | null | undefined | NiveauDefaultArgs> = $Result.GetResult<Prisma.$NiveauPayload, S>

  type NiveauCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NiveauFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NiveauCountAggregateInputType | true
    }

  export interface NiveauDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Niveau'], meta: { name: 'Niveau' } }
    /**
     * Find zero or one Niveau that matches the filter.
     * @param {NiveauFindUniqueArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NiveauFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauFindUniqueArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Niveau that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NiveauFindUniqueOrThrowArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NiveauFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Niveau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauFindFirstArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NiveauFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindFirstArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Niveau that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauFindFirstOrThrowArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NiveauFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Niveaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Niveaus
     * const niveaus = await prisma.niveau.findMany()
     * 
     * // Get first 10 Niveaus
     * const niveaus = await prisma.niveau.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const niveauWithIdOnly = await prisma.niveau.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NiveauFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Niveau.
     * @param {NiveauCreateArgs} args - Arguments to create a Niveau.
     * @example
     * // Create one Niveau
     * const Niveau = await prisma.niveau.create({
     *   data: {
     *     // ... data to create a Niveau
     *   }
     * })
     * 
    **/
    create<T extends NiveauCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauCreateArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Niveaus.
     *     @param {NiveauCreateManyArgs} args - Arguments to create many Niveaus.
     *     @example
     *     // Create many Niveaus
     *     const niveau = await prisma.niveau.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NiveauCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Niveau.
     * @param {NiveauDeleteArgs} args - Arguments to delete one Niveau.
     * @example
     * // Delete one Niveau
     * const Niveau = await prisma.niveau.delete({
     *   where: {
     *     // ... filter to delete one Niveau
     *   }
     * })
     * 
    **/
    delete<T extends NiveauDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauDeleteArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Niveau.
     * @param {NiveauUpdateArgs} args - Arguments to update one Niveau.
     * @example
     * // Update one Niveau
     * const niveau = await prisma.niveau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NiveauUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauUpdateArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Niveaus.
     * @param {NiveauDeleteManyArgs} args - Arguments to filter Niveaus to delete.
     * @example
     * // Delete a few Niveaus
     * const { count } = await prisma.niveau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NiveauDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Niveaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Niveaus
     * const niveau = await prisma.niveau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NiveauUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Niveau.
     * @param {NiveauUpsertArgs} args - Arguments to update or create a Niveau.
     * @example
     * // Update or create a Niveau
     * const niveau = await prisma.niveau.upsert({
     *   create: {
     *     // ... data to create a Niveau
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Niveau we want to update
     *   }
     * })
    **/
    upsert<T extends NiveauUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauUpsertArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Niveaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauCountArgs} args - Arguments to filter Niveaus to count.
     * @example
     * // Count the number of Niveaus
     * const count = await prisma.niveau.count({
     *   where: {
     *     // ... the filter for the Niveaus we want to count
     *   }
     * })
    **/
    count<T extends NiveauCountArgs>(
      args?: Subset<T, NiveauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NiveauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Niveau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NiveauAggregateArgs>(args: Subset<T, NiveauAggregateArgs>): Prisma.PrismaPromise<GetNiveauAggregateType<T>>

    /**
     * Group by Niveau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NiveauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NiveauGroupByArgs['orderBy'] }
        : { orderBy?: NiveauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NiveauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNiveauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Niveau model
   */
  readonly fields: NiveauFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Niveau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NiveauClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    specialite<T extends SpecialiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialiteDefaultArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    EspaceCours<T extends Niveau$EspaceCoursArgs<ExtArgs> = {}>(args?: Subset<T, Niveau$EspaceCoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Niveau model
   */ 
  interface NiveauFieldRefs {
    readonly id: FieldRef<"Niveau", 'Int'>
    readonly num: FieldRef<"Niveau", 'Int'>
    readonly specialiteId: FieldRef<"Niveau", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Niveau findUnique
   */
  export type NiveauFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau findUniqueOrThrow
   */
  export type NiveauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau findFirst
   */
  export type NiveauFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: NiveauOrderByWithRelationInput | NiveauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Niveaus.
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Niveaus.
     */
    distinct?: NiveauScalarFieldEnum | NiveauScalarFieldEnum[]
  }


  /**
   * Niveau findFirstOrThrow
   */
  export type NiveauFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: NiveauOrderByWithRelationInput | NiveauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Niveaus.
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Niveaus.
     */
    distinct?: NiveauScalarFieldEnum | NiveauScalarFieldEnum[]
  }


  /**
   * Niveau findMany
   */
  export type NiveauFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveaus to fetch.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: NiveauOrderByWithRelationInput | NiveauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Niveaus.
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    distinct?: NiveauScalarFieldEnum | NiveauScalarFieldEnum[]
  }


  /**
   * Niveau create
   */
  export type NiveauCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * The data needed to create a Niveau.
     */
    data: XOR<NiveauCreateInput, NiveauUncheckedCreateInput>
  }


  /**
   * Niveau createMany
   */
  export type NiveauCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Niveaus.
     */
    data: NiveauCreateManyInput | NiveauCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Niveau update
   */
  export type NiveauUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * The data needed to update a Niveau.
     */
    data: XOR<NiveauUpdateInput, NiveauUncheckedUpdateInput>
    /**
     * Choose, which Niveau to update.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau updateMany
   */
  export type NiveauUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Niveaus.
     */
    data: XOR<NiveauUpdateManyMutationInput, NiveauUncheckedUpdateManyInput>
    /**
     * Filter which Niveaus to update
     */
    where?: NiveauWhereInput
  }


  /**
   * Niveau upsert
   */
  export type NiveauUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * The filter to search for the Niveau to update in case it exists.
     */
    where: NiveauWhereUniqueInput
    /**
     * In case the Niveau found by the `where` argument doesn't exist, create a new Niveau with this data.
     */
    create: XOR<NiveauCreateInput, NiveauUncheckedCreateInput>
    /**
     * In case the Niveau was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NiveauUpdateInput, NiveauUncheckedUpdateInput>
  }


  /**
   * Niveau delete
   */
  export type NiveauDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter which Niveau to delete.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau deleteMany
   */
  export type NiveauDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Niveaus to delete
     */
    where?: NiveauWhereInput
  }


  /**
   * Niveau.EspaceCours
   */
  export type Niveau$EspaceCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    where?: EspaceCoursWhereInput
    orderBy?: EspaceCoursOrderByWithRelationInput | EspaceCoursOrderByWithRelationInput[]
    cursor?: EspaceCoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspaceCoursScalarFieldEnum | EspaceCoursScalarFieldEnum[]
  }


  /**
   * Niveau without action
   */
  export type NiveauDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
  }



  /**
   * Model EspaceCours
   */

  export type AggregateEspaceCours = {
    _count: EspaceCoursCountAggregateOutputType | null
    _avg: EspaceCoursAvgAggregateOutputType | null
    _sum: EspaceCoursSumAggregateOutputType | null
    _min: EspaceCoursMinAggregateOutputType | null
    _max: EspaceCoursMaxAggregateOutputType | null
  }

  export type EspaceCoursAvgAggregateOutputType = {
    id: number | null
    niveauId: number | null
    enseingantId: number | null
  }

  export type EspaceCoursSumAggregateOutputType = {
    id: number | null
    niveauId: number | null
    enseingantId: number | null
  }

  export type EspaceCoursMinAggregateOutputType = {
    id: number | null
    nom: string | null
    image: string | null
    cleAccee: string | null
    niveauId: number | null
    enseingantId: number | null
  }

  export type EspaceCoursMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    image: string | null
    cleAccee: string | null
    niveauId: number | null
    enseingantId: number | null
  }

  export type EspaceCoursCountAggregateOutputType = {
    id: number
    nom: number
    image: number
    cleAccee: number
    niveauId: number
    enseingantId: number
    _all: number
  }


  export type EspaceCoursAvgAggregateInputType = {
    id?: true
    niveauId?: true
    enseingantId?: true
  }

  export type EspaceCoursSumAggregateInputType = {
    id?: true
    niveauId?: true
    enseingantId?: true
  }

  export type EspaceCoursMinAggregateInputType = {
    id?: true
    nom?: true
    image?: true
    cleAccee?: true
    niveauId?: true
    enseingantId?: true
  }

  export type EspaceCoursMaxAggregateInputType = {
    id?: true
    nom?: true
    image?: true
    cleAccee?: true
    niveauId?: true
    enseingantId?: true
  }

  export type EspaceCoursCountAggregateInputType = {
    id?: true
    nom?: true
    image?: true
    cleAccee?: true
    niveauId?: true
    enseingantId?: true
    _all?: true
  }

  export type EspaceCoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspaceCours to aggregate.
     */
    where?: EspaceCoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceCours to fetch.
     */
    orderBy?: EspaceCoursOrderByWithRelationInput | EspaceCoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspaceCoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceCours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceCours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EspaceCours
    **/
    _count?: true | EspaceCoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspaceCoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspaceCoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspaceCoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspaceCoursMaxAggregateInputType
  }

  export type GetEspaceCoursAggregateType<T extends EspaceCoursAggregateArgs> = {
        [P in keyof T & keyof AggregateEspaceCours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspaceCours[P]>
      : GetScalarType<T[P], AggregateEspaceCours[P]>
  }




  export type EspaceCoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspaceCoursWhereInput
    orderBy?: EspaceCoursOrderByWithAggregationInput | EspaceCoursOrderByWithAggregationInput[]
    by: EspaceCoursScalarFieldEnum[] | EspaceCoursScalarFieldEnum
    having?: EspaceCoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspaceCoursCountAggregateInputType | true
    _avg?: EspaceCoursAvgAggregateInputType
    _sum?: EspaceCoursSumAggregateInputType
    _min?: EspaceCoursMinAggregateInputType
    _max?: EspaceCoursMaxAggregateInputType
  }

  export type EspaceCoursGroupByOutputType = {
    id: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    enseingantId: number
    _count: EspaceCoursCountAggregateOutputType | null
    _avg: EspaceCoursAvgAggregateOutputType | null
    _sum: EspaceCoursSumAggregateOutputType | null
    _min: EspaceCoursMinAggregateOutputType | null
    _max: EspaceCoursMaxAggregateOutputType | null
  }

  type GetEspaceCoursGroupByPayload<T extends EspaceCoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspaceCoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspaceCoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspaceCoursGroupByOutputType[P]>
            : GetScalarType<T[P], EspaceCoursGroupByOutputType[P]>
        }
      >
    >


  export type EspaceCoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    image?: boolean
    cleAccee?: boolean
    niveauId?: boolean
    enseingantId?: boolean
    niveau?: boolean | NiveauDefaultArgs<ExtArgs>
    enseingant?: boolean | EnseingantDefaultArgs<ExtArgs>
    Theme?: boolean | EspaceCours$ThemeArgs<ExtArgs>
    BanqueQuestion?: boolean | EspaceCours$BanqueQuestionArgs<ExtArgs>
    Gamification?: boolean | EspaceCours$GamificationArgs<ExtArgs>
    _count?: boolean | EspaceCoursCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["espaceCours"]>

  export type EspaceCoursSelectScalar = {
    id?: boolean
    nom?: boolean
    image?: boolean
    cleAccee?: boolean
    niveauId?: boolean
    enseingantId?: boolean
  }

  export type EspaceCoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    niveau?: boolean | NiveauDefaultArgs<ExtArgs>
    enseingant?: boolean | EnseingantDefaultArgs<ExtArgs>
    Theme?: boolean | EspaceCours$ThemeArgs<ExtArgs>
    BanqueQuestion?: boolean | EspaceCours$BanqueQuestionArgs<ExtArgs>
    Gamification?: boolean | EspaceCours$GamificationArgs<ExtArgs>
    _count?: boolean | EspaceCoursCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EspaceCoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EspaceCours"
    objects: {
      niveau: Prisma.$NiveauPayload<ExtArgs>
      enseingant: Prisma.$EnseingantPayload<ExtArgs>
      Theme: Prisma.$ThemePayload<ExtArgs>[]
      BanqueQuestion: Prisma.$BanqueQuestionPayload<ExtArgs>[]
      Gamification: Prisma.$GamificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      image: string
      cleAccee: string
      niveauId: number
      enseingantId: number
    }, ExtArgs["result"]["espaceCours"]>
    composites: {}
  }


  type EspaceCoursGetPayload<S extends boolean | null | undefined | EspaceCoursDefaultArgs> = $Result.GetResult<Prisma.$EspaceCoursPayload, S>

  type EspaceCoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspaceCoursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspaceCoursCountAggregateInputType | true
    }

  export interface EspaceCoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EspaceCours'], meta: { name: 'EspaceCours' } }
    /**
     * Find zero or one EspaceCours that matches the filter.
     * @param {EspaceCoursFindUniqueArgs} args - Arguments to find a EspaceCours
     * @example
     * // Get one EspaceCours
     * const espaceCours = await prisma.espaceCours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EspaceCoursFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceCoursFindUniqueArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EspaceCours that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EspaceCoursFindUniqueOrThrowArgs} args - Arguments to find a EspaceCours
     * @example
     * // Get one EspaceCours
     * const espaceCours = await prisma.espaceCours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EspaceCoursFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceCoursFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EspaceCours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursFindFirstArgs} args - Arguments to find a EspaceCours
     * @example
     * // Get one EspaceCours
     * const espaceCours = await prisma.espaceCours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EspaceCoursFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceCoursFindFirstArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EspaceCours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursFindFirstOrThrowArgs} args - Arguments to find a EspaceCours
     * @example
     * // Get one EspaceCours
     * const espaceCours = await prisma.espaceCours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EspaceCoursFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceCoursFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EspaceCours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EspaceCours
     * const espaceCours = await prisma.espaceCours.findMany()
     * 
     * // Get first 10 EspaceCours
     * const espaceCours = await prisma.espaceCours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const espaceCoursWithIdOnly = await prisma.espaceCours.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EspaceCoursFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceCoursFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EspaceCours.
     * @param {EspaceCoursCreateArgs} args - Arguments to create a EspaceCours.
     * @example
     * // Create one EspaceCours
     * const EspaceCours = await prisma.espaceCours.create({
     *   data: {
     *     // ... data to create a EspaceCours
     *   }
     * })
     * 
    **/
    create<T extends EspaceCoursCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceCoursCreateArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EspaceCours.
     *     @param {EspaceCoursCreateManyArgs} args - Arguments to create many EspaceCours.
     *     @example
     *     // Create many EspaceCours
     *     const espaceCours = await prisma.espaceCours.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EspaceCoursCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceCoursCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EspaceCours.
     * @param {EspaceCoursDeleteArgs} args - Arguments to delete one EspaceCours.
     * @example
     * // Delete one EspaceCours
     * const EspaceCours = await prisma.espaceCours.delete({
     *   where: {
     *     // ... filter to delete one EspaceCours
     *   }
     * })
     * 
    **/
    delete<T extends EspaceCoursDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceCoursDeleteArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EspaceCours.
     * @param {EspaceCoursUpdateArgs} args - Arguments to update one EspaceCours.
     * @example
     * // Update one EspaceCours
     * const espaceCours = await prisma.espaceCours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EspaceCoursUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceCoursUpdateArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EspaceCours.
     * @param {EspaceCoursDeleteManyArgs} args - Arguments to filter EspaceCours to delete.
     * @example
     * // Delete a few EspaceCours
     * const { count } = await prisma.espaceCours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EspaceCoursDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceCoursDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EspaceCours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EspaceCours
     * const espaceCours = await prisma.espaceCours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EspaceCoursUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceCoursUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EspaceCours.
     * @param {EspaceCoursUpsertArgs} args - Arguments to update or create a EspaceCours.
     * @example
     * // Update or create a EspaceCours
     * const espaceCours = await prisma.espaceCours.upsert({
     *   create: {
     *     // ... data to create a EspaceCours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EspaceCours we want to update
     *   }
     * })
    **/
    upsert<T extends EspaceCoursUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceCoursUpsertArgs<ExtArgs>>
    ): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EspaceCours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursCountArgs} args - Arguments to filter EspaceCours to count.
     * @example
     * // Count the number of EspaceCours
     * const count = await prisma.espaceCours.count({
     *   where: {
     *     // ... the filter for the EspaceCours we want to count
     *   }
     * })
    **/
    count<T extends EspaceCoursCountArgs>(
      args?: Subset<T, EspaceCoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspaceCoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EspaceCours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspaceCoursAggregateArgs>(args: Subset<T, EspaceCoursAggregateArgs>): Prisma.PrismaPromise<GetEspaceCoursAggregateType<T>>

    /**
     * Group by EspaceCours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceCoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspaceCoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspaceCoursGroupByArgs['orderBy'] }
        : { orderBy?: EspaceCoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspaceCoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspaceCoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EspaceCours model
   */
  readonly fields: EspaceCoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EspaceCours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspaceCoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    niveau<T extends NiveauDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NiveauDefaultArgs<ExtArgs>>): Prisma__NiveauClient<$Result.GetResult<Prisma.$NiveauPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    enseingant<T extends EnseingantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnseingantDefaultArgs<ExtArgs>>): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Theme<T extends EspaceCours$ThemeArgs<ExtArgs> = {}>(args?: Subset<T, EspaceCours$ThemeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findMany'> | Null>;

    BanqueQuestion<T extends EspaceCours$BanqueQuestionArgs<ExtArgs> = {}>(args?: Subset<T, EspaceCours$BanqueQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findMany'> | Null>;

    Gamification<T extends EspaceCours$GamificationArgs<ExtArgs> = {}>(args?: Subset<T, EspaceCours$GamificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EspaceCours model
   */ 
  interface EspaceCoursFieldRefs {
    readonly id: FieldRef<"EspaceCours", 'Int'>
    readonly nom: FieldRef<"EspaceCours", 'String'>
    readonly image: FieldRef<"EspaceCours", 'String'>
    readonly cleAccee: FieldRef<"EspaceCours", 'String'>
    readonly niveauId: FieldRef<"EspaceCours", 'Int'>
    readonly enseingantId: FieldRef<"EspaceCours", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EspaceCours findUnique
   */
  export type EspaceCoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * Filter, which EspaceCours to fetch.
     */
    where: EspaceCoursWhereUniqueInput
  }


  /**
   * EspaceCours findUniqueOrThrow
   */
  export type EspaceCoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * Filter, which EspaceCours to fetch.
     */
    where: EspaceCoursWhereUniqueInput
  }


  /**
   * EspaceCours findFirst
   */
  export type EspaceCoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * Filter, which EspaceCours to fetch.
     */
    where?: EspaceCoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceCours to fetch.
     */
    orderBy?: EspaceCoursOrderByWithRelationInput | EspaceCoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspaceCours.
     */
    cursor?: EspaceCoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceCours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceCours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspaceCours.
     */
    distinct?: EspaceCoursScalarFieldEnum | EspaceCoursScalarFieldEnum[]
  }


  /**
   * EspaceCours findFirstOrThrow
   */
  export type EspaceCoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * Filter, which EspaceCours to fetch.
     */
    where?: EspaceCoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceCours to fetch.
     */
    orderBy?: EspaceCoursOrderByWithRelationInput | EspaceCoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspaceCours.
     */
    cursor?: EspaceCoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceCours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceCours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspaceCours.
     */
    distinct?: EspaceCoursScalarFieldEnum | EspaceCoursScalarFieldEnum[]
  }


  /**
   * EspaceCours findMany
   */
  export type EspaceCoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * Filter, which EspaceCours to fetch.
     */
    where?: EspaceCoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceCours to fetch.
     */
    orderBy?: EspaceCoursOrderByWithRelationInput | EspaceCoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EspaceCours.
     */
    cursor?: EspaceCoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceCours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceCours.
     */
    skip?: number
    distinct?: EspaceCoursScalarFieldEnum | EspaceCoursScalarFieldEnum[]
  }


  /**
   * EspaceCours create
   */
  export type EspaceCoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * The data needed to create a EspaceCours.
     */
    data: XOR<EspaceCoursCreateInput, EspaceCoursUncheckedCreateInput>
  }


  /**
   * EspaceCours createMany
   */
  export type EspaceCoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EspaceCours.
     */
    data: EspaceCoursCreateManyInput | EspaceCoursCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EspaceCours update
   */
  export type EspaceCoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * The data needed to update a EspaceCours.
     */
    data: XOR<EspaceCoursUpdateInput, EspaceCoursUncheckedUpdateInput>
    /**
     * Choose, which EspaceCours to update.
     */
    where: EspaceCoursWhereUniqueInput
  }


  /**
   * EspaceCours updateMany
   */
  export type EspaceCoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EspaceCours.
     */
    data: XOR<EspaceCoursUpdateManyMutationInput, EspaceCoursUncheckedUpdateManyInput>
    /**
     * Filter which EspaceCours to update
     */
    where?: EspaceCoursWhereInput
  }


  /**
   * EspaceCours upsert
   */
  export type EspaceCoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * The filter to search for the EspaceCours to update in case it exists.
     */
    where: EspaceCoursWhereUniqueInput
    /**
     * In case the EspaceCours found by the `where` argument doesn't exist, create a new EspaceCours with this data.
     */
    create: XOR<EspaceCoursCreateInput, EspaceCoursUncheckedCreateInput>
    /**
     * In case the EspaceCours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspaceCoursUpdateInput, EspaceCoursUncheckedUpdateInput>
  }


  /**
   * EspaceCours delete
   */
  export type EspaceCoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    /**
     * Filter which EspaceCours to delete.
     */
    where: EspaceCoursWhereUniqueInput
  }


  /**
   * EspaceCours deleteMany
   */
  export type EspaceCoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspaceCours to delete
     */
    where?: EspaceCoursWhereInput
  }


  /**
   * EspaceCours.Theme
   */
  export type EspaceCours$ThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    cursor?: ThemeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * EspaceCours.BanqueQuestion
   */
  export type EspaceCours$BanqueQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    where?: BanqueQuestionWhereInput
    orderBy?: BanqueQuestionOrderByWithRelationInput | BanqueQuestionOrderByWithRelationInput[]
    cursor?: BanqueQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BanqueQuestionScalarFieldEnum | BanqueQuestionScalarFieldEnum[]
  }


  /**
   * EspaceCours.Gamification
   */
  export type EspaceCours$GamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    where?: GamificationWhereInput
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    cursor?: GamificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }


  /**
   * EspaceCours without action
   */
  export type EspaceCoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
  }



  /**
   * Model Theme
   */

  export type AggregateTheme = {
    _count: ThemeCountAggregateOutputType | null
    _avg: ThemeAvgAggregateOutputType | null
    _sum: ThemeSumAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  export type ThemeAvgAggregateOutputType = {
    id: number | null
    espaceCoursId: number | null
  }

  export type ThemeSumAggregateOutputType = {
    id: number | null
    espaceCoursId: number | null
  }

  export type ThemeMinAggregateOutputType = {
    id: number | null
    nom: string | null
    espaceCoursId: number | null
  }

  export type ThemeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    espaceCoursId: number | null
  }

  export type ThemeCountAggregateOutputType = {
    id: number
    nom: number
    espaceCoursId: number
    _all: number
  }


  export type ThemeAvgAggregateInputType = {
    id?: true
    espaceCoursId?: true
  }

  export type ThemeSumAggregateInputType = {
    id?: true
    espaceCoursId?: true
  }

  export type ThemeMinAggregateInputType = {
    id?: true
    nom?: true
    espaceCoursId?: true
  }

  export type ThemeMaxAggregateInputType = {
    id?: true
    nom?: true
    espaceCoursId?: true
  }

  export type ThemeCountAggregateInputType = {
    id?: true
    nom?: true
    espaceCoursId?: true
    _all?: true
  }

  export type ThemeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theme to aggregate.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Themes
    **/
    _count?: true | ThemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThemeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThemeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeMaxAggregateInputType
  }

  export type GetThemeAggregateType<T extends ThemeAggregateArgs> = {
        [P in keyof T & keyof AggregateTheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTheme[P]>
      : GetScalarType<T[P], AggregateTheme[P]>
  }




  export type ThemeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithAggregationInput | ThemeOrderByWithAggregationInput[]
    by: ThemeScalarFieldEnum[] | ThemeScalarFieldEnum
    having?: ThemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeCountAggregateInputType | true
    _avg?: ThemeAvgAggregateInputType
    _sum?: ThemeSumAggregateInputType
    _min?: ThemeMinAggregateInputType
    _max?: ThemeMaxAggregateInputType
  }

  export type ThemeGroupByOutputType = {
    id: number
    nom: string
    espaceCoursId: number
    _count: ThemeCountAggregateOutputType | null
    _avg: ThemeAvgAggregateOutputType | null
    _sum: ThemeSumAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  type GetThemeGroupByPayload<T extends ThemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeGroupByOutputType[P]>
        }
      >
    >


  export type ThemeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    espaceCoursId?: boolean
    espaceCours?: boolean | EspaceCoursDefaultArgs<ExtArgs>
    EspaceDepot?: boolean | Theme$EspaceDepotArgs<ExtArgs>
    Ressource?: boolean | Theme$RessourceArgs<ExtArgs>
    Test?: boolean | Theme$TestArgs<ExtArgs>
    _count?: boolean | ThemeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectScalar = {
    id?: boolean
    nom?: boolean
    espaceCoursId?: boolean
  }

  export type ThemeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    espaceCours?: boolean | EspaceCoursDefaultArgs<ExtArgs>
    EspaceDepot?: boolean | Theme$EspaceDepotArgs<ExtArgs>
    Ressource?: boolean | Theme$RessourceArgs<ExtArgs>
    Test?: boolean | Theme$TestArgs<ExtArgs>
    _count?: boolean | ThemeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ThemePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Theme"
    objects: {
      espaceCours: Prisma.$EspaceCoursPayload<ExtArgs>
      EspaceDepot: Prisma.$EspaceDepotPayload<ExtArgs>[]
      Ressource: Prisma.$RessourcePayload<ExtArgs>[]
      Test: Prisma.$TestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      espaceCoursId: number
    }, ExtArgs["result"]["theme"]>
    composites: {}
  }


  type ThemeGetPayload<S extends boolean | null | undefined | ThemeDefaultArgs> = $Result.GetResult<Prisma.$ThemePayload, S>

  type ThemeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ThemeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ThemeCountAggregateInputType | true
    }

  export interface ThemeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Theme'], meta: { name: 'Theme' } }
    /**
     * Find zero or one Theme that matches the filter.
     * @param {ThemeFindUniqueArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThemeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeFindUniqueArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Theme that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThemeFindUniqueOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThemeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Theme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThemeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindFirstArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Theme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThemeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Themes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Themes
     * const themes = await prisma.theme.findMany()
     * 
     * // Get first 10 Themes
     * const themes = await prisma.theme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themeWithIdOnly = await prisma.theme.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ThemeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Theme.
     * @param {ThemeCreateArgs} args - Arguments to create a Theme.
     * @example
     * // Create one Theme
     * const Theme = await prisma.theme.create({
     *   data: {
     *     // ... data to create a Theme
     *   }
     * })
     * 
    **/
    create<T extends ThemeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeCreateArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Themes.
     *     @param {ThemeCreateManyArgs} args - Arguments to create many Themes.
     *     @example
     *     // Create many Themes
     *     const theme = await prisma.theme.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThemeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Theme.
     * @param {ThemeDeleteArgs} args - Arguments to delete one Theme.
     * @example
     * // Delete one Theme
     * const Theme = await prisma.theme.delete({
     *   where: {
     *     // ... filter to delete one Theme
     *   }
     * })
     * 
    **/
    delete<T extends ThemeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeDeleteArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Theme.
     * @param {ThemeUpdateArgs} args - Arguments to update one Theme.
     * @example
     * // Update one Theme
     * const theme = await prisma.theme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThemeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeUpdateArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Themes.
     * @param {ThemeDeleteManyArgs} args - Arguments to filter Themes to delete.
     * @example
     * // Delete a few Themes
     * const { count } = await prisma.theme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThemeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThemeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Theme.
     * @param {ThemeUpsertArgs} args - Arguments to update or create a Theme.
     * @example
     * // Update or create a Theme
     * const theme = await prisma.theme.upsert({
     *   create: {
     *     // ... data to create a Theme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Theme we want to update
     *   }
     * })
    **/
    upsert<T extends ThemeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeUpsertArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeCountArgs} args - Arguments to filter Themes to count.
     * @example
     * // Count the number of Themes
     * const count = await prisma.theme.count({
     *   where: {
     *     // ... the filter for the Themes we want to count
     *   }
     * })
    **/
    count<T extends ThemeCountArgs>(
      args?: Subset<T, ThemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeAggregateArgs>(args: Subset<T, ThemeAggregateArgs>): Prisma.PrismaPromise<GetThemeAggregateType<T>>

    /**
     * Group by Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeGroupByArgs['orderBy'] }
        : { orderBy?: ThemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Theme model
   */
  readonly fields: ThemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Theme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    espaceCours<T extends EspaceCoursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspaceCoursDefaultArgs<ExtArgs>>): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    EspaceDepot<T extends Theme$EspaceDepotArgs<ExtArgs> = {}>(args?: Subset<T, Theme$EspaceDepotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findMany'> | Null>;

    Ressource<T extends Theme$RessourceArgs<ExtArgs> = {}>(args?: Subset<T, Theme$RessourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findMany'> | Null>;

    Test<T extends Theme$TestArgs<ExtArgs> = {}>(args?: Subset<T, Theme$TestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Theme model
   */ 
  interface ThemeFieldRefs {
    readonly id: FieldRef<"Theme", 'Int'>
    readonly nom: FieldRef<"Theme", 'String'>
    readonly espaceCoursId: FieldRef<"Theme", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Theme findUnique
   */
  export type ThemeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme findUniqueOrThrow
   */
  export type ThemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme findFirst
   */
  export type ThemeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * Theme findFirstOrThrow
   */
  export type ThemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * Theme findMany
   */
  export type ThemeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Themes to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * Theme create
   */
  export type ThemeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to create a Theme.
     */
    data: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
  }


  /**
   * Theme createMany
   */
  export type ThemeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Theme update
   */
  export type ThemeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to update a Theme.
     */
    data: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
    /**
     * Choose, which Theme to update.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme updateMany
   */
  export type ThemeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
  }


  /**
   * Theme upsert
   */
  export type ThemeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The filter to search for the Theme to update in case it exists.
     */
    where: ThemeWhereUniqueInput
    /**
     * In case the Theme found by the `where` argument doesn't exist, create a new Theme with this data.
     */
    create: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
    /**
     * In case the Theme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
  }


  /**
   * Theme delete
   */
  export type ThemeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter which Theme to delete.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme deleteMany
   */
  export type ThemeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Themes to delete
     */
    where?: ThemeWhereInput
  }


  /**
   * Theme.EspaceDepot
   */
  export type Theme$EspaceDepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    where?: EspaceDepotWhereInput
    orderBy?: EspaceDepotOrderByWithRelationInput | EspaceDepotOrderByWithRelationInput[]
    cursor?: EspaceDepotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspaceDepotScalarFieldEnum | EspaceDepotScalarFieldEnum[]
  }


  /**
   * Theme.Ressource
   */
  export type Theme$RessourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    where?: RessourceWhereInput
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    cursor?: RessourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }


  /**
   * Theme.Test
   */
  export type Theme$TestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    where?: TestWhereInput
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    cursor?: TestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }


  /**
   * Theme without action
   */
  export type ThemeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
  }



  /**
   * Model EspaceDepot
   */

  export type AggregateEspaceDepot = {
    _count: EspaceDepotCountAggregateOutputType | null
    _avg: EspaceDepotAvgAggregateOutputType | null
    _sum: EspaceDepotSumAggregateOutputType | null
    _min: EspaceDepotMinAggregateOutputType | null
    _max: EspaceDepotMaxAggregateOutputType | null
  }

  export type EspaceDepotAvgAggregateOutputType = {
    id: number | null
    themeId: number | null
  }

  export type EspaceDepotSumAggregateOutputType = {
    id: number | null
    themeId: number | null
  }

  export type EspaceDepotMinAggregateOutputType = {
    id: number | null
    nom: string | null
    type: $Enums.TypeFile | null
    themeId: number | null
    dateDebut: Date | null
    dateFin: Date | null
  }

  export type EspaceDepotMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    type: $Enums.TypeFile | null
    themeId: number | null
    dateDebut: Date | null
    dateFin: Date | null
  }

  export type EspaceDepotCountAggregateOutputType = {
    id: number
    nom: number
    type: number
    themeId: number
    dateDebut: number
    dateFin: number
    _all: number
  }


  export type EspaceDepotAvgAggregateInputType = {
    id?: true
    themeId?: true
  }

  export type EspaceDepotSumAggregateInputType = {
    id?: true
    themeId?: true
  }

  export type EspaceDepotMinAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    themeId?: true
    dateDebut?: true
    dateFin?: true
  }

  export type EspaceDepotMaxAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    themeId?: true
    dateDebut?: true
    dateFin?: true
  }

  export type EspaceDepotCountAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    themeId?: true
    dateDebut?: true
    dateFin?: true
    _all?: true
  }

  export type EspaceDepotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspaceDepot to aggregate.
     */
    where?: EspaceDepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceDepots to fetch.
     */
    orderBy?: EspaceDepotOrderByWithRelationInput | EspaceDepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspaceDepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceDepots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceDepots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EspaceDepots
    **/
    _count?: true | EspaceDepotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspaceDepotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspaceDepotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspaceDepotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspaceDepotMaxAggregateInputType
  }

  export type GetEspaceDepotAggregateType<T extends EspaceDepotAggregateArgs> = {
        [P in keyof T & keyof AggregateEspaceDepot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspaceDepot[P]>
      : GetScalarType<T[P], AggregateEspaceDepot[P]>
  }




  export type EspaceDepotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspaceDepotWhereInput
    orderBy?: EspaceDepotOrderByWithAggregationInput | EspaceDepotOrderByWithAggregationInput[]
    by: EspaceDepotScalarFieldEnum[] | EspaceDepotScalarFieldEnum
    having?: EspaceDepotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspaceDepotCountAggregateInputType | true
    _avg?: EspaceDepotAvgAggregateInputType
    _sum?: EspaceDepotSumAggregateInputType
    _min?: EspaceDepotMinAggregateInputType
    _max?: EspaceDepotMaxAggregateInputType
  }

  export type EspaceDepotGroupByOutputType = {
    id: number
    nom: string
    type: $Enums.TypeFile
    themeId: number
    dateDebut: Date
    dateFin: Date
    _count: EspaceDepotCountAggregateOutputType | null
    _avg: EspaceDepotAvgAggregateOutputType | null
    _sum: EspaceDepotSumAggregateOutputType | null
    _min: EspaceDepotMinAggregateOutputType | null
    _max: EspaceDepotMaxAggregateOutputType | null
  }

  type GetEspaceDepotGroupByPayload<T extends EspaceDepotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspaceDepotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspaceDepotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspaceDepotGroupByOutputType[P]>
            : GetScalarType<T[P], EspaceDepotGroupByOutputType[P]>
        }
      >
    >


  export type EspaceDepotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type?: boolean
    themeId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
    Depot?: boolean | EspaceDepot$DepotArgs<ExtArgs>
    _count?: boolean | EspaceDepotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["espaceDepot"]>

  export type EspaceDepotSelectScalar = {
    id?: boolean
    nom?: boolean
    type?: boolean
    themeId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
  }

  export type EspaceDepotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
    Depot?: boolean | EspaceDepot$DepotArgs<ExtArgs>
    _count?: boolean | EspaceDepotCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EspaceDepotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EspaceDepot"
    objects: {
      theme: Prisma.$ThemePayload<ExtArgs>
      Depot: Prisma.$DepotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      type: $Enums.TypeFile
      themeId: number
      dateDebut: Date
      dateFin: Date
    }, ExtArgs["result"]["espaceDepot"]>
    composites: {}
  }


  type EspaceDepotGetPayload<S extends boolean | null | undefined | EspaceDepotDefaultArgs> = $Result.GetResult<Prisma.$EspaceDepotPayload, S>

  type EspaceDepotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspaceDepotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspaceDepotCountAggregateInputType | true
    }

  export interface EspaceDepotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EspaceDepot'], meta: { name: 'EspaceDepot' } }
    /**
     * Find zero or one EspaceDepot that matches the filter.
     * @param {EspaceDepotFindUniqueArgs} args - Arguments to find a EspaceDepot
     * @example
     * // Get one EspaceDepot
     * const espaceDepot = await prisma.espaceDepot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EspaceDepotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceDepotFindUniqueArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EspaceDepot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EspaceDepotFindUniqueOrThrowArgs} args - Arguments to find a EspaceDepot
     * @example
     * // Get one EspaceDepot
     * const espaceDepot = await prisma.espaceDepot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EspaceDepotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceDepotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EspaceDepot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotFindFirstArgs} args - Arguments to find a EspaceDepot
     * @example
     * // Get one EspaceDepot
     * const espaceDepot = await prisma.espaceDepot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EspaceDepotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceDepotFindFirstArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EspaceDepot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotFindFirstOrThrowArgs} args - Arguments to find a EspaceDepot
     * @example
     * // Get one EspaceDepot
     * const espaceDepot = await prisma.espaceDepot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EspaceDepotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceDepotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EspaceDepots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EspaceDepots
     * const espaceDepots = await prisma.espaceDepot.findMany()
     * 
     * // Get first 10 EspaceDepots
     * const espaceDepots = await prisma.espaceDepot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const espaceDepotWithIdOnly = await prisma.espaceDepot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EspaceDepotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceDepotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EspaceDepot.
     * @param {EspaceDepotCreateArgs} args - Arguments to create a EspaceDepot.
     * @example
     * // Create one EspaceDepot
     * const EspaceDepot = await prisma.espaceDepot.create({
     *   data: {
     *     // ... data to create a EspaceDepot
     *   }
     * })
     * 
    **/
    create<T extends EspaceDepotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceDepotCreateArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EspaceDepots.
     *     @param {EspaceDepotCreateManyArgs} args - Arguments to create many EspaceDepots.
     *     @example
     *     // Create many EspaceDepots
     *     const espaceDepot = await prisma.espaceDepot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EspaceDepotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceDepotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EspaceDepot.
     * @param {EspaceDepotDeleteArgs} args - Arguments to delete one EspaceDepot.
     * @example
     * // Delete one EspaceDepot
     * const EspaceDepot = await prisma.espaceDepot.delete({
     *   where: {
     *     // ... filter to delete one EspaceDepot
     *   }
     * })
     * 
    **/
    delete<T extends EspaceDepotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceDepotDeleteArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EspaceDepot.
     * @param {EspaceDepotUpdateArgs} args - Arguments to update one EspaceDepot.
     * @example
     * // Update one EspaceDepot
     * const espaceDepot = await prisma.espaceDepot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EspaceDepotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceDepotUpdateArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EspaceDepots.
     * @param {EspaceDepotDeleteManyArgs} args - Arguments to filter EspaceDepots to delete.
     * @example
     * // Delete a few EspaceDepots
     * const { count } = await prisma.espaceDepot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EspaceDepotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspaceDepotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EspaceDepots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EspaceDepots
     * const espaceDepot = await prisma.espaceDepot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EspaceDepotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceDepotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EspaceDepot.
     * @param {EspaceDepotUpsertArgs} args - Arguments to update or create a EspaceDepot.
     * @example
     * // Update or create a EspaceDepot
     * const espaceDepot = await prisma.espaceDepot.upsert({
     *   create: {
     *     // ... data to create a EspaceDepot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EspaceDepot we want to update
     *   }
     * })
    **/
    upsert<T extends EspaceDepotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EspaceDepotUpsertArgs<ExtArgs>>
    ): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EspaceDepots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotCountArgs} args - Arguments to filter EspaceDepots to count.
     * @example
     * // Count the number of EspaceDepots
     * const count = await prisma.espaceDepot.count({
     *   where: {
     *     // ... the filter for the EspaceDepots we want to count
     *   }
     * })
    **/
    count<T extends EspaceDepotCountArgs>(
      args?: Subset<T, EspaceDepotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspaceDepotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EspaceDepot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspaceDepotAggregateArgs>(args: Subset<T, EspaceDepotAggregateArgs>): Prisma.PrismaPromise<GetEspaceDepotAggregateType<T>>

    /**
     * Group by EspaceDepot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspaceDepotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspaceDepotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspaceDepotGroupByArgs['orderBy'] }
        : { orderBy?: EspaceDepotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspaceDepotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspaceDepotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EspaceDepot model
   */
  readonly fields: EspaceDepotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EspaceDepot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspaceDepotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    theme<T extends ThemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThemeDefaultArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Depot<T extends EspaceDepot$DepotArgs<ExtArgs> = {}>(args?: Subset<T, EspaceDepot$DepotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EspaceDepot model
   */ 
  interface EspaceDepotFieldRefs {
    readonly id: FieldRef<"EspaceDepot", 'Int'>
    readonly nom: FieldRef<"EspaceDepot", 'String'>
    readonly type: FieldRef<"EspaceDepot", 'TypeFile'>
    readonly themeId: FieldRef<"EspaceDepot", 'Int'>
    readonly dateDebut: FieldRef<"EspaceDepot", 'DateTime'>
    readonly dateFin: FieldRef<"EspaceDepot", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EspaceDepot findUnique
   */
  export type EspaceDepotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * Filter, which EspaceDepot to fetch.
     */
    where: EspaceDepotWhereUniqueInput
  }


  /**
   * EspaceDepot findUniqueOrThrow
   */
  export type EspaceDepotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * Filter, which EspaceDepot to fetch.
     */
    where: EspaceDepotWhereUniqueInput
  }


  /**
   * EspaceDepot findFirst
   */
  export type EspaceDepotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * Filter, which EspaceDepot to fetch.
     */
    where?: EspaceDepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceDepots to fetch.
     */
    orderBy?: EspaceDepotOrderByWithRelationInput | EspaceDepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspaceDepots.
     */
    cursor?: EspaceDepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceDepots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceDepots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspaceDepots.
     */
    distinct?: EspaceDepotScalarFieldEnum | EspaceDepotScalarFieldEnum[]
  }


  /**
   * EspaceDepot findFirstOrThrow
   */
  export type EspaceDepotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * Filter, which EspaceDepot to fetch.
     */
    where?: EspaceDepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceDepots to fetch.
     */
    orderBy?: EspaceDepotOrderByWithRelationInput | EspaceDepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspaceDepots.
     */
    cursor?: EspaceDepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceDepots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceDepots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspaceDepots.
     */
    distinct?: EspaceDepotScalarFieldEnum | EspaceDepotScalarFieldEnum[]
  }


  /**
   * EspaceDepot findMany
   */
  export type EspaceDepotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * Filter, which EspaceDepots to fetch.
     */
    where?: EspaceDepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspaceDepots to fetch.
     */
    orderBy?: EspaceDepotOrderByWithRelationInput | EspaceDepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EspaceDepots.
     */
    cursor?: EspaceDepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspaceDepots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspaceDepots.
     */
    skip?: number
    distinct?: EspaceDepotScalarFieldEnum | EspaceDepotScalarFieldEnum[]
  }


  /**
   * EspaceDepot create
   */
  export type EspaceDepotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * The data needed to create a EspaceDepot.
     */
    data: XOR<EspaceDepotCreateInput, EspaceDepotUncheckedCreateInput>
  }


  /**
   * EspaceDepot createMany
   */
  export type EspaceDepotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EspaceDepots.
     */
    data: EspaceDepotCreateManyInput | EspaceDepotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EspaceDepot update
   */
  export type EspaceDepotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * The data needed to update a EspaceDepot.
     */
    data: XOR<EspaceDepotUpdateInput, EspaceDepotUncheckedUpdateInput>
    /**
     * Choose, which EspaceDepot to update.
     */
    where: EspaceDepotWhereUniqueInput
  }


  /**
   * EspaceDepot updateMany
   */
  export type EspaceDepotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EspaceDepots.
     */
    data: XOR<EspaceDepotUpdateManyMutationInput, EspaceDepotUncheckedUpdateManyInput>
    /**
     * Filter which EspaceDepots to update
     */
    where?: EspaceDepotWhereInput
  }


  /**
   * EspaceDepot upsert
   */
  export type EspaceDepotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * The filter to search for the EspaceDepot to update in case it exists.
     */
    where: EspaceDepotWhereUniqueInput
    /**
     * In case the EspaceDepot found by the `where` argument doesn't exist, create a new EspaceDepot with this data.
     */
    create: XOR<EspaceDepotCreateInput, EspaceDepotUncheckedCreateInput>
    /**
     * In case the EspaceDepot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspaceDepotUpdateInput, EspaceDepotUncheckedUpdateInput>
  }


  /**
   * EspaceDepot delete
   */
  export type EspaceDepotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
    /**
     * Filter which EspaceDepot to delete.
     */
    where: EspaceDepotWhereUniqueInput
  }


  /**
   * EspaceDepot deleteMany
   */
  export type EspaceDepotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspaceDepots to delete
     */
    where?: EspaceDepotWhereInput
  }


  /**
   * EspaceDepot.Depot
   */
  export type EspaceDepot$DepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    where?: DepotWhereInput
    orderBy?: DepotOrderByWithRelationInput | DepotOrderByWithRelationInput[]
    cursor?: DepotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepotScalarFieldEnum | DepotScalarFieldEnum[]
  }


  /**
   * EspaceDepot without action
   */
  export type EspaceDepotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceDepot
     */
    select?: EspaceDepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceDepotInclude<ExtArgs> | null
  }



  /**
   * Model Ressource
   */

  export type AggregateRessource = {
    _count: RessourceCountAggregateOutputType | null
    _avg: RessourceAvgAggregateOutputType | null
    _sum: RessourceSumAggregateOutputType | null
    _min: RessourceMinAggregateOutputType | null
    _max: RessourceMaxAggregateOutputType | null
  }

  export type RessourceAvgAggregateOutputType = {
    id: number | null
    themeId: number | null
  }

  export type RessourceSumAggregateOutputType = {
    id: number | null
    themeId: number | null
  }

  export type RessourceMinAggregateOutputType = {
    id: number | null
    nom: string | null
    file: string | null
    type: $Enums.TypeFile | null
    themeId: number | null
    dateDepot: Date | null
  }

  export type RessourceMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    file: string | null
    type: $Enums.TypeFile | null
    themeId: number | null
    dateDepot: Date | null
  }

  export type RessourceCountAggregateOutputType = {
    id: number
    nom: number
    file: number
    type: number
    themeId: number
    dateDepot: number
    _all: number
  }


  export type RessourceAvgAggregateInputType = {
    id?: true
    themeId?: true
  }

  export type RessourceSumAggregateInputType = {
    id?: true
    themeId?: true
  }

  export type RessourceMinAggregateInputType = {
    id?: true
    nom?: true
    file?: true
    type?: true
    themeId?: true
    dateDepot?: true
  }

  export type RessourceMaxAggregateInputType = {
    id?: true
    nom?: true
    file?: true
    type?: true
    themeId?: true
    dateDepot?: true
  }

  export type RessourceCountAggregateInputType = {
    id?: true
    nom?: true
    file?: true
    type?: true
    themeId?: true
    dateDepot?: true
    _all?: true
  }

  export type RessourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ressource to aggregate.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ressources
    **/
    _count?: true | RessourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RessourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RessourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RessourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RessourceMaxAggregateInputType
  }

  export type GetRessourceAggregateType<T extends RessourceAggregateArgs> = {
        [P in keyof T & keyof AggregateRessource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRessource[P]>
      : GetScalarType<T[P], AggregateRessource[P]>
  }




  export type RessourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RessourceWhereInput
    orderBy?: RessourceOrderByWithAggregationInput | RessourceOrderByWithAggregationInput[]
    by: RessourceScalarFieldEnum[] | RessourceScalarFieldEnum
    having?: RessourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RessourceCountAggregateInputType | true
    _avg?: RessourceAvgAggregateInputType
    _sum?: RessourceSumAggregateInputType
    _min?: RessourceMinAggregateInputType
    _max?: RessourceMaxAggregateInputType
  }

  export type RessourceGroupByOutputType = {
    id: number
    nom: string
    file: string
    type: $Enums.TypeFile
    themeId: number
    dateDepot: Date
    _count: RessourceCountAggregateOutputType | null
    _avg: RessourceAvgAggregateOutputType | null
    _sum: RessourceSumAggregateOutputType | null
    _min: RessourceMinAggregateOutputType | null
    _max: RessourceMaxAggregateOutputType | null
  }

  type GetRessourceGroupByPayload<T extends RessourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RessourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RessourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RessourceGroupByOutputType[P]>
            : GetScalarType<T[P], RessourceGroupByOutputType[P]>
        }
      >
    >


  export type RessourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    file?: boolean
    type?: boolean
    themeId?: boolean
    dateDepot?: boolean
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
    Commentaire?: boolean | Ressource$CommentaireArgs<ExtArgs>
    _count?: boolean | RessourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ressource"]>

  export type RessourceSelectScalar = {
    id?: boolean
    nom?: boolean
    file?: boolean
    type?: boolean
    themeId?: boolean
    dateDepot?: boolean
  }

  export type RessourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
    Commentaire?: boolean | Ressource$CommentaireArgs<ExtArgs>
    _count?: boolean | RessourceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RessourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ressource"
    objects: {
      theme: Prisma.$ThemePayload<ExtArgs>
      Commentaire: Prisma.$CommentairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      file: string
      type: $Enums.TypeFile
      themeId: number
      dateDepot: Date
    }, ExtArgs["result"]["ressource"]>
    composites: {}
  }


  type RessourceGetPayload<S extends boolean | null | undefined | RessourceDefaultArgs> = $Result.GetResult<Prisma.$RessourcePayload, S>

  type RessourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RessourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RessourceCountAggregateInputType | true
    }

  export interface RessourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ressource'], meta: { name: 'Ressource' } }
    /**
     * Find zero or one Ressource that matches the filter.
     * @param {RessourceFindUniqueArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RessourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RessourceFindUniqueArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ressource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RessourceFindUniqueOrThrowArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RessourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RessourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ressource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceFindFirstArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RessourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RessourceFindFirstArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ressource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceFindFirstOrThrowArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RessourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RessourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ressources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ressources
     * const ressources = await prisma.ressource.findMany()
     * 
     * // Get first 10 Ressources
     * const ressources = await prisma.ressource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ressourceWithIdOnly = await prisma.ressource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RessourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RessourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ressource.
     * @param {RessourceCreateArgs} args - Arguments to create a Ressource.
     * @example
     * // Create one Ressource
     * const Ressource = await prisma.ressource.create({
     *   data: {
     *     // ... data to create a Ressource
     *   }
     * })
     * 
    **/
    create<T extends RessourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RessourceCreateArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ressources.
     *     @param {RessourceCreateManyArgs} args - Arguments to create many Ressources.
     *     @example
     *     // Create many Ressources
     *     const ressource = await prisma.ressource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RessourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RessourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ressource.
     * @param {RessourceDeleteArgs} args - Arguments to delete one Ressource.
     * @example
     * // Delete one Ressource
     * const Ressource = await prisma.ressource.delete({
     *   where: {
     *     // ... filter to delete one Ressource
     *   }
     * })
     * 
    **/
    delete<T extends RessourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RessourceDeleteArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ressource.
     * @param {RessourceUpdateArgs} args - Arguments to update one Ressource.
     * @example
     * // Update one Ressource
     * const ressource = await prisma.ressource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RessourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RessourceUpdateArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ressources.
     * @param {RessourceDeleteManyArgs} args - Arguments to filter Ressources to delete.
     * @example
     * // Delete a few Ressources
     * const { count } = await prisma.ressource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RessourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RessourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ressources
     * const ressource = await prisma.ressource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RessourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RessourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ressource.
     * @param {RessourceUpsertArgs} args - Arguments to update or create a Ressource.
     * @example
     * // Update or create a Ressource
     * const ressource = await prisma.ressource.upsert({
     *   create: {
     *     // ... data to create a Ressource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ressource we want to update
     *   }
     * })
    **/
    upsert<T extends RessourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RessourceUpsertArgs<ExtArgs>>
    ): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceCountArgs} args - Arguments to filter Ressources to count.
     * @example
     * // Count the number of Ressources
     * const count = await prisma.ressource.count({
     *   where: {
     *     // ... the filter for the Ressources we want to count
     *   }
     * })
    **/
    count<T extends RessourceCountArgs>(
      args?: Subset<T, RessourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RessourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ressource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RessourceAggregateArgs>(args: Subset<T, RessourceAggregateArgs>): Prisma.PrismaPromise<GetRessourceAggregateType<T>>

    /**
     * Group by Ressource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RessourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RessourceGroupByArgs['orderBy'] }
        : { orderBy?: RessourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RessourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRessourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ressource model
   */
  readonly fields: RessourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ressource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RessourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    theme<T extends ThemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThemeDefaultArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Commentaire<T extends Ressource$CommentaireArgs<ExtArgs> = {}>(args?: Subset<T, Ressource$CommentaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ressource model
   */ 
  interface RessourceFieldRefs {
    readonly id: FieldRef<"Ressource", 'Int'>
    readonly nom: FieldRef<"Ressource", 'String'>
    readonly file: FieldRef<"Ressource", 'String'>
    readonly type: FieldRef<"Ressource", 'TypeFile'>
    readonly themeId: FieldRef<"Ressource", 'Int'>
    readonly dateDepot: FieldRef<"Ressource", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Ressource findUnique
   */
  export type RessourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where: RessourceWhereUniqueInput
  }


  /**
   * Ressource findUniqueOrThrow
   */
  export type RessourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where: RessourceWhereUniqueInput
  }


  /**
   * Ressource findFirst
   */
  export type RessourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ressources.
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ressources.
     */
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }


  /**
   * Ressource findFirstOrThrow
   */
  export type RessourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ressources.
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ressources.
     */
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }


  /**
   * Ressource findMany
   */
  export type RessourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressources to fetch.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ressources.
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }


  /**
   * Ressource create
   */
  export type RessourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Ressource.
     */
    data: XOR<RessourceCreateInput, RessourceUncheckedCreateInput>
  }


  /**
   * Ressource createMany
   */
  export type RessourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ressources.
     */
    data: RessourceCreateManyInput | RessourceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ressource update
   */
  export type RessourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Ressource.
     */
    data: XOR<RessourceUpdateInput, RessourceUncheckedUpdateInput>
    /**
     * Choose, which Ressource to update.
     */
    where: RessourceWhereUniqueInput
  }


  /**
   * Ressource updateMany
   */
  export type RessourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ressources.
     */
    data: XOR<RessourceUpdateManyMutationInput, RessourceUncheckedUpdateManyInput>
    /**
     * Filter which Ressources to update
     */
    where?: RessourceWhereInput
  }


  /**
   * Ressource upsert
   */
  export type RessourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Ressource to update in case it exists.
     */
    where: RessourceWhereUniqueInput
    /**
     * In case the Ressource found by the `where` argument doesn't exist, create a new Ressource with this data.
     */
    create: XOR<RessourceCreateInput, RessourceUncheckedCreateInput>
    /**
     * In case the Ressource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RessourceUpdateInput, RessourceUncheckedUpdateInput>
  }


  /**
   * Ressource delete
   */
  export type RessourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter which Ressource to delete.
     */
    where: RessourceWhereUniqueInput
  }


  /**
   * Ressource deleteMany
   */
  export type RessourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ressources to delete
     */
    where?: RessourceWhereInput
  }


  /**
   * Ressource.Commentaire
   */
  export type Ressource$CommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }


  /**
   * Ressource without action
   */
  export type RessourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RessourceInclude<ExtArgs> | null
  }



  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    id: number | null
    point: number | null
    periode: number | null
    themeId: number | null
  }

  export type TestSumAggregateOutputType = {
    id: number | null
    point: number | null
    periode: number | null
    themeId: number | null
  }

  export type TestMinAggregateOutputType = {
    id: number | null
    nom: string | null
    point: number | null
    periode: number | null
    themeId: number | null
    dateDebut: Date | null
    dateFin: Date | null
  }

  export type TestMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    point: number | null
    periode: number | null
    themeId: number | null
    dateDebut: Date | null
    dateFin: Date | null
  }

  export type TestCountAggregateOutputType = {
    id: number
    nom: number
    point: number
    periode: number
    themeId: number
    dateDebut: number
    dateFin: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    id?: true
    point?: true
    periode?: true
    themeId?: true
  }

  export type TestSumAggregateInputType = {
    id?: true
    point?: true
    periode?: true
    themeId?: true
  }

  export type TestMinAggregateInputType = {
    id?: true
    nom?: true
    point?: true
    periode?: true
    themeId?: true
    dateDebut?: true
    dateFin?: true
  }

  export type TestMaxAggregateInputType = {
    id?: true
    nom?: true
    point?: true
    periode?: true
    themeId?: true
    dateDebut?: true
    dateFin?: true
  }

  export type TestCountAggregateInputType = {
    id?: true
    nom?: true
    point?: true
    periode?: true
    themeId?: true
    dateDebut?: true
    dateFin?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    id: number
    nom: string
    point: number
    periode: number
    themeId: number
    dateDebut: Date
    dateFin: Date
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    point?: boolean
    periode?: boolean
    themeId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
    Resultat?: boolean | Test$ResultatArgs<ExtArgs>
    TestQuestion?: boolean | Test$TestQuestionArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>

  export type TestSelectScalar = {
    id?: boolean
    nom?: boolean
    point?: boolean
    periode?: boolean
    themeId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
  }

  export type TestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
    Resultat?: boolean | Test$ResultatArgs<ExtArgs>
    TestQuestion?: boolean | Test$TestQuestionArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {
      theme: Prisma.$ThemePayload<ExtArgs>
      Resultat: Prisma.$ResultatPayload<ExtArgs>[]
      TestQuestion: Prisma.$TestQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      point: number
      periode: number
      themeId: number
      dateDebut: Date
      dateFin: Date
    }, ExtArgs["result"]["test"]>
    composites: {}
  }


  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Test that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testWithIdOnly = await prisma.test.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
    **/
    create<T extends TestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TestCreateArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tests.
     *     @param {TestCreateManyArgs} args - Arguments to create many Tests.
     *     @example
     *     // Create many Tests
     *     const test = await prisma.test.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
    **/
    delete<T extends TestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TestDeleteArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TestUpdateArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
    **/
    upsert<T extends TestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TestUpsertArgs<ExtArgs>>
    ): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    theme<T extends ThemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThemeDefaultArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Resultat<T extends Test$ResultatArgs<ExtArgs> = {}>(args?: Subset<T, Test$ResultatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findMany'> | Null>;

    TestQuestion<T extends Test$TestQuestionArgs<ExtArgs> = {}>(args?: Subset<T, Test$TestQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Test model
   */ 
  interface TestFieldRefs {
    readonly id: FieldRef<"Test", 'Int'>
    readonly nom: FieldRef<"Test", 'String'>
    readonly point: FieldRef<"Test", 'Int'>
    readonly periode: FieldRef<"Test", 'Int'>
    readonly themeId: FieldRef<"Test", 'Int'>
    readonly dateDebut: FieldRef<"Test", 'DateTime'>
    readonly dateFin: FieldRef<"Test", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }


  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }


  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }


  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }


  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }


  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }


  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }


  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
  }


  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }


  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }


  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
  }


  /**
   * Test.Resultat
   */
  export type Test$ResultatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    where?: ResultatWhereInput
    orderBy?: ResultatOrderByWithRelationInput | ResultatOrderByWithRelationInput[]
    cursor?: ResultatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultatScalarFieldEnum | ResultatScalarFieldEnum[]
  }


  /**
   * Test.TestQuestion
   */
  export type Test$TestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    where?: TestQuestionWhereInput
    orderBy?: TestQuestionOrderByWithRelationInput | TestQuestionOrderByWithRelationInput[]
    cursor?: TestQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestQuestionScalarFieldEnum | TestQuestionScalarFieldEnum[]
  }


  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestInclude<ExtArgs> | null
  }



  /**
   * Model BanqueQuestion
   */

  export type AggregateBanqueQuestion = {
    _count: BanqueQuestionCountAggregateOutputType | null
    _avg: BanqueQuestionAvgAggregateOutputType | null
    _sum: BanqueQuestionSumAggregateOutputType | null
    _min: BanqueQuestionMinAggregateOutputType | null
    _max: BanqueQuestionMaxAggregateOutputType | null
  }

  export type BanqueQuestionAvgAggregateOutputType = {
    id: number | null
    num: number | null
    espaceCoursId: number | null
  }

  export type BanqueQuestionSumAggregateOutputType = {
    id: number | null
    num: number | null
    espaceCoursId: number | null
  }

  export type BanqueQuestionMinAggregateOutputType = {
    id: number | null
    num: number | null
    desc: string | null
    espaceCoursId: number | null
  }

  export type BanqueQuestionMaxAggregateOutputType = {
    id: number | null
    num: number | null
    desc: string | null
    espaceCoursId: number | null
  }

  export type BanqueQuestionCountAggregateOutputType = {
    id: number
    num: number
    desc: number
    espaceCoursId: number
    _all: number
  }


  export type BanqueQuestionAvgAggregateInputType = {
    id?: true
    num?: true
    espaceCoursId?: true
  }

  export type BanqueQuestionSumAggregateInputType = {
    id?: true
    num?: true
    espaceCoursId?: true
  }

  export type BanqueQuestionMinAggregateInputType = {
    id?: true
    num?: true
    desc?: true
    espaceCoursId?: true
  }

  export type BanqueQuestionMaxAggregateInputType = {
    id?: true
    num?: true
    desc?: true
    espaceCoursId?: true
  }

  export type BanqueQuestionCountAggregateInputType = {
    id?: true
    num?: true
    desc?: true
    espaceCoursId?: true
    _all?: true
  }

  export type BanqueQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BanqueQuestion to aggregate.
     */
    where?: BanqueQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanqueQuestions to fetch.
     */
    orderBy?: BanqueQuestionOrderByWithRelationInput | BanqueQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BanqueQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanqueQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanqueQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BanqueQuestions
    **/
    _count?: true | BanqueQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanqueQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanqueQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanqueQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanqueQuestionMaxAggregateInputType
  }

  export type GetBanqueQuestionAggregateType<T extends BanqueQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateBanqueQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanqueQuestion[P]>
      : GetScalarType<T[P], AggregateBanqueQuestion[P]>
  }




  export type BanqueQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanqueQuestionWhereInput
    orderBy?: BanqueQuestionOrderByWithAggregationInput | BanqueQuestionOrderByWithAggregationInput[]
    by: BanqueQuestionScalarFieldEnum[] | BanqueQuestionScalarFieldEnum
    having?: BanqueQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanqueQuestionCountAggregateInputType | true
    _avg?: BanqueQuestionAvgAggregateInputType
    _sum?: BanqueQuestionSumAggregateInputType
    _min?: BanqueQuestionMinAggregateInputType
    _max?: BanqueQuestionMaxAggregateInputType
  }

  export type BanqueQuestionGroupByOutputType = {
    id: number
    num: number
    desc: string
    espaceCoursId: number
    _count: BanqueQuestionCountAggregateOutputType | null
    _avg: BanqueQuestionAvgAggregateOutputType | null
    _sum: BanqueQuestionSumAggregateOutputType | null
    _min: BanqueQuestionMinAggregateOutputType | null
    _max: BanqueQuestionMaxAggregateOutputType | null
  }

  type GetBanqueQuestionGroupByPayload<T extends BanqueQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanqueQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanqueQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanqueQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], BanqueQuestionGroupByOutputType[P]>
        }
      >
    >


  export type BanqueQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    num?: boolean
    desc?: boolean
    espaceCoursId?: boolean
    espaceCours?: boolean | EspaceCoursDefaultArgs<ExtArgs>
    Reponse?: boolean | BanqueQuestion$ReponseArgs<ExtArgs>
    TestQuestion?: boolean | BanqueQuestion$TestQuestionArgs<ExtArgs>
    _count?: boolean | BanqueQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banqueQuestion"]>

  export type BanqueQuestionSelectScalar = {
    id?: boolean
    num?: boolean
    desc?: boolean
    espaceCoursId?: boolean
  }

  export type BanqueQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    espaceCours?: boolean | EspaceCoursDefaultArgs<ExtArgs>
    Reponse?: boolean | BanqueQuestion$ReponseArgs<ExtArgs>
    TestQuestion?: boolean | BanqueQuestion$TestQuestionArgs<ExtArgs>
    _count?: boolean | BanqueQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BanqueQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BanqueQuestion"
    objects: {
      espaceCours: Prisma.$EspaceCoursPayload<ExtArgs>
      Reponse: Prisma.$ReponsePayload<ExtArgs>[]
      TestQuestion: Prisma.$TestQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      num: number
      desc: string
      espaceCoursId: number
    }, ExtArgs["result"]["banqueQuestion"]>
    composites: {}
  }


  type BanqueQuestionGetPayload<S extends boolean | null | undefined | BanqueQuestionDefaultArgs> = $Result.GetResult<Prisma.$BanqueQuestionPayload, S>

  type BanqueQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BanqueQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BanqueQuestionCountAggregateInputType | true
    }

  export interface BanqueQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BanqueQuestion'], meta: { name: 'BanqueQuestion' } }
    /**
     * Find zero or one BanqueQuestion that matches the filter.
     * @param {BanqueQuestionFindUniqueArgs} args - Arguments to find a BanqueQuestion
     * @example
     * // Get one BanqueQuestion
     * const banqueQuestion = await prisma.banqueQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BanqueQuestionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BanqueQuestionFindUniqueArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BanqueQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BanqueQuestionFindUniqueOrThrowArgs} args - Arguments to find a BanqueQuestion
     * @example
     * // Get one BanqueQuestion
     * const banqueQuestion = await prisma.banqueQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BanqueQuestionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BanqueQuestionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BanqueQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionFindFirstArgs} args - Arguments to find a BanqueQuestion
     * @example
     * // Get one BanqueQuestion
     * const banqueQuestion = await prisma.banqueQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BanqueQuestionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BanqueQuestionFindFirstArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BanqueQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionFindFirstOrThrowArgs} args - Arguments to find a BanqueQuestion
     * @example
     * // Get one BanqueQuestion
     * const banqueQuestion = await prisma.banqueQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BanqueQuestionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BanqueQuestionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BanqueQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BanqueQuestions
     * const banqueQuestions = await prisma.banqueQuestion.findMany()
     * 
     * // Get first 10 BanqueQuestions
     * const banqueQuestions = await prisma.banqueQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banqueQuestionWithIdOnly = await prisma.banqueQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BanqueQuestionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanqueQuestionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BanqueQuestion.
     * @param {BanqueQuestionCreateArgs} args - Arguments to create a BanqueQuestion.
     * @example
     * // Create one BanqueQuestion
     * const BanqueQuestion = await prisma.banqueQuestion.create({
     *   data: {
     *     // ... data to create a BanqueQuestion
     *   }
     * })
     * 
    **/
    create<T extends BanqueQuestionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BanqueQuestionCreateArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BanqueQuestions.
     *     @param {BanqueQuestionCreateManyArgs} args - Arguments to create many BanqueQuestions.
     *     @example
     *     // Create many BanqueQuestions
     *     const banqueQuestion = await prisma.banqueQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BanqueQuestionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanqueQuestionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BanqueQuestion.
     * @param {BanqueQuestionDeleteArgs} args - Arguments to delete one BanqueQuestion.
     * @example
     * // Delete one BanqueQuestion
     * const BanqueQuestion = await prisma.banqueQuestion.delete({
     *   where: {
     *     // ... filter to delete one BanqueQuestion
     *   }
     * })
     * 
    **/
    delete<T extends BanqueQuestionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BanqueQuestionDeleteArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BanqueQuestion.
     * @param {BanqueQuestionUpdateArgs} args - Arguments to update one BanqueQuestion.
     * @example
     * // Update one BanqueQuestion
     * const banqueQuestion = await prisma.banqueQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BanqueQuestionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BanqueQuestionUpdateArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BanqueQuestions.
     * @param {BanqueQuestionDeleteManyArgs} args - Arguments to filter BanqueQuestions to delete.
     * @example
     * // Delete a few BanqueQuestions
     * const { count } = await prisma.banqueQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BanqueQuestionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanqueQuestionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BanqueQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BanqueQuestions
     * const banqueQuestion = await prisma.banqueQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BanqueQuestionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BanqueQuestionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BanqueQuestion.
     * @param {BanqueQuestionUpsertArgs} args - Arguments to update or create a BanqueQuestion.
     * @example
     * // Update or create a BanqueQuestion
     * const banqueQuestion = await prisma.banqueQuestion.upsert({
     *   create: {
     *     // ... data to create a BanqueQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BanqueQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends BanqueQuestionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BanqueQuestionUpsertArgs<ExtArgs>>
    ): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BanqueQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionCountArgs} args - Arguments to filter BanqueQuestions to count.
     * @example
     * // Count the number of BanqueQuestions
     * const count = await prisma.banqueQuestion.count({
     *   where: {
     *     // ... the filter for the BanqueQuestions we want to count
     *   }
     * })
    **/
    count<T extends BanqueQuestionCountArgs>(
      args?: Subset<T, BanqueQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanqueQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BanqueQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanqueQuestionAggregateArgs>(args: Subset<T, BanqueQuestionAggregateArgs>): Prisma.PrismaPromise<GetBanqueQuestionAggregateType<T>>

    /**
     * Group by BanqueQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BanqueQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BanqueQuestionGroupByArgs['orderBy'] }
        : { orderBy?: BanqueQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BanqueQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanqueQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BanqueQuestion model
   */
  readonly fields: BanqueQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BanqueQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BanqueQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    espaceCours<T extends EspaceCoursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspaceCoursDefaultArgs<ExtArgs>>): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Reponse<T extends BanqueQuestion$ReponseArgs<ExtArgs> = {}>(args?: Subset<T, BanqueQuestion$ReponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    TestQuestion<T extends BanqueQuestion$TestQuestionArgs<ExtArgs> = {}>(args?: Subset<T, BanqueQuestion$TestQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BanqueQuestion model
   */ 
  interface BanqueQuestionFieldRefs {
    readonly id: FieldRef<"BanqueQuestion", 'Int'>
    readonly num: FieldRef<"BanqueQuestion", 'Int'>
    readonly desc: FieldRef<"BanqueQuestion", 'String'>
    readonly espaceCoursId: FieldRef<"BanqueQuestion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BanqueQuestion findUnique
   */
  export type BanqueQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * Filter, which BanqueQuestion to fetch.
     */
    where: BanqueQuestionWhereUniqueInput
  }


  /**
   * BanqueQuestion findUniqueOrThrow
   */
  export type BanqueQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * Filter, which BanqueQuestion to fetch.
     */
    where: BanqueQuestionWhereUniqueInput
  }


  /**
   * BanqueQuestion findFirst
   */
  export type BanqueQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * Filter, which BanqueQuestion to fetch.
     */
    where?: BanqueQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanqueQuestions to fetch.
     */
    orderBy?: BanqueQuestionOrderByWithRelationInput | BanqueQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BanqueQuestions.
     */
    cursor?: BanqueQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanqueQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanqueQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BanqueQuestions.
     */
    distinct?: BanqueQuestionScalarFieldEnum | BanqueQuestionScalarFieldEnum[]
  }


  /**
   * BanqueQuestion findFirstOrThrow
   */
  export type BanqueQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * Filter, which BanqueQuestion to fetch.
     */
    where?: BanqueQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanqueQuestions to fetch.
     */
    orderBy?: BanqueQuestionOrderByWithRelationInput | BanqueQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BanqueQuestions.
     */
    cursor?: BanqueQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanqueQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanqueQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BanqueQuestions.
     */
    distinct?: BanqueQuestionScalarFieldEnum | BanqueQuestionScalarFieldEnum[]
  }


  /**
   * BanqueQuestion findMany
   */
  export type BanqueQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * Filter, which BanqueQuestions to fetch.
     */
    where?: BanqueQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanqueQuestions to fetch.
     */
    orderBy?: BanqueQuestionOrderByWithRelationInput | BanqueQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BanqueQuestions.
     */
    cursor?: BanqueQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanqueQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanqueQuestions.
     */
    skip?: number
    distinct?: BanqueQuestionScalarFieldEnum | BanqueQuestionScalarFieldEnum[]
  }


  /**
   * BanqueQuestion create
   */
  export type BanqueQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a BanqueQuestion.
     */
    data: XOR<BanqueQuestionCreateInput, BanqueQuestionUncheckedCreateInput>
  }


  /**
   * BanqueQuestion createMany
   */
  export type BanqueQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BanqueQuestions.
     */
    data: BanqueQuestionCreateManyInput | BanqueQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BanqueQuestion update
   */
  export type BanqueQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a BanqueQuestion.
     */
    data: XOR<BanqueQuestionUpdateInput, BanqueQuestionUncheckedUpdateInput>
    /**
     * Choose, which BanqueQuestion to update.
     */
    where: BanqueQuestionWhereUniqueInput
  }


  /**
   * BanqueQuestion updateMany
   */
  export type BanqueQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BanqueQuestions.
     */
    data: XOR<BanqueQuestionUpdateManyMutationInput, BanqueQuestionUncheckedUpdateManyInput>
    /**
     * Filter which BanqueQuestions to update
     */
    where?: BanqueQuestionWhereInput
  }


  /**
   * BanqueQuestion upsert
   */
  export type BanqueQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the BanqueQuestion to update in case it exists.
     */
    where: BanqueQuestionWhereUniqueInput
    /**
     * In case the BanqueQuestion found by the `where` argument doesn't exist, create a new BanqueQuestion with this data.
     */
    create: XOR<BanqueQuestionCreateInput, BanqueQuestionUncheckedCreateInput>
    /**
     * In case the BanqueQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BanqueQuestionUpdateInput, BanqueQuestionUncheckedUpdateInput>
  }


  /**
   * BanqueQuestion delete
   */
  export type BanqueQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
    /**
     * Filter which BanqueQuestion to delete.
     */
    where: BanqueQuestionWhereUniqueInput
  }


  /**
   * BanqueQuestion deleteMany
   */
  export type BanqueQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BanqueQuestions to delete
     */
    where?: BanqueQuestionWhereInput
  }


  /**
   * BanqueQuestion.Reponse
   */
  export type BanqueQuestion$ReponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    where?: ReponseWhereInput
    orderBy?: ReponseOrderByWithRelationInput | ReponseOrderByWithRelationInput[]
    cursor?: ReponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReponseScalarFieldEnum | ReponseScalarFieldEnum[]
  }


  /**
   * BanqueQuestion.TestQuestion
   */
  export type BanqueQuestion$TestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    where?: TestQuestionWhereInput
    orderBy?: TestQuestionOrderByWithRelationInput | TestQuestionOrderByWithRelationInput[]
    cursor?: TestQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestQuestionScalarFieldEnum | TestQuestionScalarFieldEnum[]
  }


  /**
   * BanqueQuestion without action
   */
  export type BanqueQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueQuestion
     */
    select?: BanqueQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanqueQuestionInclude<ExtArgs> | null
  }



  /**
   * Model Reponse
   */

  export type AggregateReponse = {
    _count: ReponseCountAggregateOutputType | null
    _avg: ReponseAvgAggregateOutputType | null
    _sum: ReponseSumAggregateOutputType | null
    _min: ReponseMinAggregateOutputType | null
    _max: ReponseMaxAggregateOutputType | null
  }

  export type ReponseAvgAggregateOutputType = {
    id: number | null
    num: number | null
    banqueQuestionId: number | null
  }

  export type ReponseSumAggregateOutputType = {
    id: number | null
    num: number | null
    banqueQuestionId: number | null
  }

  export type ReponseMinAggregateOutputType = {
    id: number | null
    num: number | null
    desc: string | null
    isCorrecte: boolean | null
    banqueQuestionId: number | null
  }

  export type ReponseMaxAggregateOutputType = {
    id: number | null
    num: number | null
    desc: string | null
    isCorrecte: boolean | null
    banqueQuestionId: number | null
  }

  export type ReponseCountAggregateOutputType = {
    id: number
    num: number
    desc: number
    isCorrecte: number
    banqueQuestionId: number
    _all: number
  }


  export type ReponseAvgAggregateInputType = {
    id?: true
    num?: true
    banqueQuestionId?: true
  }

  export type ReponseSumAggregateInputType = {
    id?: true
    num?: true
    banqueQuestionId?: true
  }

  export type ReponseMinAggregateInputType = {
    id?: true
    num?: true
    desc?: true
    isCorrecte?: true
    banqueQuestionId?: true
  }

  export type ReponseMaxAggregateInputType = {
    id?: true
    num?: true
    desc?: true
    isCorrecte?: true
    banqueQuestionId?: true
  }

  export type ReponseCountAggregateInputType = {
    id?: true
    num?: true
    desc?: true
    isCorrecte?: true
    banqueQuestionId?: true
    _all?: true
  }

  export type ReponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reponse to aggregate.
     */
    where?: ReponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reponses to fetch.
     */
    orderBy?: ReponseOrderByWithRelationInput | ReponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reponses
    **/
    _count?: true | ReponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReponseMaxAggregateInputType
  }

  export type GetReponseAggregateType<T extends ReponseAggregateArgs> = {
        [P in keyof T & keyof AggregateReponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReponse[P]>
      : GetScalarType<T[P], AggregateReponse[P]>
  }




  export type ReponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReponseWhereInput
    orderBy?: ReponseOrderByWithAggregationInput | ReponseOrderByWithAggregationInput[]
    by: ReponseScalarFieldEnum[] | ReponseScalarFieldEnum
    having?: ReponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReponseCountAggregateInputType | true
    _avg?: ReponseAvgAggregateInputType
    _sum?: ReponseSumAggregateInputType
    _min?: ReponseMinAggregateInputType
    _max?: ReponseMaxAggregateInputType
  }

  export type ReponseGroupByOutputType = {
    id: number
    num: number
    desc: string
    isCorrecte: boolean
    banqueQuestionId: number
    _count: ReponseCountAggregateOutputType | null
    _avg: ReponseAvgAggregateOutputType | null
    _sum: ReponseSumAggregateOutputType | null
    _min: ReponseMinAggregateOutputType | null
    _max: ReponseMaxAggregateOutputType | null
  }

  type GetReponseGroupByPayload<T extends ReponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReponseGroupByOutputType[P]>
            : GetScalarType<T[P], ReponseGroupByOutputType[P]>
        }
      >
    >


  export type ReponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    num?: boolean
    desc?: boolean
    isCorrecte?: boolean
    banqueQuestionId?: boolean
    banqueQuestion?: boolean | BanqueQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reponse"]>

  export type ReponseSelectScalar = {
    id?: boolean
    num?: boolean
    desc?: boolean
    isCorrecte?: boolean
    banqueQuestionId?: boolean
  }

  export type ReponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueQuestion?: boolean | BanqueQuestionDefaultArgs<ExtArgs>
  }


  export type $ReponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reponse"
    objects: {
      banqueQuestion: Prisma.$BanqueQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      num: number
      desc: string
      isCorrecte: boolean
      banqueQuestionId: number
    }, ExtArgs["result"]["reponse"]>
    composites: {}
  }


  type ReponseGetPayload<S extends boolean | null | undefined | ReponseDefaultArgs> = $Result.GetResult<Prisma.$ReponsePayload, S>

  type ReponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReponseCountAggregateInputType | true
    }

  export interface ReponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reponse'], meta: { name: 'Reponse' } }
    /**
     * Find zero or one Reponse that matches the filter.
     * @param {ReponseFindUniqueArgs} args - Arguments to find a Reponse
     * @example
     * // Get one Reponse
     * const reponse = await prisma.reponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReponseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReponseFindUniqueArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reponse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReponseFindUniqueOrThrowArgs} args - Arguments to find a Reponse
     * @example
     * // Get one Reponse
     * const reponse = await prisma.reponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReponseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReponseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseFindFirstArgs} args - Arguments to find a Reponse
     * @example
     * // Get one Reponse
     * const reponse = await prisma.reponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReponseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReponseFindFirstArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseFindFirstOrThrowArgs} args - Arguments to find a Reponse
     * @example
     * // Get one Reponse
     * const reponse = await prisma.reponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReponseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReponseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reponses
     * const reponses = await prisma.reponse.findMany()
     * 
     * // Get first 10 Reponses
     * const reponses = await prisma.reponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reponseWithIdOnly = await prisma.reponse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReponseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReponseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reponse.
     * @param {ReponseCreateArgs} args - Arguments to create a Reponse.
     * @example
     * // Create one Reponse
     * const Reponse = await prisma.reponse.create({
     *   data: {
     *     // ... data to create a Reponse
     *   }
     * })
     * 
    **/
    create<T extends ReponseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReponseCreateArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reponses.
     *     @param {ReponseCreateManyArgs} args - Arguments to create many Reponses.
     *     @example
     *     // Create many Reponses
     *     const reponse = await prisma.reponse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReponseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReponseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reponse.
     * @param {ReponseDeleteArgs} args - Arguments to delete one Reponse.
     * @example
     * // Delete one Reponse
     * const Reponse = await prisma.reponse.delete({
     *   where: {
     *     // ... filter to delete one Reponse
     *   }
     * })
     * 
    **/
    delete<T extends ReponseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReponseDeleteArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reponse.
     * @param {ReponseUpdateArgs} args - Arguments to update one Reponse.
     * @example
     * // Update one Reponse
     * const reponse = await prisma.reponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReponseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReponseUpdateArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reponses.
     * @param {ReponseDeleteManyArgs} args - Arguments to filter Reponses to delete.
     * @example
     * // Delete a few Reponses
     * const { count } = await prisma.reponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReponseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReponseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reponses
     * const reponse = await prisma.reponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReponseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReponseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reponse.
     * @param {ReponseUpsertArgs} args - Arguments to update or create a Reponse.
     * @example
     * // Update or create a Reponse
     * const reponse = await prisma.reponse.upsert({
     *   create: {
     *     // ... data to create a Reponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reponse we want to update
     *   }
     * })
    **/
    upsert<T extends ReponseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReponseUpsertArgs<ExtArgs>>
    ): Prisma__ReponseClient<$Result.GetResult<Prisma.$ReponsePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseCountArgs} args - Arguments to filter Reponses to count.
     * @example
     * // Count the number of Reponses
     * const count = await prisma.reponse.count({
     *   where: {
     *     // ... the filter for the Reponses we want to count
     *   }
     * })
    **/
    count<T extends ReponseCountArgs>(
      args?: Subset<T, ReponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReponseAggregateArgs>(args: Subset<T, ReponseAggregateArgs>): Prisma.PrismaPromise<GetReponseAggregateType<T>>

    /**
     * Group by Reponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReponseGroupByArgs['orderBy'] }
        : { orderBy?: ReponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reponse model
   */
  readonly fields: ReponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    banqueQuestion<T extends BanqueQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BanqueQuestionDefaultArgs<ExtArgs>>): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Reponse model
   */ 
  interface ReponseFieldRefs {
    readonly id: FieldRef<"Reponse", 'Int'>
    readonly num: FieldRef<"Reponse", 'Int'>
    readonly desc: FieldRef<"Reponse", 'String'>
    readonly isCorrecte: FieldRef<"Reponse", 'Boolean'>
    readonly banqueQuestionId: FieldRef<"Reponse", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Reponse findUnique
   */
  export type ReponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * Filter, which Reponse to fetch.
     */
    where: ReponseWhereUniqueInput
  }


  /**
   * Reponse findUniqueOrThrow
   */
  export type ReponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * Filter, which Reponse to fetch.
     */
    where: ReponseWhereUniqueInput
  }


  /**
   * Reponse findFirst
   */
  export type ReponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * Filter, which Reponse to fetch.
     */
    where?: ReponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reponses to fetch.
     */
    orderBy?: ReponseOrderByWithRelationInput | ReponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reponses.
     */
    cursor?: ReponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reponses.
     */
    distinct?: ReponseScalarFieldEnum | ReponseScalarFieldEnum[]
  }


  /**
   * Reponse findFirstOrThrow
   */
  export type ReponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * Filter, which Reponse to fetch.
     */
    where?: ReponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reponses to fetch.
     */
    orderBy?: ReponseOrderByWithRelationInput | ReponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reponses.
     */
    cursor?: ReponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reponses.
     */
    distinct?: ReponseScalarFieldEnum | ReponseScalarFieldEnum[]
  }


  /**
   * Reponse findMany
   */
  export type ReponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * Filter, which Reponses to fetch.
     */
    where?: ReponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reponses to fetch.
     */
    orderBy?: ReponseOrderByWithRelationInput | ReponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reponses.
     */
    cursor?: ReponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reponses.
     */
    skip?: number
    distinct?: ReponseScalarFieldEnum | ReponseScalarFieldEnum[]
  }


  /**
   * Reponse create
   */
  export type ReponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * The data needed to create a Reponse.
     */
    data: XOR<ReponseCreateInput, ReponseUncheckedCreateInput>
  }


  /**
   * Reponse createMany
   */
  export type ReponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reponses.
     */
    data: ReponseCreateManyInput | ReponseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Reponse update
   */
  export type ReponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * The data needed to update a Reponse.
     */
    data: XOR<ReponseUpdateInput, ReponseUncheckedUpdateInput>
    /**
     * Choose, which Reponse to update.
     */
    where: ReponseWhereUniqueInput
  }


  /**
   * Reponse updateMany
   */
  export type ReponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reponses.
     */
    data: XOR<ReponseUpdateManyMutationInput, ReponseUncheckedUpdateManyInput>
    /**
     * Filter which Reponses to update
     */
    where?: ReponseWhereInput
  }


  /**
   * Reponse upsert
   */
  export type ReponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * The filter to search for the Reponse to update in case it exists.
     */
    where: ReponseWhereUniqueInput
    /**
     * In case the Reponse found by the `where` argument doesn't exist, create a new Reponse with this data.
     */
    create: XOR<ReponseCreateInput, ReponseUncheckedCreateInput>
    /**
     * In case the Reponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReponseUpdateInput, ReponseUncheckedUpdateInput>
  }


  /**
   * Reponse delete
   */
  export type ReponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
    /**
     * Filter which Reponse to delete.
     */
    where: ReponseWhereUniqueInput
  }


  /**
   * Reponse deleteMany
   */
  export type ReponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reponses to delete
     */
    where?: ReponseWhereInput
  }


  /**
   * Reponse without action
   */
  export type ReponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reponse
     */
    select?: ReponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReponseInclude<ExtArgs> | null
  }



  /**
   * Model Commentaire
   */

  export type AggregateCommentaire = {
    _count: CommentaireCountAggregateOutputType | null
    _avg: CommentaireAvgAggregateOutputType | null
    _sum: CommentaireSumAggregateOutputType | null
    _min: CommentaireMinAggregateOutputType | null
    _max: CommentaireMaxAggregateOutputType | null
  }

  export type CommentaireAvgAggregateOutputType = {
    id: number | null
    ressourceId: number | null
    userId: number | null
  }

  export type CommentaireSumAggregateOutputType = {
    id: number | null
    ressourceId: number | null
    userId: number | null
  }

  export type CommentaireMinAggregateOutputType = {
    id: number | null
    desc: string | null
    font: string | null
    italic: boolean | null
    ressourceId: number | null
    userId: number | null
  }

  export type CommentaireMaxAggregateOutputType = {
    id: number | null
    desc: string | null
    font: string | null
    italic: boolean | null
    ressourceId: number | null
    userId: number | null
  }

  export type CommentaireCountAggregateOutputType = {
    id: number
    desc: number
    font: number
    italic: number
    ressourceId: number
    userId: number
    _all: number
  }


  export type CommentaireAvgAggregateInputType = {
    id?: true
    ressourceId?: true
    userId?: true
  }

  export type CommentaireSumAggregateInputType = {
    id?: true
    ressourceId?: true
    userId?: true
  }

  export type CommentaireMinAggregateInputType = {
    id?: true
    desc?: true
    font?: true
    italic?: true
    ressourceId?: true
    userId?: true
  }

  export type CommentaireMaxAggregateInputType = {
    id?: true
    desc?: true
    font?: true
    italic?: true
    ressourceId?: true
    userId?: true
  }

  export type CommentaireCountAggregateInputType = {
    id?: true
    desc?: true
    font?: true
    italic?: true
    ressourceId?: true
    userId?: true
    _all?: true
  }

  export type CommentaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commentaire to aggregate.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commentaires
    **/
    _count?: true | CommentaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentaireMaxAggregateInputType
  }

  export type GetCommentaireAggregateType<T extends CommentaireAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentaire[P]>
      : GetScalarType<T[P], AggregateCommentaire[P]>
  }




  export type CommentaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithAggregationInput | CommentaireOrderByWithAggregationInput[]
    by: CommentaireScalarFieldEnum[] | CommentaireScalarFieldEnum
    having?: CommentaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentaireCountAggregateInputType | true
    _avg?: CommentaireAvgAggregateInputType
    _sum?: CommentaireSumAggregateInputType
    _min?: CommentaireMinAggregateInputType
    _max?: CommentaireMaxAggregateInputType
  }

  export type CommentaireGroupByOutputType = {
    id: number
    desc: string
    font: string
    italic: boolean
    ressourceId: number
    userId: number
    _count: CommentaireCountAggregateOutputType | null
    _avg: CommentaireAvgAggregateOutputType | null
    _sum: CommentaireSumAggregateOutputType | null
    _min: CommentaireMinAggregateOutputType | null
    _max: CommentaireMaxAggregateOutputType | null
  }

  type GetCommentaireGroupByPayload<T extends CommentaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentaireGroupByOutputType[P]>
            : GetScalarType<T[P], CommentaireGroupByOutputType[P]>
        }
      >
    >


  export type CommentaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    font?: boolean
    italic?: boolean
    ressourceId?: boolean
    userId?: boolean
    ressource?: boolean | RessourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentaire"]>

  export type CommentaireSelectScalar = {
    id?: boolean
    desc?: boolean
    font?: boolean
    italic?: boolean
    ressourceId?: boolean
    userId?: boolean
  }

  export type CommentaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ressource?: boolean | RessourceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $CommentairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commentaire"
    objects: {
      ressource: Prisma.$RessourcePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      desc: string
      font: string
      italic: boolean
      ressourceId: number
      userId: number
    }, ExtArgs["result"]["commentaire"]>
    composites: {}
  }


  type CommentaireGetPayload<S extends boolean | null | undefined | CommentaireDefaultArgs> = $Result.GetResult<Prisma.$CommentairePayload, S>

  type CommentaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentaireCountAggregateInputType | true
    }

  export interface CommentaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commentaire'], meta: { name: 'Commentaire' } }
    /**
     * Find zero or one Commentaire that matches the filter.
     * @param {CommentaireFindUniqueArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentaireFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Commentaire that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentaireFindUniqueOrThrowArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentaireFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Commentaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindFirstArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentaireFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindFirstArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Commentaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindFirstOrThrowArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentaireFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Commentaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commentaires
     * const commentaires = await prisma.commentaire.findMany()
     * 
     * // Get first 10 Commentaires
     * const commentaires = await prisma.commentaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentaireWithIdOnly = await prisma.commentaire.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentaireFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Commentaire.
     * @param {CommentaireCreateArgs} args - Arguments to create a Commentaire.
     * @example
     * // Create one Commentaire
     * const Commentaire = await prisma.commentaire.create({
     *   data: {
     *     // ... data to create a Commentaire
     *   }
     * })
     * 
    **/
    create<T extends CommentaireCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireCreateArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Commentaires.
     *     @param {CommentaireCreateManyArgs} args - Arguments to create many Commentaires.
     *     @example
     *     // Create many Commentaires
     *     const commentaire = await prisma.commentaire.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentaireCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commentaire.
     * @param {CommentaireDeleteArgs} args - Arguments to delete one Commentaire.
     * @example
     * // Delete one Commentaire
     * const Commentaire = await prisma.commentaire.delete({
     *   where: {
     *     // ... filter to delete one Commentaire
     *   }
     * })
     * 
    **/
    delete<T extends CommentaireDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireDeleteArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Commentaire.
     * @param {CommentaireUpdateArgs} args - Arguments to update one Commentaire.
     * @example
     * // Update one Commentaire
     * const commentaire = await prisma.commentaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentaireUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireUpdateArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Commentaires.
     * @param {CommentaireDeleteManyArgs} args - Arguments to filter Commentaires to delete.
     * @example
     * // Delete a few Commentaires
     * const { count } = await prisma.commentaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentaireDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commentaires
     * const commentaire = await prisma.commentaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentaireUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commentaire.
     * @param {CommentaireUpsertArgs} args - Arguments to update or create a Commentaire.
     * @example
     * // Update or create a Commentaire
     * const commentaire = await prisma.commentaire.upsert({
     *   create: {
     *     // ... data to create a Commentaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commentaire we want to update
     *   }
     * })
    **/
    upsert<T extends CommentaireUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireUpsertArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireCountArgs} args - Arguments to filter Commentaires to count.
     * @example
     * // Count the number of Commentaires
     * const count = await prisma.commentaire.count({
     *   where: {
     *     // ... the filter for the Commentaires we want to count
     *   }
     * })
    **/
    count<T extends CommentaireCountArgs>(
      args?: Subset<T, CommentaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commentaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentaireAggregateArgs>(args: Subset<T, CommentaireAggregateArgs>): Prisma.PrismaPromise<GetCommentaireAggregateType<T>>

    /**
     * Group by Commentaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentaireGroupByArgs['orderBy'] }
        : { orderBy?: CommentaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commentaire model
   */
  readonly fields: CommentaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commentaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ressource<T extends RessourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RessourceDefaultArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Commentaire model
   */ 
  interface CommentaireFieldRefs {
    readonly id: FieldRef<"Commentaire", 'Int'>
    readonly desc: FieldRef<"Commentaire", 'String'>
    readonly font: FieldRef<"Commentaire", 'String'>
    readonly italic: FieldRef<"Commentaire", 'Boolean'>
    readonly ressourceId: FieldRef<"Commentaire", 'Int'>
    readonly userId: FieldRef<"Commentaire", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Commentaire findUnique
   */
  export type CommentaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire findUniqueOrThrow
   */
  export type CommentaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire findFirst
   */
  export type CommentaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commentaires.
     */
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }


  /**
   * Commentaire findFirstOrThrow
   */
  export type CommentaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commentaires.
     */
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }


  /**
   * Commentaire findMany
   */
  export type CommentaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaires to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }


  /**
   * Commentaire create
   */
  export type CommentaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The data needed to create a Commentaire.
     */
    data: XOR<CommentaireCreateInput, CommentaireUncheckedCreateInput>
  }


  /**
   * Commentaire createMany
   */
  export type CommentaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commentaires.
     */
    data: CommentaireCreateManyInput | CommentaireCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Commentaire update
   */
  export type CommentaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The data needed to update a Commentaire.
     */
    data: XOR<CommentaireUpdateInput, CommentaireUncheckedUpdateInput>
    /**
     * Choose, which Commentaire to update.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire updateMany
   */
  export type CommentaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commentaires.
     */
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyInput>
    /**
     * Filter which Commentaires to update
     */
    where?: CommentaireWhereInput
  }


  /**
   * Commentaire upsert
   */
  export type CommentaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The filter to search for the Commentaire to update in case it exists.
     */
    where: CommentaireWhereUniqueInput
    /**
     * In case the Commentaire found by the `where` argument doesn't exist, create a new Commentaire with this data.
     */
    create: XOR<CommentaireCreateInput, CommentaireUncheckedCreateInput>
    /**
     * In case the Commentaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentaireUpdateInput, CommentaireUncheckedUpdateInput>
  }


  /**
   * Commentaire delete
   */
  export type CommentaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter which Commentaire to delete.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire deleteMany
   */
  export type CommentaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commentaires to delete
     */
    where?: CommentaireWhereInput
  }


  /**
   * Commentaire without action
   */
  export type CommentaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    telephone: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    telephone: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    prenom: string | null
    nom: string | null
    email: string | null
    image: string | null
    password: string | null
    telephone: number | null
    role: $Enums.RoleUser | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    prenom: string | null
    nom: string | null
    email: string | null
    image: string | null
    password: string | null
    telephone: number | null
    role: $Enums.RoleUser | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    prenom: number
    nom: number
    email: number
    image: number
    password: number
    telephone: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    telephone?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    telephone?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    prenom?: true
    nom?: true
    email?: true
    image?: true
    password?: true
    telephone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    prenom?: true
    nom?: true
    email?: true
    image?: true
    password?: true
    telephone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    prenom?: true
    nom?: true
    email?: true
    image?: true
    password?: true
    telephone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prenom?: boolean
    nom?: boolean
    email?: boolean
    image?: boolean
    password?: boolean
    telephone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Etudiant?: boolean | User$EtudiantArgs<ExtArgs>
    Enseingant?: boolean | User$EnseingantArgs<ExtArgs>
    Admin?: boolean | User$AdminArgs<ExtArgs>
    Commentaire?: boolean | User$CommentaireArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    prenom?: boolean
    nom?: boolean
    email?: boolean
    image?: boolean
    password?: boolean
    telephone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Etudiant?: boolean | User$EtudiantArgs<ExtArgs>
    Enseingant?: boolean | User$EnseingantArgs<ExtArgs>
    Admin?: boolean | User$AdminArgs<ExtArgs>
    Commentaire?: boolean | User$CommentaireArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Etudiant: Prisma.$EtudiantPayload<ExtArgs> | null
      Enseingant: Prisma.$EnseingantPayload<ExtArgs> | null
      Admin: Prisma.$AdminPayload<ExtArgs> | null
      Commentaire: Prisma.$CommentairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prenom: string
      nom: string
      email: string
      image: string
      password: string
      telephone: number
      role: $Enums.RoleUser
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Etudiant<T extends User$EtudiantArgs<ExtArgs> = {}>(args?: Subset<T, User$EtudiantArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Enseingant<T extends User$EnseingantArgs<ExtArgs> = {}>(args?: Subset<T, User$EnseingantArgs<ExtArgs>>): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Admin<T extends User$AdminArgs<ExtArgs> = {}>(args?: Subset<T, User$AdminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Commentaire<T extends User$CommentaireArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly prenom: FieldRef<"User", 'String'>
    readonly nom: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly telephone: FieldRef<"User", 'Int'>
    readonly role: FieldRef<"User", 'RoleUser'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.Etudiant
   */
  export type User$EtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    where?: EtudiantWhereInput
  }


  /**
   * User.Enseingant
   */
  export type User$EnseingantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    where?: EnseingantWhereInput
  }


  /**
   * User.Admin
   */
  export type User$AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * User.Commentaire
   */
  export type User$CommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Etudiant
   */

  export type AggregateEtudiant = {
    _count: EtudiantCountAggregateOutputType | null
    _avg: EtudiantAvgAggregateOutputType | null
    _sum: EtudiantSumAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  export type EtudiantAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    matricule: number | null
  }

  export type EtudiantSumAggregateOutputType = {
    id: number | null
    userId: number | null
    matricule: number | null
  }

  export type EtudiantMinAggregateOutputType = {
    id: number | null
    userId: number | null
    matricule: number | null
    dateNaiss: Date | null
  }

  export type EtudiantMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    matricule: number | null
    dateNaiss: Date | null
  }

  export type EtudiantCountAggregateOutputType = {
    id: number
    userId: number
    matricule: number
    dateNaiss: number
    _all: number
  }


  export type EtudiantAvgAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
  }

  export type EtudiantSumAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
  }

  export type EtudiantMinAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
    dateNaiss?: true
  }

  export type EtudiantMaxAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
    dateNaiss?: true
  }

  export type EtudiantCountAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
    dateNaiss?: true
    _all?: true
  }

  export type EtudiantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etudiant to aggregate.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etudiants
    **/
    _count?: true | EtudiantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtudiantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtudiantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtudiantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtudiantMaxAggregateInputType
  }

  export type GetEtudiantAggregateType<T extends EtudiantAggregateArgs> = {
        [P in keyof T & keyof AggregateEtudiant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtudiant[P]>
      : GetScalarType<T[P], AggregateEtudiant[P]>
  }




  export type EtudiantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantWhereInput
    orderBy?: EtudiantOrderByWithAggregationInput | EtudiantOrderByWithAggregationInput[]
    by: EtudiantScalarFieldEnum[] | EtudiantScalarFieldEnum
    having?: EtudiantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtudiantCountAggregateInputType | true
    _avg?: EtudiantAvgAggregateInputType
    _sum?: EtudiantSumAggregateInputType
    _min?: EtudiantMinAggregateInputType
    _max?: EtudiantMaxAggregateInputType
  }

  export type EtudiantGroupByOutputType = {
    id: number
    userId: number
    matricule: number
    dateNaiss: Date
    _count: EtudiantCountAggregateOutputType | null
    _avg: EtudiantAvgAggregateOutputType | null
    _sum: EtudiantSumAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  type GetEtudiantGroupByPayload<T extends EtudiantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtudiantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtudiantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
            : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
        }
      >
    >


  export type EtudiantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matricule?: boolean
    dateNaiss?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Gamification?: boolean | Etudiant$GamificationArgs<ExtArgs>
    Resultat?: boolean | Etudiant$ResultatArgs<ExtArgs>
    Depot?: boolean | Etudiant$DepotArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etudiant"]>

  export type EtudiantSelectScalar = {
    id?: boolean
    userId?: boolean
    matricule?: boolean
    dateNaiss?: boolean
  }

  export type EtudiantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Gamification?: boolean | Etudiant$GamificationArgs<ExtArgs>
    Resultat?: boolean | Etudiant$ResultatArgs<ExtArgs>
    Depot?: boolean | Etudiant$DepotArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EtudiantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etudiant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Gamification: Prisma.$GamificationPayload<ExtArgs>[]
      Resultat: Prisma.$ResultatPayload<ExtArgs>[]
      Depot: Prisma.$DepotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      matricule: number
      dateNaiss: Date
    }, ExtArgs["result"]["etudiant"]>
    composites: {}
  }


  type EtudiantGetPayload<S extends boolean | null | undefined | EtudiantDefaultArgs> = $Result.GetResult<Prisma.$EtudiantPayload, S>

  type EtudiantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EtudiantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtudiantCountAggregateInputType | true
    }

  export interface EtudiantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etudiant'], meta: { name: 'Etudiant' } }
    /**
     * Find zero or one Etudiant that matches the filter.
     * @param {EtudiantFindUniqueArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EtudiantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantFindUniqueArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Etudiant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EtudiantFindUniqueOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EtudiantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Etudiant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindFirstArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EtudiantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindFirstArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Etudiant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindFirstOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EtudiantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Etudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etudiants
     * const etudiants = await prisma.etudiant.findMany()
     * 
     * // Get first 10 Etudiants
     * const etudiants = await prisma.etudiant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etudiantWithIdOnly = await prisma.etudiant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EtudiantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Etudiant.
     * @param {EtudiantCreateArgs} args - Arguments to create a Etudiant.
     * @example
     * // Create one Etudiant
     * const Etudiant = await prisma.etudiant.create({
     *   data: {
     *     // ... data to create a Etudiant
     *   }
     * })
     * 
    **/
    create<T extends EtudiantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantCreateArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Etudiants.
     *     @param {EtudiantCreateManyArgs} args - Arguments to create many Etudiants.
     *     @example
     *     // Create many Etudiants
     *     const etudiant = await prisma.etudiant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EtudiantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etudiant.
     * @param {EtudiantDeleteArgs} args - Arguments to delete one Etudiant.
     * @example
     * // Delete one Etudiant
     * const Etudiant = await prisma.etudiant.delete({
     *   where: {
     *     // ... filter to delete one Etudiant
     *   }
     * })
     * 
    **/
    delete<T extends EtudiantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantDeleteArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Etudiant.
     * @param {EtudiantUpdateArgs} args - Arguments to update one Etudiant.
     * @example
     * // Update one Etudiant
     * const etudiant = await prisma.etudiant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EtudiantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantUpdateArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Etudiants.
     * @param {EtudiantDeleteManyArgs} args - Arguments to filter Etudiants to delete.
     * @example
     * // Delete a few Etudiants
     * const { count } = await prisma.etudiant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EtudiantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EtudiantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etudiants
     * const etudiant = await prisma.etudiant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EtudiantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etudiant.
     * @param {EtudiantUpsertArgs} args - Arguments to update or create a Etudiant.
     * @example
     * // Update or create a Etudiant
     * const etudiant = await prisma.etudiant.upsert({
     *   create: {
     *     // ... data to create a Etudiant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etudiant we want to update
     *   }
     * })
    **/
    upsert<T extends EtudiantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EtudiantUpsertArgs<ExtArgs>>
    ): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantCountArgs} args - Arguments to filter Etudiants to count.
     * @example
     * // Count the number of Etudiants
     * const count = await prisma.etudiant.count({
     *   where: {
     *     // ... the filter for the Etudiants we want to count
     *   }
     * })
    **/
    count<T extends EtudiantCountArgs>(
      args?: Subset<T, EtudiantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtudiantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtudiantAggregateArgs>(args: Subset<T, EtudiantAggregateArgs>): Prisma.PrismaPromise<GetEtudiantAggregateType<T>>

    /**
     * Group by Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtudiantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtudiantGroupByArgs['orderBy'] }
        : { orderBy?: EtudiantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtudiantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtudiantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etudiant model
   */
  readonly fields: EtudiantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etudiant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtudiantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Gamification<T extends Etudiant$GamificationArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$GamificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    Resultat<T extends Etudiant$ResultatArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$ResultatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findMany'> | Null>;

    Depot<T extends Etudiant$DepotArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$DepotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Etudiant model
   */ 
  interface EtudiantFieldRefs {
    readonly id: FieldRef<"Etudiant", 'Int'>
    readonly userId: FieldRef<"Etudiant", 'Int'>
    readonly matricule: FieldRef<"Etudiant", 'Int'>
    readonly dateNaiss: FieldRef<"Etudiant", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Etudiant findUnique
   */
  export type EtudiantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant findUniqueOrThrow
   */
  export type EtudiantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant findFirst
   */
  export type EtudiantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant findFirstOrThrow
   */
  export type EtudiantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant findMany
   */
  export type EtudiantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiants to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }


  /**
   * Etudiant create
   */
  export type EtudiantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The data needed to create a Etudiant.
     */
    data: XOR<EtudiantCreateInput, EtudiantUncheckedCreateInput>
  }


  /**
   * Etudiant createMany
   */
  export type EtudiantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etudiants.
     */
    data: EtudiantCreateManyInput | EtudiantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Etudiant update
   */
  export type EtudiantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The data needed to update a Etudiant.
     */
    data: XOR<EtudiantUpdateInput, EtudiantUncheckedUpdateInput>
    /**
     * Choose, which Etudiant to update.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant updateMany
   */
  export type EtudiantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etudiants.
     */
    data: XOR<EtudiantUpdateManyMutationInput, EtudiantUncheckedUpdateManyInput>
    /**
     * Filter which Etudiants to update
     */
    where?: EtudiantWhereInput
  }


  /**
   * Etudiant upsert
   */
  export type EtudiantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The filter to search for the Etudiant to update in case it exists.
     */
    where: EtudiantWhereUniqueInput
    /**
     * In case the Etudiant found by the `where` argument doesn't exist, create a new Etudiant with this data.
     */
    create: XOR<EtudiantCreateInput, EtudiantUncheckedCreateInput>
    /**
     * In case the Etudiant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtudiantUpdateInput, EtudiantUncheckedUpdateInput>
  }


  /**
   * Etudiant delete
   */
  export type EtudiantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter which Etudiant to delete.
     */
    where: EtudiantWhereUniqueInput
  }


  /**
   * Etudiant deleteMany
   */
  export type EtudiantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etudiants to delete
     */
    where?: EtudiantWhereInput
  }


  /**
   * Etudiant.Gamification
   */
  export type Etudiant$GamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    where?: GamificationWhereInput
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    cursor?: GamificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }


  /**
   * Etudiant.Resultat
   */
  export type Etudiant$ResultatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    where?: ResultatWhereInput
    orderBy?: ResultatOrderByWithRelationInput | ResultatOrderByWithRelationInput[]
    cursor?: ResultatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultatScalarFieldEnum | ResultatScalarFieldEnum[]
  }


  /**
   * Etudiant.Depot
   */
  export type Etudiant$DepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    where?: DepotWhereInput
    orderBy?: DepotOrderByWithRelationInput | DepotOrderByWithRelationInput[]
    cursor?: DepotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepotScalarFieldEnum | DepotScalarFieldEnum[]
  }


  /**
   * Etudiant without action
   */
  export type EtudiantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EtudiantInclude<ExtArgs> | null
  }



  /**
   * Model Enseingant
   */

  export type AggregateEnseingant = {
    _count: EnseingantCountAggregateOutputType | null
    _avg: EnseingantAvgAggregateOutputType | null
    _sum: EnseingantSumAggregateOutputType | null
    _min: EnseingantMinAggregateOutputType | null
    _max: EnseingantMaxAggregateOutputType | null
  }

  export type EnseingantAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
  }

  export type EnseingantSumAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
  }

  export type EnseingantMinAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
  }

  export type EnseingantMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
  }

  export type EnseingantCountAggregateOutputType = {
    id: number
    userId: number
    CIN: number
    _all: number
  }


  export type EnseingantAvgAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
  }

  export type EnseingantSumAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
  }

  export type EnseingantMinAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
  }

  export type EnseingantMaxAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
  }

  export type EnseingantCountAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
    _all?: true
  }

  export type EnseingantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enseingant to aggregate.
     */
    where?: EnseingantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseingants to fetch.
     */
    orderBy?: EnseingantOrderByWithRelationInput | EnseingantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnseingantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseingants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseingants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enseingants
    **/
    _count?: true | EnseingantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnseingantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnseingantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnseingantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnseingantMaxAggregateInputType
  }

  export type GetEnseingantAggregateType<T extends EnseingantAggregateArgs> = {
        [P in keyof T & keyof AggregateEnseingant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnseingant[P]>
      : GetScalarType<T[P], AggregateEnseingant[P]>
  }




  export type EnseingantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnseingantWhereInput
    orderBy?: EnseingantOrderByWithAggregationInput | EnseingantOrderByWithAggregationInput[]
    by: EnseingantScalarFieldEnum[] | EnseingantScalarFieldEnum
    having?: EnseingantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnseingantCountAggregateInputType | true
    _avg?: EnseingantAvgAggregateInputType
    _sum?: EnseingantSumAggregateInputType
    _min?: EnseingantMinAggregateInputType
    _max?: EnseingantMaxAggregateInputType
  }

  export type EnseingantGroupByOutputType = {
    id: number
    userId: number
    CIN: number
    _count: EnseingantCountAggregateOutputType | null
    _avg: EnseingantAvgAggregateOutputType | null
    _sum: EnseingantSumAggregateOutputType | null
    _min: EnseingantMinAggregateOutputType | null
    _max: EnseingantMaxAggregateOutputType | null
  }

  type GetEnseingantGroupByPayload<T extends EnseingantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnseingantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnseingantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnseingantGroupByOutputType[P]>
            : GetScalarType<T[P], EnseingantGroupByOutputType[P]>
        }
      >
    >


  export type EnseingantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    CIN?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    EspaceCours?: boolean | Enseingant$EspaceCoursArgs<ExtArgs>
    _count?: boolean | EnseingantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enseingant"]>

  export type EnseingantSelectScalar = {
    id?: boolean
    userId?: boolean
    CIN?: boolean
  }

  export type EnseingantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    EspaceCours?: boolean | Enseingant$EspaceCoursArgs<ExtArgs>
    _count?: boolean | EnseingantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EnseingantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enseingant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      EspaceCours: Prisma.$EspaceCoursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      CIN: number
    }, ExtArgs["result"]["enseingant"]>
    composites: {}
  }


  type EnseingantGetPayload<S extends boolean | null | undefined | EnseingantDefaultArgs> = $Result.GetResult<Prisma.$EnseingantPayload, S>

  type EnseingantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnseingantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnseingantCountAggregateInputType | true
    }

  export interface EnseingantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enseingant'], meta: { name: 'Enseingant' } }
    /**
     * Find zero or one Enseingant that matches the filter.
     * @param {EnseingantFindUniqueArgs} args - Arguments to find a Enseingant
     * @example
     * // Get one Enseingant
     * const enseingant = await prisma.enseingant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnseingantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnseingantFindUniqueArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Enseingant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnseingantFindUniqueOrThrowArgs} args - Arguments to find a Enseingant
     * @example
     * // Get one Enseingant
     * const enseingant = await prisma.enseingant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnseingantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnseingantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Enseingant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantFindFirstArgs} args - Arguments to find a Enseingant
     * @example
     * // Get one Enseingant
     * const enseingant = await prisma.enseingant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnseingantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnseingantFindFirstArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Enseingant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantFindFirstOrThrowArgs} args - Arguments to find a Enseingant
     * @example
     * // Get one Enseingant
     * const enseingant = await prisma.enseingant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnseingantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnseingantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Enseingants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enseingants
     * const enseingants = await prisma.enseingant.findMany()
     * 
     * // Get first 10 Enseingants
     * const enseingants = await prisma.enseingant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enseingantWithIdOnly = await prisma.enseingant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnseingantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnseingantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Enseingant.
     * @param {EnseingantCreateArgs} args - Arguments to create a Enseingant.
     * @example
     * // Create one Enseingant
     * const Enseingant = await prisma.enseingant.create({
     *   data: {
     *     // ... data to create a Enseingant
     *   }
     * })
     * 
    **/
    create<T extends EnseingantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnseingantCreateArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Enseingants.
     *     @param {EnseingantCreateManyArgs} args - Arguments to create many Enseingants.
     *     @example
     *     // Create many Enseingants
     *     const enseingant = await prisma.enseingant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnseingantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnseingantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enseingant.
     * @param {EnseingantDeleteArgs} args - Arguments to delete one Enseingant.
     * @example
     * // Delete one Enseingant
     * const Enseingant = await prisma.enseingant.delete({
     *   where: {
     *     // ... filter to delete one Enseingant
     *   }
     * })
     * 
    **/
    delete<T extends EnseingantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnseingantDeleteArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Enseingant.
     * @param {EnseingantUpdateArgs} args - Arguments to update one Enseingant.
     * @example
     * // Update one Enseingant
     * const enseingant = await prisma.enseingant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnseingantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnseingantUpdateArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Enseingants.
     * @param {EnseingantDeleteManyArgs} args - Arguments to filter Enseingants to delete.
     * @example
     * // Delete a few Enseingants
     * const { count } = await prisma.enseingant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnseingantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnseingantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enseingants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enseingants
     * const enseingant = await prisma.enseingant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnseingantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnseingantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enseingant.
     * @param {EnseingantUpsertArgs} args - Arguments to update or create a Enseingant.
     * @example
     * // Update or create a Enseingant
     * const enseingant = await prisma.enseingant.upsert({
     *   create: {
     *     // ... data to create a Enseingant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enseingant we want to update
     *   }
     * })
    **/
    upsert<T extends EnseingantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnseingantUpsertArgs<ExtArgs>>
    ): Prisma__EnseingantClient<$Result.GetResult<Prisma.$EnseingantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Enseingants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantCountArgs} args - Arguments to filter Enseingants to count.
     * @example
     * // Count the number of Enseingants
     * const count = await prisma.enseingant.count({
     *   where: {
     *     // ... the filter for the Enseingants we want to count
     *   }
     * })
    **/
    count<T extends EnseingantCountArgs>(
      args?: Subset<T, EnseingantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnseingantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enseingant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnseingantAggregateArgs>(args: Subset<T, EnseingantAggregateArgs>): Prisma.PrismaPromise<GetEnseingantAggregateType<T>>

    /**
     * Group by Enseingant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseingantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnseingantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnseingantGroupByArgs['orderBy'] }
        : { orderBy?: EnseingantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnseingantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnseingantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enseingant model
   */
  readonly fields: EnseingantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enseingant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnseingantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    EspaceCours<T extends Enseingant$EspaceCoursArgs<ExtArgs> = {}>(args?: Subset<T, Enseingant$EspaceCoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Enseingant model
   */ 
  interface EnseingantFieldRefs {
    readonly id: FieldRef<"Enseingant", 'Int'>
    readonly userId: FieldRef<"Enseingant", 'Int'>
    readonly CIN: FieldRef<"Enseingant", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Enseingant findUnique
   */
  export type EnseingantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * Filter, which Enseingant to fetch.
     */
    where: EnseingantWhereUniqueInput
  }


  /**
   * Enseingant findUniqueOrThrow
   */
  export type EnseingantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * Filter, which Enseingant to fetch.
     */
    where: EnseingantWhereUniqueInput
  }


  /**
   * Enseingant findFirst
   */
  export type EnseingantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * Filter, which Enseingant to fetch.
     */
    where?: EnseingantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseingants to fetch.
     */
    orderBy?: EnseingantOrderByWithRelationInput | EnseingantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enseingants.
     */
    cursor?: EnseingantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseingants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseingants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enseingants.
     */
    distinct?: EnseingantScalarFieldEnum | EnseingantScalarFieldEnum[]
  }


  /**
   * Enseingant findFirstOrThrow
   */
  export type EnseingantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * Filter, which Enseingant to fetch.
     */
    where?: EnseingantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseingants to fetch.
     */
    orderBy?: EnseingantOrderByWithRelationInput | EnseingantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enseingants.
     */
    cursor?: EnseingantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseingants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseingants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enseingants.
     */
    distinct?: EnseingantScalarFieldEnum | EnseingantScalarFieldEnum[]
  }


  /**
   * Enseingant findMany
   */
  export type EnseingantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * Filter, which Enseingants to fetch.
     */
    where?: EnseingantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseingants to fetch.
     */
    orderBy?: EnseingantOrderByWithRelationInput | EnseingantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enseingants.
     */
    cursor?: EnseingantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseingants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseingants.
     */
    skip?: number
    distinct?: EnseingantScalarFieldEnum | EnseingantScalarFieldEnum[]
  }


  /**
   * Enseingant create
   */
  export type EnseingantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * The data needed to create a Enseingant.
     */
    data: XOR<EnseingantCreateInput, EnseingantUncheckedCreateInput>
  }


  /**
   * Enseingant createMany
   */
  export type EnseingantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enseingants.
     */
    data: EnseingantCreateManyInput | EnseingantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Enseingant update
   */
  export type EnseingantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * The data needed to update a Enseingant.
     */
    data: XOR<EnseingantUpdateInput, EnseingantUncheckedUpdateInput>
    /**
     * Choose, which Enseingant to update.
     */
    where: EnseingantWhereUniqueInput
  }


  /**
   * Enseingant updateMany
   */
  export type EnseingantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enseingants.
     */
    data: XOR<EnseingantUpdateManyMutationInput, EnseingantUncheckedUpdateManyInput>
    /**
     * Filter which Enseingants to update
     */
    where?: EnseingantWhereInput
  }


  /**
   * Enseingant upsert
   */
  export type EnseingantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * The filter to search for the Enseingant to update in case it exists.
     */
    where: EnseingantWhereUniqueInput
    /**
     * In case the Enseingant found by the `where` argument doesn't exist, create a new Enseingant with this data.
     */
    create: XOR<EnseingantCreateInput, EnseingantUncheckedCreateInput>
    /**
     * In case the Enseingant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnseingantUpdateInput, EnseingantUncheckedUpdateInput>
  }


  /**
   * Enseingant delete
   */
  export type EnseingantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
    /**
     * Filter which Enseingant to delete.
     */
    where: EnseingantWhereUniqueInput
  }


  /**
   * Enseingant deleteMany
   */
  export type EnseingantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enseingants to delete
     */
    where?: EnseingantWhereInput
  }


  /**
   * Enseingant.EspaceCours
   */
  export type Enseingant$EspaceCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspaceCours
     */
    select?: EspaceCoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspaceCoursInclude<ExtArgs> | null
    where?: EspaceCoursWhereInput
    orderBy?: EspaceCoursOrderByWithRelationInput | EspaceCoursOrderByWithRelationInput[]
    cursor?: EspaceCoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspaceCoursScalarFieldEnum | EspaceCoursScalarFieldEnum[]
  }


  /**
   * Enseingant without action
   */
  export type EnseingantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseingant
     */
    select?: EnseingantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnseingantInclude<ExtArgs> | null
  }



  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
    post: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    CIN: number | null
    post: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    CIN: number
    post: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
    post?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
    post?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    CIN?: true
    post?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    userId: number
    CIN: number
    post: string
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    CIN?: boolean
    post?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    CIN?: boolean
    post?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      CIN: number
      post: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly userId: FieldRef<"Admin", 'Int'>
    readonly CIN: FieldRef<"Admin", 'Int'>
    readonly post: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
  }



  /**
   * Model Gamification
   */

  export type AggregateGamification = {
    _count: GamificationCountAggregateOutputType | null
    _avg: GamificationAvgAggregateOutputType | null
    _sum: GamificationSumAggregateOutputType | null
    _min: GamificationMinAggregateOutputType | null
    _max: GamificationMaxAggregateOutputType | null
  }

  export type GamificationAvgAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceCoursId: number | null
    point: number | null
  }

  export type GamificationSumAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceCoursId: number | null
    point: number | null
  }

  export type GamificationMinAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceCoursId: number | null
    point: number | null
  }

  export type GamificationMaxAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceCoursId: number | null
    point: number | null
  }

  export type GamificationCountAggregateOutputType = {
    id: number
    etudiantId: number
    espaceCoursId: number
    point: number
    _all: number
  }


  export type GamificationAvgAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceCoursId?: true
    point?: true
  }

  export type GamificationSumAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceCoursId?: true
    point?: true
  }

  export type GamificationMinAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceCoursId?: true
    point?: true
  }

  export type GamificationMaxAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceCoursId?: true
    point?: true
  }

  export type GamificationCountAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceCoursId?: true
    point?: true
    _all?: true
  }

  export type GamificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gamification to aggregate.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gamifications
    **/
    _count?: true | GamificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamificationMaxAggregateInputType
  }

  export type GetGamificationAggregateType<T extends GamificationAggregateArgs> = {
        [P in keyof T & keyof AggregateGamification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamification[P]>
      : GetScalarType<T[P], AggregateGamification[P]>
  }




  export type GamificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamificationWhereInput
    orderBy?: GamificationOrderByWithAggregationInput | GamificationOrderByWithAggregationInput[]
    by: GamificationScalarFieldEnum[] | GamificationScalarFieldEnum
    having?: GamificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamificationCountAggregateInputType | true
    _avg?: GamificationAvgAggregateInputType
    _sum?: GamificationSumAggregateInputType
    _min?: GamificationMinAggregateInputType
    _max?: GamificationMaxAggregateInputType
  }

  export type GamificationGroupByOutputType = {
    id: number
    etudiantId: number
    espaceCoursId: number
    point: number
    _count: GamificationCountAggregateOutputType | null
    _avg: GamificationAvgAggregateOutputType | null
    _sum: GamificationSumAggregateOutputType | null
    _min: GamificationMinAggregateOutputType | null
    _max: GamificationMaxAggregateOutputType | null
  }

  type GetGamificationGroupByPayload<T extends GamificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamificationGroupByOutputType[P]>
            : GetScalarType<T[P], GamificationGroupByOutputType[P]>
        }
      >
    >


  export type GamificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etudiantId?: boolean
    espaceCoursId?: boolean
    point?: boolean
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    espaceCours?: boolean | EspaceCoursDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gamification"]>

  export type GamificationSelectScalar = {
    id?: boolean
    etudiantId?: boolean
    espaceCoursId?: boolean
    point?: boolean
  }

  export type GamificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    espaceCours?: boolean | EspaceCoursDefaultArgs<ExtArgs>
  }


  export type $GamificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gamification"
    objects: {
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
      espaceCours: Prisma.$EspaceCoursPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etudiantId: number
      espaceCoursId: number
      point: number
    }, ExtArgs["result"]["gamification"]>
    composites: {}
  }


  type GamificationGetPayload<S extends boolean | null | undefined | GamificationDefaultArgs> = $Result.GetResult<Prisma.$GamificationPayload, S>

  type GamificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GamificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamificationCountAggregateInputType | true
    }

  export interface GamificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gamification'], meta: { name: 'Gamification' } }
    /**
     * Find zero or one Gamification that matches the filter.
     * @param {GamificationFindUniqueArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GamificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GamificationFindUniqueArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Gamification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GamificationFindUniqueOrThrowArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GamificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GamificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Gamification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationFindFirstArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GamificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GamificationFindFirstArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Gamification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationFindFirstOrThrowArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GamificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GamificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Gamifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamifications
     * const gamifications = await prisma.gamification.findMany()
     * 
     * // Get first 10 Gamifications
     * const gamifications = await prisma.gamification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamificationWithIdOnly = await prisma.gamification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GamificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GamificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Gamification.
     * @param {GamificationCreateArgs} args - Arguments to create a Gamification.
     * @example
     * // Create one Gamification
     * const Gamification = await prisma.gamification.create({
     *   data: {
     *     // ... data to create a Gamification
     *   }
     * })
     * 
    **/
    create<T extends GamificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GamificationCreateArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Gamifications.
     *     @param {GamificationCreateManyArgs} args - Arguments to create many Gamifications.
     *     @example
     *     // Create many Gamifications
     *     const gamification = await prisma.gamification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GamificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GamificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gamification.
     * @param {GamificationDeleteArgs} args - Arguments to delete one Gamification.
     * @example
     * // Delete one Gamification
     * const Gamification = await prisma.gamification.delete({
     *   where: {
     *     // ... filter to delete one Gamification
     *   }
     * })
     * 
    **/
    delete<T extends GamificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GamificationDeleteArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Gamification.
     * @param {GamificationUpdateArgs} args - Arguments to update one Gamification.
     * @example
     * // Update one Gamification
     * const gamification = await prisma.gamification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GamificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GamificationUpdateArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Gamifications.
     * @param {GamificationDeleteManyArgs} args - Arguments to filter Gamifications to delete.
     * @example
     * // Delete a few Gamifications
     * const { count } = await prisma.gamification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GamificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GamificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamifications
     * const gamification = await prisma.gamification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GamificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GamificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gamification.
     * @param {GamificationUpsertArgs} args - Arguments to update or create a Gamification.
     * @example
     * // Update or create a Gamification
     * const gamification = await prisma.gamification.upsert({
     *   create: {
     *     // ... data to create a Gamification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamification we want to update
     *   }
     * })
    **/
    upsert<T extends GamificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GamificationUpsertArgs<ExtArgs>>
    ): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Gamifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationCountArgs} args - Arguments to filter Gamifications to count.
     * @example
     * // Count the number of Gamifications
     * const count = await prisma.gamification.count({
     *   where: {
     *     // ... the filter for the Gamifications we want to count
     *   }
     * })
    **/
    count<T extends GamificationCountArgs>(
      args?: Subset<T, GamificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamificationAggregateArgs>(args: Subset<T, GamificationAggregateArgs>): Prisma.PrismaPromise<GetGamificationAggregateType<T>>

    /**
     * Group by Gamification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GamificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GamificationGroupByArgs['orderBy'] }
        : { orderBy?: GamificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GamificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gamification model
   */
  readonly fields: GamificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gamification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GamificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    espaceCours<T extends EspaceCoursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspaceCoursDefaultArgs<ExtArgs>>): Prisma__EspaceCoursClient<$Result.GetResult<Prisma.$EspaceCoursPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Gamification model
   */ 
  interface GamificationFieldRefs {
    readonly id: FieldRef<"Gamification", 'Int'>
    readonly etudiantId: FieldRef<"Gamification", 'Int'>
    readonly espaceCoursId: FieldRef<"Gamification", 'Int'>
    readonly point: FieldRef<"Gamification", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Gamification findUnique
   */
  export type GamificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where: GamificationWhereUniqueInput
  }


  /**
   * Gamification findUniqueOrThrow
   */
  export type GamificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where: GamificationWhereUniqueInput
  }


  /**
   * Gamification findFirst
   */
  export type GamificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gamifications.
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gamifications.
     */
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }


  /**
   * Gamification findFirstOrThrow
   */
  export type GamificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gamifications.
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gamifications.
     */
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }


  /**
   * Gamification findMany
   */
  export type GamificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamifications to fetch.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gamifications.
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }


  /**
   * Gamification create
   */
  export type GamificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Gamification.
     */
    data: XOR<GamificationCreateInput, GamificationUncheckedCreateInput>
  }


  /**
   * Gamification createMany
   */
  export type GamificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gamifications.
     */
    data: GamificationCreateManyInput | GamificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Gamification update
   */
  export type GamificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Gamification.
     */
    data: XOR<GamificationUpdateInput, GamificationUncheckedUpdateInput>
    /**
     * Choose, which Gamification to update.
     */
    where: GamificationWhereUniqueInput
  }


  /**
   * Gamification updateMany
   */
  export type GamificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gamifications.
     */
    data: XOR<GamificationUpdateManyMutationInput, GamificationUncheckedUpdateManyInput>
    /**
     * Filter which Gamifications to update
     */
    where?: GamificationWhereInput
  }


  /**
   * Gamification upsert
   */
  export type GamificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Gamification to update in case it exists.
     */
    where: GamificationWhereUniqueInput
    /**
     * In case the Gamification found by the `where` argument doesn't exist, create a new Gamification with this data.
     */
    create: XOR<GamificationCreateInput, GamificationUncheckedCreateInput>
    /**
     * In case the Gamification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GamificationUpdateInput, GamificationUncheckedUpdateInput>
  }


  /**
   * Gamification delete
   */
  export type GamificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter which Gamification to delete.
     */
    where: GamificationWhereUniqueInput
  }


  /**
   * Gamification deleteMany
   */
  export type GamificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gamifications to delete
     */
    where?: GamificationWhereInput
  }


  /**
   * Gamification without action
   */
  export type GamificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GamificationInclude<ExtArgs> | null
  }



  /**
   * Model Resultat
   */

  export type AggregateResultat = {
    _count: ResultatCountAggregateOutputType | null
    _avg: ResultatAvgAggregateOutputType | null
    _sum: ResultatSumAggregateOutputType | null
    _min: ResultatMinAggregateOutputType | null
    _max: ResultatMaxAggregateOutputType | null
  }

  export type ResultatAvgAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    testId: number | null
    point: number | null
  }

  export type ResultatSumAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    testId: number | null
    point: number | null
  }

  export type ResultatMinAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    testId: number | null
    point: number | null
  }

  export type ResultatMaxAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    testId: number | null
    point: number | null
  }

  export type ResultatCountAggregateOutputType = {
    id: number
    etudiantId: number
    testId: number
    point: number
    _all: number
  }


  export type ResultatAvgAggregateInputType = {
    id?: true
    etudiantId?: true
    testId?: true
    point?: true
  }

  export type ResultatSumAggregateInputType = {
    id?: true
    etudiantId?: true
    testId?: true
    point?: true
  }

  export type ResultatMinAggregateInputType = {
    id?: true
    etudiantId?: true
    testId?: true
    point?: true
  }

  export type ResultatMaxAggregateInputType = {
    id?: true
    etudiantId?: true
    testId?: true
    point?: true
  }

  export type ResultatCountAggregateInputType = {
    id?: true
    etudiantId?: true
    testId?: true
    point?: true
    _all?: true
  }

  export type ResultatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resultat to aggregate.
     */
    where?: ResultatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resultats to fetch.
     */
    orderBy?: ResultatOrderByWithRelationInput | ResultatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resultats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resultats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resultats
    **/
    _count?: true | ResultatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultatMaxAggregateInputType
  }

  export type GetResultatAggregateType<T extends ResultatAggregateArgs> = {
        [P in keyof T & keyof AggregateResultat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultat[P]>
      : GetScalarType<T[P], AggregateResultat[P]>
  }




  export type ResultatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultatWhereInput
    orderBy?: ResultatOrderByWithAggregationInput | ResultatOrderByWithAggregationInput[]
    by: ResultatScalarFieldEnum[] | ResultatScalarFieldEnum
    having?: ResultatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultatCountAggregateInputType | true
    _avg?: ResultatAvgAggregateInputType
    _sum?: ResultatSumAggregateInputType
    _min?: ResultatMinAggregateInputType
    _max?: ResultatMaxAggregateInputType
  }

  export type ResultatGroupByOutputType = {
    id: number
    etudiantId: number
    testId: number
    point: number
    _count: ResultatCountAggregateOutputType | null
    _avg: ResultatAvgAggregateOutputType | null
    _sum: ResultatSumAggregateOutputType | null
    _min: ResultatMinAggregateOutputType | null
    _max: ResultatMaxAggregateOutputType | null
  }

  type GetResultatGroupByPayload<T extends ResultatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultatGroupByOutputType[P]>
            : GetScalarType<T[P], ResultatGroupByOutputType[P]>
        }
      >
    >


  export type ResultatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etudiantId?: boolean
    testId?: boolean
    point?: boolean
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    test?: boolean | TestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultat"]>

  export type ResultatSelectScalar = {
    id?: boolean
    etudiantId?: boolean
    testId?: boolean
    point?: boolean
  }

  export type ResultatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    test?: boolean | TestDefaultArgs<ExtArgs>
  }


  export type $ResultatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resultat"
    objects: {
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
      test: Prisma.$TestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etudiantId: number
      testId: number
      point: number
    }, ExtArgs["result"]["resultat"]>
    composites: {}
  }


  type ResultatGetPayload<S extends boolean | null | undefined | ResultatDefaultArgs> = $Result.GetResult<Prisma.$ResultatPayload, S>

  type ResultatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResultatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResultatCountAggregateInputType | true
    }

  export interface ResultatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resultat'], meta: { name: 'Resultat' } }
    /**
     * Find zero or one Resultat that matches the filter.
     * @param {ResultatFindUniqueArgs} args - Arguments to find a Resultat
     * @example
     * // Get one Resultat
     * const resultat = await prisma.resultat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResultatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResultatFindUniqueArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Resultat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResultatFindUniqueOrThrowArgs} args - Arguments to find a Resultat
     * @example
     * // Get one Resultat
     * const resultat = await prisma.resultat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResultatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Resultat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatFindFirstArgs} args - Arguments to find a Resultat
     * @example
     * // Get one Resultat
     * const resultat = await prisma.resultat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResultatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultatFindFirstArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Resultat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatFindFirstOrThrowArgs} args - Arguments to find a Resultat
     * @example
     * // Get one Resultat
     * const resultat = await prisma.resultat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResultatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Resultats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resultats
     * const resultats = await prisma.resultat.findMany()
     * 
     * // Get first 10 Resultats
     * const resultats = await prisma.resultat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultatWithIdOnly = await prisma.resultat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResultatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Resultat.
     * @param {ResultatCreateArgs} args - Arguments to create a Resultat.
     * @example
     * // Create one Resultat
     * const Resultat = await prisma.resultat.create({
     *   data: {
     *     // ... data to create a Resultat
     *   }
     * })
     * 
    **/
    create<T extends ResultatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResultatCreateArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Resultats.
     *     @param {ResultatCreateManyArgs} args - Arguments to create many Resultats.
     *     @example
     *     // Create many Resultats
     *     const resultat = await prisma.resultat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResultatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resultat.
     * @param {ResultatDeleteArgs} args - Arguments to delete one Resultat.
     * @example
     * // Delete one Resultat
     * const Resultat = await prisma.resultat.delete({
     *   where: {
     *     // ... filter to delete one Resultat
     *   }
     * })
     * 
    **/
    delete<T extends ResultatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResultatDeleteArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Resultat.
     * @param {ResultatUpdateArgs} args - Arguments to update one Resultat.
     * @example
     * // Update one Resultat
     * const resultat = await prisma.resultat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResultatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResultatUpdateArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Resultats.
     * @param {ResultatDeleteManyArgs} args - Arguments to filter Resultats to delete.
     * @example
     * // Delete a few Resultats
     * const { count } = await prisma.resultat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResultatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResultatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resultats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resultats
     * const resultat = await prisma.resultat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResultatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResultatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resultat.
     * @param {ResultatUpsertArgs} args - Arguments to update or create a Resultat.
     * @example
     * // Update or create a Resultat
     * const resultat = await prisma.resultat.upsert({
     *   create: {
     *     // ... data to create a Resultat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resultat we want to update
     *   }
     * })
    **/
    upsert<T extends ResultatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResultatUpsertArgs<ExtArgs>>
    ): Prisma__ResultatClient<$Result.GetResult<Prisma.$ResultatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Resultats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatCountArgs} args - Arguments to filter Resultats to count.
     * @example
     * // Count the number of Resultats
     * const count = await prisma.resultat.count({
     *   where: {
     *     // ... the filter for the Resultats we want to count
     *   }
     * })
    **/
    count<T extends ResultatCountArgs>(
      args?: Subset<T, ResultatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resultat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultatAggregateArgs>(args: Subset<T, ResultatAggregateArgs>): Prisma.PrismaPromise<GetResultatAggregateType<T>>

    /**
     * Group by Resultat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultatGroupByArgs['orderBy'] }
        : { orderBy?: ResultatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resultat model
   */
  readonly fields: ResultatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resultat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    test<T extends TestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestDefaultArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Resultat model
   */ 
  interface ResultatFieldRefs {
    readonly id: FieldRef<"Resultat", 'Int'>
    readonly etudiantId: FieldRef<"Resultat", 'Int'>
    readonly testId: FieldRef<"Resultat", 'Int'>
    readonly point: FieldRef<"Resultat", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Resultat findUnique
   */
  export type ResultatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * Filter, which Resultat to fetch.
     */
    where: ResultatWhereUniqueInput
  }


  /**
   * Resultat findUniqueOrThrow
   */
  export type ResultatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * Filter, which Resultat to fetch.
     */
    where: ResultatWhereUniqueInput
  }


  /**
   * Resultat findFirst
   */
  export type ResultatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * Filter, which Resultat to fetch.
     */
    where?: ResultatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resultats to fetch.
     */
    orderBy?: ResultatOrderByWithRelationInput | ResultatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resultats.
     */
    cursor?: ResultatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resultats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resultats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resultats.
     */
    distinct?: ResultatScalarFieldEnum | ResultatScalarFieldEnum[]
  }


  /**
   * Resultat findFirstOrThrow
   */
  export type ResultatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * Filter, which Resultat to fetch.
     */
    where?: ResultatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resultats to fetch.
     */
    orderBy?: ResultatOrderByWithRelationInput | ResultatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resultats.
     */
    cursor?: ResultatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resultats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resultats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resultats.
     */
    distinct?: ResultatScalarFieldEnum | ResultatScalarFieldEnum[]
  }


  /**
   * Resultat findMany
   */
  export type ResultatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * Filter, which Resultats to fetch.
     */
    where?: ResultatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resultats to fetch.
     */
    orderBy?: ResultatOrderByWithRelationInput | ResultatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resultats.
     */
    cursor?: ResultatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resultats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resultats.
     */
    skip?: number
    distinct?: ResultatScalarFieldEnum | ResultatScalarFieldEnum[]
  }


  /**
   * Resultat create
   */
  export type ResultatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * The data needed to create a Resultat.
     */
    data: XOR<ResultatCreateInput, ResultatUncheckedCreateInput>
  }


  /**
   * Resultat createMany
   */
  export type ResultatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resultats.
     */
    data: ResultatCreateManyInput | ResultatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Resultat update
   */
  export type ResultatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * The data needed to update a Resultat.
     */
    data: XOR<ResultatUpdateInput, ResultatUncheckedUpdateInput>
    /**
     * Choose, which Resultat to update.
     */
    where: ResultatWhereUniqueInput
  }


  /**
   * Resultat updateMany
   */
  export type ResultatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resultats.
     */
    data: XOR<ResultatUpdateManyMutationInput, ResultatUncheckedUpdateManyInput>
    /**
     * Filter which Resultats to update
     */
    where?: ResultatWhereInput
  }


  /**
   * Resultat upsert
   */
  export type ResultatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * The filter to search for the Resultat to update in case it exists.
     */
    where: ResultatWhereUniqueInput
    /**
     * In case the Resultat found by the `where` argument doesn't exist, create a new Resultat with this data.
     */
    create: XOR<ResultatCreateInput, ResultatUncheckedCreateInput>
    /**
     * In case the Resultat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultatUpdateInput, ResultatUncheckedUpdateInput>
  }


  /**
   * Resultat delete
   */
  export type ResultatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
    /**
     * Filter which Resultat to delete.
     */
    where: ResultatWhereUniqueInput
  }


  /**
   * Resultat deleteMany
   */
  export type ResultatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resultats to delete
     */
    where?: ResultatWhereInput
  }


  /**
   * Resultat without action
   */
  export type ResultatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resultat
     */
    select?: ResultatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResultatInclude<ExtArgs> | null
  }



  /**
   * Model TestQuestion
   */

  export type AggregateTestQuestion = {
    _count: TestQuestionCountAggregateOutputType | null
    _avg: TestQuestionAvgAggregateOutputType | null
    _sum: TestQuestionSumAggregateOutputType | null
    _min: TestQuestionMinAggregateOutputType | null
    _max: TestQuestionMaxAggregateOutputType | null
  }

  export type TestQuestionAvgAggregateOutputType = {
    id: number | null
    point: number | null
    banqueQuestionId: number | null
    testId: number | null
  }

  export type TestQuestionSumAggregateOutputType = {
    id: number | null
    point: number | null
    banqueQuestionId: number | null
    testId: number | null
  }

  export type TestQuestionMinAggregateOutputType = {
    id: number | null
    point: number | null
    banqueQuestionId: number | null
    testId: number | null
  }

  export type TestQuestionMaxAggregateOutputType = {
    id: number | null
    point: number | null
    banqueQuestionId: number | null
    testId: number | null
  }

  export type TestQuestionCountAggregateOutputType = {
    id: number
    point: number
    banqueQuestionId: number
    testId: number
    _all: number
  }


  export type TestQuestionAvgAggregateInputType = {
    id?: true
    point?: true
    banqueQuestionId?: true
    testId?: true
  }

  export type TestQuestionSumAggregateInputType = {
    id?: true
    point?: true
    banqueQuestionId?: true
    testId?: true
  }

  export type TestQuestionMinAggregateInputType = {
    id?: true
    point?: true
    banqueQuestionId?: true
    testId?: true
  }

  export type TestQuestionMaxAggregateInputType = {
    id?: true
    point?: true
    banqueQuestionId?: true
    testId?: true
  }

  export type TestQuestionCountAggregateInputType = {
    id?: true
    point?: true
    banqueQuestionId?: true
    testId?: true
    _all?: true
  }

  export type TestQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestQuestion to aggregate.
     */
    where?: TestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestQuestions to fetch.
     */
    orderBy?: TestQuestionOrderByWithRelationInput | TestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestQuestions
    **/
    _count?: true | TestQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestQuestionMaxAggregateInputType
  }

  export type GetTestQuestionAggregateType<T extends TestQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateTestQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestQuestion[P]>
      : GetScalarType<T[P], AggregateTestQuestion[P]>
  }




  export type TestQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestQuestionWhereInput
    orderBy?: TestQuestionOrderByWithAggregationInput | TestQuestionOrderByWithAggregationInput[]
    by: TestQuestionScalarFieldEnum[] | TestQuestionScalarFieldEnum
    having?: TestQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestQuestionCountAggregateInputType | true
    _avg?: TestQuestionAvgAggregateInputType
    _sum?: TestQuestionSumAggregateInputType
    _min?: TestQuestionMinAggregateInputType
    _max?: TestQuestionMaxAggregateInputType
  }

  export type TestQuestionGroupByOutputType = {
    id: number
    point: number
    banqueQuestionId: number
    testId: number
    _count: TestQuestionCountAggregateOutputType | null
    _avg: TestQuestionAvgAggregateOutputType | null
    _sum: TestQuestionSumAggregateOutputType | null
    _min: TestQuestionMinAggregateOutputType | null
    _max: TestQuestionMaxAggregateOutputType | null
  }

  type GetTestQuestionGroupByPayload<T extends TestQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], TestQuestionGroupByOutputType[P]>
        }
      >
    >


  export type TestQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    point?: boolean
    banqueQuestionId?: boolean
    testId?: boolean
    banqueQuestion?: boolean | BanqueQuestionDefaultArgs<ExtArgs>
    test?: boolean | TestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testQuestion"]>

  export type TestQuestionSelectScalar = {
    id?: boolean
    point?: boolean
    banqueQuestionId?: boolean
    testId?: boolean
  }

  export type TestQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueQuestion?: boolean | BanqueQuestionDefaultArgs<ExtArgs>
    test?: boolean | TestDefaultArgs<ExtArgs>
  }


  export type $TestQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestQuestion"
    objects: {
      banqueQuestion: Prisma.$BanqueQuestionPayload<ExtArgs>
      test: Prisma.$TestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      point: number
      banqueQuestionId: number
      testId: number
    }, ExtArgs["result"]["testQuestion"]>
    composites: {}
  }


  type TestQuestionGetPayload<S extends boolean | null | undefined | TestQuestionDefaultArgs> = $Result.GetResult<Prisma.$TestQuestionPayload, S>

  type TestQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestQuestionCountAggregateInputType | true
    }

  export interface TestQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestQuestion'], meta: { name: 'TestQuestion' } }
    /**
     * Find zero or one TestQuestion that matches the filter.
     * @param {TestQuestionFindUniqueArgs} args - Arguments to find a TestQuestion
     * @example
     * // Get one TestQuestion
     * const testQuestion = await prisma.testQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestQuestionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TestQuestionFindUniqueArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TestQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestQuestionFindUniqueOrThrowArgs} args - Arguments to find a TestQuestion
     * @example
     * // Get one TestQuestion
     * const testQuestion = await prisma.testQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestQuestionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestQuestionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TestQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionFindFirstArgs} args - Arguments to find a TestQuestion
     * @example
     * // Get one TestQuestion
     * const testQuestion = await prisma.testQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestQuestionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TestQuestionFindFirstArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TestQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionFindFirstOrThrowArgs} args - Arguments to find a TestQuestion
     * @example
     * // Get one TestQuestion
     * const testQuestion = await prisma.testQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestQuestionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestQuestionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TestQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestQuestions
     * const testQuestions = await prisma.testQuestion.findMany()
     * 
     * // Get first 10 TestQuestions
     * const testQuestions = await prisma.testQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testQuestionWithIdOnly = await prisma.testQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestQuestionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestQuestionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TestQuestion.
     * @param {TestQuestionCreateArgs} args - Arguments to create a TestQuestion.
     * @example
     * // Create one TestQuestion
     * const TestQuestion = await prisma.testQuestion.create({
     *   data: {
     *     // ... data to create a TestQuestion
     *   }
     * })
     * 
    **/
    create<T extends TestQuestionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TestQuestionCreateArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TestQuestions.
     *     @param {TestQuestionCreateManyArgs} args - Arguments to create many TestQuestions.
     *     @example
     *     // Create many TestQuestions
     *     const testQuestion = await prisma.testQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestQuestionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestQuestionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestQuestion.
     * @param {TestQuestionDeleteArgs} args - Arguments to delete one TestQuestion.
     * @example
     * // Delete one TestQuestion
     * const TestQuestion = await prisma.testQuestion.delete({
     *   where: {
     *     // ... filter to delete one TestQuestion
     *   }
     * })
     * 
    **/
    delete<T extends TestQuestionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TestQuestionDeleteArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TestQuestion.
     * @param {TestQuestionUpdateArgs} args - Arguments to update one TestQuestion.
     * @example
     * // Update one TestQuestion
     * const testQuestion = await prisma.testQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestQuestionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TestQuestionUpdateArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TestQuestions.
     * @param {TestQuestionDeleteManyArgs} args - Arguments to filter TestQuestions to delete.
     * @example
     * // Delete a few TestQuestions
     * const { count } = await prisma.testQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestQuestionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestQuestionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestQuestions
     * const testQuestion = await prisma.testQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestQuestionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TestQuestionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestQuestion.
     * @param {TestQuestionUpsertArgs} args - Arguments to update or create a TestQuestion.
     * @example
     * // Update or create a TestQuestion
     * const testQuestion = await prisma.testQuestion.upsert({
     *   create: {
     *     // ... data to create a TestQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends TestQuestionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TestQuestionUpsertArgs<ExtArgs>>
    ): Prisma__TestQuestionClient<$Result.GetResult<Prisma.$TestQuestionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TestQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionCountArgs} args - Arguments to filter TestQuestions to count.
     * @example
     * // Count the number of TestQuestions
     * const count = await prisma.testQuestion.count({
     *   where: {
     *     // ... the filter for the TestQuestions we want to count
     *   }
     * })
    **/
    count<T extends TestQuestionCountArgs>(
      args?: Subset<T, TestQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestQuestionAggregateArgs>(args: Subset<T, TestQuestionAggregateArgs>): Prisma.PrismaPromise<GetTestQuestionAggregateType<T>>

    /**
     * Group by TestQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestQuestionGroupByArgs['orderBy'] }
        : { orderBy?: TestQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestQuestion model
   */
  readonly fields: TestQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    banqueQuestion<T extends BanqueQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BanqueQuestionDefaultArgs<ExtArgs>>): Prisma__BanqueQuestionClient<$Result.GetResult<Prisma.$BanqueQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    test<T extends TestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestDefaultArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TestQuestion model
   */ 
  interface TestQuestionFieldRefs {
    readonly id: FieldRef<"TestQuestion", 'Int'>
    readonly point: FieldRef<"TestQuestion", 'Int'>
    readonly banqueQuestionId: FieldRef<"TestQuestion", 'Int'>
    readonly testId: FieldRef<"TestQuestion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TestQuestion findUnique
   */
  export type TestQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TestQuestion to fetch.
     */
    where: TestQuestionWhereUniqueInput
  }


  /**
   * TestQuestion findUniqueOrThrow
   */
  export type TestQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TestQuestion to fetch.
     */
    where: TestQuestionWhereUniqueInput
  }


  /**
   * TestQuestion findFirst
   */
  export type TestQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TestQuestion to fetch.
     */
    where?: TestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestQuestions to fetch.
     */
    orderBy?: TestQuestionOrderByWithRelationInput | TestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestQuestions.
     */
    cursor?: TestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestQuestions.
     */
    distinct?: TestQuestionScalarFieldEnum | TestQuestionScalarFieldEnum[]
  }


  /**
   * TestQuestion findFirstOrThrow
   */
  export type TestQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TestQuestion to fetch.
     */
    where?: TestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestQuestions to fetch.
     */
    orderBy?: TestQuestionOrderByWithRelationInput | TestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestQuestions.
     */
    cursor?: TestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestQuestions.
     */
    distinct?: TestQuestionScalarFieldEnum | TestQuestionScalarFieldEnum[]
  }


  /**
   * TestQuestion findMany
   */
  export type TestQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TestQuestions to fetch.
     */
    where?: TestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestQuestions to fetch.
     */
    orderBy?: TestQuestionOrderByWithRelationInput | TestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestQuestions.
     */
    cursor?: TestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestQuestions.
     */
    skip?: number
    distinct?: TestQuestionScalarFieldEnum | TestQuestionScalarFieldEnum[]
  }


  /**
   * TestQuestion create
   */
  export type TestQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a TestQuestion.
     */
    data: XOR<TestQuestionCreateInput, TestQuestionUncheckedCreateInput>
  }


  /**
   * TestQuestion createMany
   */
  export type TestQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestQuestions.
     */
    data: TestQuestionCreateManyInput | TestQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TestQuestion update
   */
  export type TestQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a TestQuestion.
     */
    data: XOR<TestQuestionUpdateInput, TestQuestionUncheckedUpdateInput>
    /**
     * Choose, which TestQuestion to update.
     */
    where: TestQuestionWhereUniqueInput
  }


  /**
   * TestQuestion updateMany
   */
  export type TestQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestQuestions.
     */
    data: XOR<TestQuestionUpdateManyMutationInput, TestQuestionUncheckedUpdateManyInput>
    /**
     * Filter which TestQuestions to update
     */
    where?: TestQuestionWhereInput
  }


  /**
   * TestQuestion upsert
   */
  export type TestQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the TestQuestion to update in case it exists.
     */
    where: TestQuestionWhereUniqueInput
    /**
     * In case the TestQuestion found by the `where` argument doesn't exist, create a new TestQuestion with this data.
     */
    create: XOR<TestQuestionCreateInput, TestQuestionUncheckedCreateInput>
    /**
     * In case the TestQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestQuestionUpdateInput, TestQuestionUncheckedUpdateInput>
  }


  /**
   * TestQuestion delete
   */
  export type TestQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
    /**
     * Filter which TestQuestion to delete.
     */
    where: TestQuestionWhereUniqueInput
  }


  /**
   * TestQuestion deleteMany
   */
  export type TestQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestQuestions to delete
     */
    where?: TestQuestionWhereInput
  }


  /**
   * TestQuestion without action
   */
  export type TestQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestQuestion
     */
    select?: TestQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestQuestionInclude<ExtArgs> | null
  }



  /**
   * Model Depot
   */

  export type AggregateDepot = {
    _count: DepotCountAggregateOutputType | null
    _avg: DepotAvgAggregateOutputType | null
    _sum: DepotSumAggregateOutputType | null
    _min: DepotMinAggregateOutputType | null
    _max: DepotMaxAggregateOutputType | null
  }

  export type DepotAvgAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceDepotId: number | null
  }

  export type DepotSumAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceDepotId: number | null
  }

  export type DepotMinAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceDepotId: number | null
    file: string | null
  }

  export type DepotMaxAggregateOutputType = {
    id: number | null
    etudiantId: number | null
    espaceDepotId: number | null
    file: string | null
  }

  export type DepotCountAggregateOutputType = {
    id: number
    etudiantId: number
    espaceDepotId: number
    file: number
    _all: number
  }


  export type DepotAvgAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceDepotId?: true
  }

  export type DepotSumAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceDepotId?: true
  }

  export type DepotMinAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceDepotId?: true
    file?: true
  }

  export type DepotMaxAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceDepotId?: true
    file?: true
  }

  export type DepotCountAggregateInputType = {
    id?: true
    etudiantId?: true
    espaceDepotId?: true
    file?: true
    _all?: true
  }

  export type DepotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depot to aggregate.
     */
    where?: DepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depots to fetch.
     */
    orderBy?: DepotOrderByWithRelationInput | DepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Depots
    **/
    _count?: true | DepotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepotMaxAggregateInputType
  }

  export type GetDepotAggregateType<T extends DepotAggregateArgs> = {
        [P in keyof T & keyof AggregateDepot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepot[P]>
      : GetScalarType<T[P], AggregateDepot[P]>
  }




  export type DepotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepotWhereInput
    orderBy?: DepotOrderByWithAggregationInput | DepotOrderByWithAggregationInput[]
    by: DepotScalarFieldEnum[] | DepotScalarFieldEnum
    having?: DepotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepotCountAggregateInputType | true
    _avg?: DepotAvgAggregateInputType
    _sum?: DepotSumAggregateInputType
    _min?: DepotMinAggregateInputType
    _max?: DepotMaxAggregateInputType
  }

  export type DepotGroupByOutputType = {
    id: number
    etudiantId: number
    espaceDepotId: number
    file: string
    _count: DepotCountAggregateOutputType | null
    _avg: DepotAvgAggregateOutputType | null
    _sum: DepotSumAggregateOutputType | null
    _min: DepotMinAggregateOutputType | null
    _max: DepotMaxAggregateOutputType | null
  }

  type GetDepotGroupByPayload<T extends DepotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepotGroupByOutputType[P]>
            : GetScalarType<T[P], DepotGroupByOutputType[P]>
        }
      >
    >


  export type DepotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etudiantId?: boolean
    espaceDepotId?: boolean
    file?: boolean
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    espaceDepot?: boolean | EspaceDepotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["depot"]>

  export type DepotSelectScalar = {
    id?: boolean
    etudiantId?: boolean
    espaceDepotId?: boolean
    file?: boolean
  }

  export type DepotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    espaceDepot?: boolean | EspaceDepotDefaultArgs<ExtArgs>
  }


  export type $DepotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Depot"
    objects: {
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
      espaceDepot: Prisma.$EspaceDepotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etudiantId: number
      espaceDepotId: number
      file: string
    }, ExtArgs["result"]["depot"]>
    composites: {}
  }


  type DepotGetPayload<S extends boolean | null | undefined | DepotDefaultArgs> = $Result.GetResult<Prisma.$DepotPayload, S>

  type DepotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepotCountAggregateInputType | true
    }

  export interface DepotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Depot'], meta: { name: 'Depot' } }
    /**
     * Find zero or one Depot that matches the filter.
     * @param {DepotFindUniqueArgs} args - Arguments to find a Depot
     * @example
     * // Get one Depot
     * const depot = await prisma.depot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DepotFindUniqueArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Depot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DepotFindUniqueOrThrowArgs} args - Arguments to find a Depot
     * @example
     * // Get one Depot
     * const depot = await prisma.depot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DepotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Depot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotFindFirstArgs} args - Arguments to find a Depot
     * @example
     * // Get one Depot
     * const depot = await prisma.depot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DepotFindFirstArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Depot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotFindFirstOrThrowArgs} args - Arguments to find a Depot
     * @example
     * // Get one Depot
     * const depot = await prisma.depot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DepotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Depots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Depots
     * const depots = await prisma.depot.findMany()
     * 
     * // Get first 10 Depots
     * const depots = await prisma.depot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depotWithIdOnly = await prisma.depot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DepotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Depot.
     * @param {DepotCreateArgs} args - Arguments to create a Depot.
     * @example
     * // Create one Depot
     * const Depot = await prisma.depot.create({
     *   data: {
     *     // ... data to create a Depot
     *   }
     * })
     * 
    **/
    create<T extends DepotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DepotCreateArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Depots.
     *     @param {DepotCreateManyArgs} args - Arguments to create many Depots.
     *     @example
     *     // Create many Depots
     *     const depot = await prisma.depot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DepotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Depot.
     * @param {DepotDeleteArgs} args - Arguments to delete one Depot.
     * @example
     * // Delete one Depot
     * const Depot = await prisma.depot.delete({
     *   where: {
     *     // ... filter to delete one Depot
     *   }
     * })
     * 
    **/
    delete<T extends DepotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DepotDeleteArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Depot.
     * @param {DepotUpdateArgs} args - Arguments to update one Depot.
     * @example
     * // Update one Depot
     * const depot = await prisma.depot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DepotUpdateArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Depots.
     * @param {DepotDeleteManyArgs} args - Arguments to filter Depots to delete.
     * @example
     * // Delete a few Depots
     * const { count } = await prisma.depot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Depots
     * const depot = await prisma.depot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DepotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Depot.
     * @param {DepotUpsertArgs} args - Arguments to update or create a Depot.
     * @example
     * // Update or create a Depot
     * const depot = await prisma.depot.upsert({
     *   create: {
     *     // ... data to create a Depot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Depot we want to update
     *   }
     * })
    **/
    upsert<T extends DepotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DepotUpsertArgs<ExtArgs>>
    ): Prisma__DepotClient<$Result.GetResult<Prisma.$DepotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Depots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotCountArgs} args - Arguments to filter Depots to count.
     * @example
     * // Count the number of Depots
     * const count = await prisma.depot.count({
     *   where: {
     *     // ... the filter for the Depots we want to count
     *   }
     * })
    **/
    count<T extends DepotCountArgs>(
      args?: Subset<T, DepotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Depot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepotAggregateArgs>(args: Subset<T, DepotAggregateArgs>): Prisma.PrismaPromise<GetDepotAggregateType<T>>

    /**
     * Group by Depot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepotGroupByArgs['orderBy'] }
        : { orderBy?: DepotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Depot model
   */
  readonly fields: DepotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Depot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    espaceDepot<T extends EspaceDepotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspaceDepotDefaultArgs<ExtArgs>>): Prisma__EspaceDepotClient<$Result.GetResult<Prisma.$EspaceDepotPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Depot model
   */ 
  interface DepotFieldRefs {
    readonly id: FieldRef<"Depot", 'Int'>
    readonly etudiantId: FieldRef<"Depot", 'Int'>
    readonly espaceDepotId: FieldRef<"Depot", 'Int'>
    readonly file: FieldRef<"Depot", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Depot findUnique
   */
  export type DepotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * Filter, which Depot to fetch.
     */
    where: DepotWhereUniqueInput
  }


  /**
   * Depot findUniqueOrThrow
   */
  export type DepotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * Filter, which Depot to fetch.
     */
    where: DepotWhereUniqueInput
  }


  /**
   * Depot findFirst
   */
  export type DepotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * Filter, which Depot to fetch.
     */
    where?: DepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depots to fetch.
     */
    orderBy?: DepotOrderByWithRelationInput | DepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depots.
     */
    cursor?: DepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depots.
     */
    distinct?: DepotScalarFieldEnum | DepotScalarFieldEnum[]
  }


  /**
   * Depot findFirstOrThrow
   */
  export type DepotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * Filter, which Depot to fetch.
     */
    where?: DepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depots to fetch.
     */
    orderBy?: DepotOrderByWithRelationInput | DepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depots.
     */
    cursor?: DepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depots.
     */
    distinct?: DepotScalarFieldEnum | DepotScalarFieldEnum[]
  }


  /**
   * Depot findMany
   */
  export type DepotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * Filter, which Depots to fetch.
     */
    where?: DepotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depots to fetch.
     */
    orderBy?: DepotOrderByWithRelationInput | DepotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Depots.
     */
    cursor?: DepotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depots.
     */
    skip?: number
    distinct?: DepotScalarFieldEnum | DepotScalarFieldEnum[]
  }


  /**
   * Depot create
   */
  export type DepotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * The data needed to create a Depot.
     */
    data: XOR<DepotCreateInput, DepotUncheckedCreateInput>
  }


  /**
   * Depot createMany
   */
  export type DepotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Depots.
     */
    data: DepotCreateManyInput | DepotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Depot update
   */
  export type DepotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * The data needed to update a Depot.
     */
    data: XOR<DepotUpdateInput, DepotUncheckedUpdateInput>
    /**
     * Choose, which Depot to update.
     */
    where: DepotWhereUniqueInput
  }


  /**
   * Depot updateMany
   */
  export type DepotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Depots.
     */
    data: XOR<DepotUpdateManyMutationInput, DepotUncheckedUpdateManyInput>
    /**
     * Filter which Depots to update
     */
    where?: DepotWhereInput
  }


  /**
   * Depot upsert
   */
  export type DepotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * The filter to search for the Depot to update in case it exists.
     */
    where: DepotWhereUniqueInput
    /**
     * In case the Depot found by the `where` argument doesn't exist, create a new Depot with this data.
     */
    create: XOR<DepotCreateInput, DepotUncheckedCreateInput>
    /**
     * In case the Depot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepotUpdateInput, DepotUncheckedUpdateInput>
  }


  /**
   * Depot delete
   */
  export type DepotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
    /**
     * Filter which Depot to delete.
     */
    where: DepotWhereUniqueInput
  }


  /**
   * Depot deleteMany
   */
  export type DepotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depots to delete
     */
    where?: DepotWhereInput
  }


  /**
   * Depot without action
   */
  export type DepotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depot
     */
    select?: DepotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepotInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SpecialiteScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    image: 'image'
  };

  export type SpecialiteScalarFieldEnum = (typeof SpecialiteScalarFieldEnum)[keyof typeof SpecialiteScalarFieldEnum]


  export const NiveauScalarFieldEnum: {
    id: 'id',
    num: 'num',
    specialiteId: 'specialiteId'
  };

  export type NiveauScalarFieldEnum = (typeof NiveauScalarFieldEnum)[keyof typeof NiveauScalarFieldEnum]


  export const EspaceCoursScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    image: 'image',
    cleAccee: 'cleAccee',
    niveauId: 'niveauId',
    enseingantId: 'enseingantId'
  };

  export type EspaceCoursScalarFieldEnum = (typeof EspaceCoursScalarFieldEnum)[keyof typeof EspaceCoursScalarFieldEnum]


  export const ThemeScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    espaceCoursId: 'espaceCoursId'
  };

  export type ThemeScalarFieldEnum = (typeof ThemeScalarFieldEnum)[keyof typeof ThemeScalarFieldEnum]


  export const EspaceDepotScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    type: 'type',
    themeId: 'themeId',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin'
  };

  export type EspaceDepotScalarFieldEnum = (typeof EspaceDepotScalarFieldEnum)[keyof typeof EspaceDepotScalarFieldEnum]


  export const RessourceScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    file: 'file',
    type: 'type',
    themeId: 'themeId',
    dateDepot: 'dateDepot'
  };

  export type RessourceScalarFieldEnum = (typeof RessourceScalarFieldEnum)[keyof typeof RessourceScalarFieldEnum]


  export const TestScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    point: 'point',
    periode: 'periode',
    themeId: 'themeId',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const BanqueQuestionScalarFieldEnum: {
    id: 'id',
    num: 'num',
    desc: 'desc',
    espaceCoursId: 'espaceCoursId'
  };

  export type BanqueQuestionScalarFieldEnum = (typeof BanqueQuestionScalarFieldEnum)[keyof typeof BanqueQuestionScalarFieldEnum]


  export const ReponseScalarFieldEnum: {
    id: 'id',
    num: 'num',
    desc: 'desc',
    isCorrecte: 'isCorrecte',
    banqueQuestionId: 'banqueQuestionId'
  };

  export type ReponseScalarFieldEnum = (typeof ReponseScalarFieldEnum)[keyof typeof ReponseScalarFieldEnum]


  export const CommentaireScalarFieldEnum: {
    id: 'id',
    desc: 'desc',
    font: 'font',
    italic: 'italic',
    ressourceId: 'ressourceId',
    userId: 'userId'
  };

  export type CommentaireScalarFieldEnum = (typeof CommentaireScalarFieldEnum)[keyof typeof CommentaireScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    prenom: 'prenom',
    nom: 'nom',
    email: 'email',
    image: 'image',
    password: 'password',
    telephone: 'telephone',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EtudiantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    matricule: 'matricule',
    dateNaiss: 'dateNaiss'
  };

  export type EtudiantScalarFieldEnum = (typeof EtudiantScalarFieldEnum)[keyof typeof EtudiantScalarFieldEnum]


  export const EnseingantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    CIN: 'CIN'
  };

  export type EnseingantScalarFieldEnum = (typeof EnseingantScalarFieldEnum)[keyof typeof EnseingantScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    CIN: 'CIN',
    post: 'post'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const GamificationScalarFieldEnum: {
    id: 'id',
    etudiantId: 'etudiantId',
    espaceCoursId: 'espaceCoursId',
    point: 'point'
  };

  export type GamificationScalarFieldEnum = (typeof GamificationScalarFieldEnum)[keyof typeof GamificationScalarFieldEnum]


  export const ResultatScalarFieldEnum: {
    id: 'id',
    etudiantId: 'etudiantId',
    testId: 'testId',
    point: 'point'
  };

  export type ResultatScalarFieldEnum = (typeof ResultatScalarFieldEnum)[keyof typeof ResultatScalarFieldEnum]


  export const TestQuestionScalarFieldEnum: {
    id: 'id',
    point: 'point',
    banqueQuestionId: 'banqueQuestionId',
    testId: 'testId'
  };

  export type TestQuestionScalarFieldEnum = (typeof TestQuestionScalarFieldEnum)[keyof typeof TestQuestionScalarFieldEnum]


  export const DepotScalarFieldEnum: {
    id: 'id',
    etudiantId: 'etudiantId',
    espaceDepotId: 'espaceDepotId',
    file: 'file'
  };

  export type DepotScalarFieldEnum = (typeof DepotScalarFieldEnum)[keyof typeof DepotScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'TypeFile'
   */
  export type EnumTypeFileFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeFile'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RoleUser'
   */
  export type EnumRoleUserFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleUser'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SpecialiteWhereInput = {
    AND?: SpecialiteWhereInput | SpecialiteWhereInput[]
    OR?: SpecialiteWhereInput[]
    NOT?: SpecialiteWhereInput | SpecialiteWhereInput[]
    id?: IntFilter<"Specialite"> | number
    nom?: StringFilter<"Specialite"> | string
    image?: StringFilter<"Specialite"> | string
    Niveau?: NiveauListRelationFilter
  }

  export type SpecialiteOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    Niveau?: NiveauOrderByRelationAggregateInput
  }

  export type SpecialiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: SpecialiteWhereInput | SpecialiteWhereInput[]
    OR?: SpecialiteWhereInput[]
    NOT?: SpecialiteWhereInput | SpecialiteWhereInput[]
    image?: StringFilter<"Specialite"> | string
    Niveau?: NiveauListRelationFilter
  }, "id" | "nom">

  export type SpecialiteOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    _count?: SpecialiteCountOrderByAggregateInput
    _avg?: SpecialiteAvgOrderByAggregateInput
    _max?: SpecialiteMaxOrderByAggregateInput
    _min?: SpecialiteMinOrderByAggregateInput
    _sum?: SpecialiteSumOrderByAggregateInput
  }

  export type SpecialiteScalarWhereWithAggregatesInput = {
    AND?: SpecialiteScalarWhereWithAggregatesInput | SpecialiteScalarWhereWithAggregatesInput[]
    OR?: SpecialiteScalarWhereWithAggregatesInput[]
    NOT?: SpecialiteScalarWhereWithAggregatesInput | SpecialiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Specialite"> | number
    nom?: StringWithAggregatesFilter<"Specialite"> | string
    image?: StringWithAggregatesFilter<"Specialite"> | string
  }

  export type NiveauWhereInput = {
    AND?: NiveauWhereInput | NiveauWhereInput[]
    OR?: NiveauWhereInput[]
    NOT?: NiveauWhereInput | NiveauWhereInput[]
    id?: IntFilter<"Niveau"> | number
    num?: IntFilter<"Niveau"> | number
    specialiteId?: IntFilter<"Niveau"> | number
    specialite?: XOR<SpecialiteRelationFilter, SpecialiteWhereInput>
    EspaceCours?: EspaceCoursListRelationFilter
  }

  export type NiveauOrderByWithRelationInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
    specialite?: SpecialiteOrderByWithRelationInput
    EspaceCours?: EspaceCoursOrderByRelationAggregateInput
  }

  export type NiveauWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NiveauWhereInput | NiveauWhereInput[]
    OR?: NiveauWhereInput[]
    NOT?: NiveauWhereInput | NiveauWhereInput[]
    num?: IntFilter<"Niveau"> | number
    specialiteId?: IntFilter<"Niveau"> | number
    specialite?: XOR<SpecialiteRelationFilter, SpecialiteWhereInput>
    EspaceCours?: EspaceCoursListRelationFilter
  }, "id">

  export type NiveauOrderByWithAggregationInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
    _count?: NiveauCountOrderByAggregateInput
    _avg?: NiveauAvgOrderByAggregateInput
    _max?: NiveauMaxOrderByAggregateInput
    _min?: NiveauMinOrderByAggregateInput
    _sum?: NiveauSumOrderByAggregateInput
  }

  export type NiveauScalarWhereWithAggregatesInput = {
    AND?: NiveauScalarWhereWithAggregatesInput | NiveauScalarWhereWithAggregatesInput[]
    OR?: NiveauScalarWhereWithAggregatesInput[]
    NOT?: NiveauScalarWhereWithAggregatesInput | NiveauScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Niveau"> | number
    num?: IntWithAggregatesFilter<"Niveau"> | number
    specialiteId?: IntWithAggregatesFilter<"Niveau"> | number
  }

  export type EspaceCoursWhereInput = {
    AND?: EspaceCoursWhereInput | EspaceCoursWhereInput[]
    OR?: EspaceCoursWhereInput[]
    NOT?: EspaceCoursWhereInput | EspaceCoursWhereInput[]
    id?: IntFilter<"EspaceCours"> | number
    nom?: StringFilter<"EspaceCours"> | string
    image?: StringFilter<"EspaceCours"> | string
    cleAccee?: StringFilter<"EspaceCours"> | string
    niveauId?: IntFilter<"EspaceCours"> | number
    enseingantId?: IntFilter<"EspaceCours"> | number
    niveau?: XOR<NiveauRelationFilter, NiveauWhereInput>
    enseingant?: XOR<EnseingantRelationFilter, EnseingantWhereInput>
    Theme?: ThemeListRelationFilter
    BanqueQuestion?: BanqueQuestionListRelationFilter
    Gamification?: GamificationListRelationFilter
  }

  export type EspaceCoursOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    cleAccee?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
    niveau?: NiveauOrderByWithRelationInput
    enseingant?: EnseingantOrderByWithRelationInput
    Theme?: ThemeOrderByRelationAggregateInput
    BanqueQuestion?: BanqueQuestionOrderByRelationAggregateInput
    Gamification?: GamificationOrderByRelationAggregateInput
  }

  export type EspaceCoursWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EspaceCoursWhereInput | EspaceCoursWhereInput[]
    OR?: EspaceCoursWhereInput[]
    NOT?: EspaceCoursWhereInput | EspaceCoursWhereInput[]
    nom?: StringFilter<"EspaceCours"> | string
    image?: StringFilter<"EspaceCours"> | string
    cleAccee?: StringFilter<"EspaceCours"> | string
    niveauId?: IntFilter<"EspaceCours"> | number
    enseingantId?: IntFilter<"EspaceCours"> | number
    niveau?: XOR<NiveauRelationFilter, NiveauWhereInput>
    enseingant?: XOR<EnseingantRelationFilter, EnseingantWhereInput>
    Theme?: ThemeListRelationFilter
    BanqueQuestion?: BanqueQuestionListRelationFilter
    Gamification?: GamificationListRelationFilter
  }, "id">

  export type EspaceCoursOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    cleAccee?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
    _count?: EspaceCoursCountOrderByAggregateInput
    _avg?: EspaceCoursAvgOrderByAggregateInput
    _max?: EspaceCoursMaxOrderByAggregateInput
    _min?: EspaceCoursMinOrderByAggregateInput
    _sum?: EspaceCoursSumOrderByAggregateInput
  }

  export type EspaceCoursScalarWhereWithAggregatesInput = {
    AND?: EspaceCoursScalarWhereWithAggregatesInput | EspaceCoursScalarWhereWithAggregatesInput[]
    OR?: EspaceCoursScalarWhereWithAggregatesInput[]
    NOT?: EspaceCoursScalarWhereWithAggregatesInput | EspaceCoursScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EspaceCours"> | number
    nom?: StringWithAggregatesFilter<"EspaceCours"> | string
    image?: StringWithAggregatesFilter<"EspaceCours"> | string
    cleAccee?: StringWithAggregatesFilter<"EspaceCours"> | string
    niveauId?: IntWithAggregatesFilter<"EspaceCours"> | number
    enseingantId?: IntWithAggregatesFilter<"EspaceCours"> | number
  }

  export type ThemeWhereInput = {
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    id?: IntFilter<"Theme"> | number
    nom?: StringFilter<"Theme"> | string
    espaceCoursId?: IntFilter<"Theme"> | number
    espaceCours?: XOR<EspaceCoursRelationFilter, EspaceCoursWhereInput>
    EspaceDepot?: EspaceDepotListRelationFilter
    Ressource?: RessourceListRelationFilter
    Test?: TestListRelationFilter
  }

  export type ThemeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    espaceCoursId?: SortOrder
    espaceCours?: EspaceCoursOrderByWithRelationInput
    EspaceDepot?: EspaceDepotOrderByRelationAggregateInput
    Ressource?: RessourceOrderByRelationAggregateInput
    Test?: TestOrderByRelationAggregateInput
  }

  export type ThemeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    nom?: StringFilter<"Theme"> | string
    espaceCoursId?: IntFilter<"Theme"> | number
    espaceCours?: XOR<EspaceCoursRelationFilter, EspaceCoursWhereInput>
    EspaceDepot?: EspaceDepotListRelationFilter
    Ressource?: RessourceListRelationFilter
    Test?: TestListRelationFilter
  }, "id">

  export type ThemeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    espaceCoursId?: SortOrder
    _count?: ThemeCountOrderByAggregateInput
    _avg?: ThemeAvgOrderByAggregateInput
    _max?: ThemeMaxOrderByAggregateInput
    _min?: ThemeMinOrderByAggregateInput
    _sum?: ThemeSumOrderByAggregateInput
  }

  export type ThemeScalarWhereWithAggregatesInput = {
    AND?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    OR?: ThemeScalarWhereWithAggregatesInput[]
    NOT?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Theme"> | number
    nom?: StringWithAggregatesFilter<"Theme"> | string
    espaceCoursId?: IntWithAggregatesFilter<"Theme"> | number
  }

  export type EspaceDepotWhereInput = {
    AND?: EspaceDepotWhereInput | EspaceDepotWhereInput[]
    OR?: EspaceDepotWhereInput[]
    NOT?: EspaceDepotWhereInput | EspaceDepotWhereInput[]
    id?: IntFilter<"EspaceDepot"> | number
    nom?: StringFilter<"EspaceDepot"> | string
    type?: EnumTypeFileFilter<"EspaceDepot"> | $Enums.TypeFile
    themeId?: IntFilter<"EspaceDepot"> | number
    dateDebut?: DateTimeFilter<"EspaceDepot"> | Date | string
    dateFin?: DateTimeFilter<"EspaceDepot"> | Date | string
    theme?: XOR<ThemeRelationFilter, ThemeWhereInput>
    Depot?: DepotListRelationFilter
  }

  export type EspaceDepotOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    theme?: ThemeOrderByWithRelationInput
    Depot?: DepotOrderByRelationAggregateInput
  }

  export type EspaceDepotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EspaceDepotWhereInput | EspaceDepotWhereInput[]
    OR?: EspaceDepotWhereInput[]
    NOT?: EspaceDepotWhereInput | EspaceDepotWhereInput[]
    nom?: StringFilter<"EspaceDepot"> | string
    type?: EnumTypeFileFilter<"EspaceDepot"> | $Enums.TypeFile
    themeId?: IntFilter<"EspaceDepot"> | number
    dateDebut?: DateTimeFilter<"EspaceDepot"> | Date | string
    dateFin?: DateTimeFilter<"EspaceDepot"> | Date | string
    theme?: XOR<ThemeRelationFilter, ThemeWhereInput>
    Depot?: DepotListRelationFilter
  }, "id">

  export type EspaceDepotOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    _count?: EspaceDepotCountOrderByAggregateInput
    _avg?: EspaceDepotAvgOrderByAggregateInput
    _max?: EspaceDepotMaxOrderByAggregateInput
    _min?: EspaceDepotMinOrderByAggregateInput
    _sum?: EspaceDepotSumOrderByAggregateInput
  }

  export type EspaceDepotScalarWhereWithAggregatesInput = {
    AND?: EspaceDepotScalarWhereWithAggregatesInput | EspaceDepotScalarWhereWithAggregatesInput[]
    OR?: EspaceDepotScalarWhereWithAggregatesInput[]
    NOT?: EspaceDepotScalarWhereWithAggregatesInput | EspaceDepotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EspaceDepot"> | number
    nom?: StringWithAggregatesFilter<"EspaceDepot"> | string
    type?: EnumTypeFileWithAggregatesFilter<"EspaceDepot"> | $Enums.TypeFile
    themeId?: IntWithAggregatesFilter<"EspaceDepot"> | number
    dateDebut?: DateTimeWithAggregatesFilter<"EspaceDepot"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"EspaceDepot"> | Date | string
  }

  export type RessourceWhereInput = {
    AND?: RessourceWhereInput | RessourceWhereInput[]
    OR?: RessourceWhereInput[]
    NOT?: RessourceWhereInput | RessourceWhereInput[]
    id?: IntFilter<"Ressource"> | number
    nom?: StringFilter<"Ressource"> | string
    file?: StringFilter<"Ressource"> | string
    type?: EnumTypeFileFilter<"Ressource"> | $Enums.TypeFile
    themeId?: IntFilter<"Ressource"> | number
    dateDepot?: DateTimeFilter<"Ressource"> | Date | string
    theme?: XOR<ThemeRelationFilter, ThemeWhereInput>
    Commentaire?: CommentaireListRelationFilter
  }

  export type RessourceOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    file?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDepot?: SortOrder
    theme?: ThemeOrderByWithRelationInput
    Commentaire?: CommentaireOrderByRelationAggregateInput
  }

  export type RessourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RessourceWhereInput | RessourceWhereInput[]
    OR?: RessourceWhereInput[]
    NOT?: RessourceWhereInput | RessourceWhereInput[]
    nom?: StringFilter<"Ressource"> | string
    file?: StringFilter<"Ressource"> | string
    type?: EnumTypeFileFilter<"Ressource"> | $Enums.TypeFile
    themeId?: IntFilter<"Ressource"> | number
    dateDepot?: DateTimeFilter<"Ressource"> | Date | string
    theme?: XOR<ThemeRelationFilter, ThemeWhereInput>
    Commentaire?: CommentaireListRelationFilter
  }, "id">

  export type RessourceOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    file?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDepot?: SortOrder
    _count?: RessourceCountOrderByAggregateInput
    _avg?: RessourceAvgOrderByAggregateInput
    _max?: RessourceMaxOrderByAggregateInput
    _min?: RessourceMinOrderByAggregateInput
    _sum?: RessourceSumOrderByAggregateInput
  }

  export type RessourceScalarWhereWithAggregatesInput = {
    AND?: RessourceScalarWhereWithAggregatesInput | RessourceScalarWhereWithAggregatesInput[]
    OR?: RessourceScalarWhereWithAggregatesInput[]
    NOT?: RessourceScalarWhereWithAggregatesInput | RessourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ressource"> | number
    nom?: StringWithAggregatesFilter<"Ressource"> | string
    file?: StringWithAggregatesFilter<"Ressource"> | string
    type?: EnumTypeFileWithAggregatesFilter<"Ressource"> | $Enums.TypeFile
    themeId?: IntWithAggregatesFilter<"Ressource"> | number
    dateDepot?: DateTimeWithAggregatesFilter<"Ressource"> | Date | string
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    id?: IntFilter<"Test"> | number
    nom?: StringFilter<"Test"> | string
    point?: IntFilter<"Test"> | number
    periode?: IntFilter<"Test"> | number
    themeId?: IntFilter<"Test"> | number
    dateDebut?: DateTimeFilter<"Test"> | Date | string
    dateFin?: DateTimeFilter<"Test"> | Date | string
    theme?: XOR<ThemeRelationFilter, ThemeWhereInput>
    Resultat?: ResultatListRelationFilter
    TestQuestion?: TestQuestionListRelationFilter
  }

  export type TestOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    theme?: ThemeOrderByWithRelationInput
    Resultat?: ResultatOrderByRelationAggregateInput
    TestQuestion?: TestQuestionOrderByRelationAggregateInput
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    nom?: StringFilter<"Test"> | string
    point?: IntFilter<"Test"> | number
    periode?: IntFilter<"Test"> | number
    themeId?: IntFilter<"Test"> | number
    dateDebut?: DateTimeFilter<"Test"> | Date | string
    dateFin?: DateTimeFilter<"Test"> | Date | string
    theme?: XOR<ThemeRelationFilter, ThemeWhereInput>
    Resultat?: ResultatListRelationFilter
    TestQuestion?: TestQuestionListRelationFilter
  }, "id">

  export type TestOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Test"> | number
    nom?: StringWithAggregatesFilter<"Test"> | string
    point?: IntWithAggregatesFilter<"Test"> | number
    periode?: IntWithAggregatesFilter<"Test"> | number
    themeId?: IntWithAggregatesFilter<"Test"> | number
    dateDebut?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Test"> | Date | string
  }

  export type BanqueQuestionWhereInput = {
    AND?: BanqueQuestionWhereInput | BanqueQuestionWhereInput[]
    OR?: BanqueQuestionWhereInput[]
    NOT?: BanqueQuestionWhereInput | BanqueQuestionWhereInput[]
    id?: IntFilter<"BanqueQuestion"> | number
    num?: IntFilter<"BanqueQuestion"> | number
    desc?: StringFilter<"BanqueQuestion"> | string
    espaceCoursId?: IntFilter<"BanqueQuestion"> | number
    espaceCours?: XOR<EspaceCoursRelationFilter, EspaceCoursWhereInput>
    Reponse?: ReponseListRelationFilter
    TestQuestion?: TestQuestionListRelationFilter
  }

  export type BanqueQuestionOrderByWithRelationInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    espaceCoursId?: SortOrder
    espaceCours?: EspaceCoursOrderByWithRelationInput
    Reponse?: ReponseOrderByRelationAggregateInput
    TestQuestion?: TestQuestionOrderByRelationAggregateInput
  }

  export type BanqueQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    num?: number
    AND?: BanqueQuestionWhereInput | BanqueQuestionWhereInput[]
    OR?: BanqueQuestionWhereInput[]
    NOT?: BanqueQuestionWhereInput | BanqueQuestionWhereInput[]
    desc?: StringFilter<"BanqueQuestion"> | string
    espaceCoursId?: IntFilter<"BanqueQuestion"> | number
    espaceCours?: XOR<EspaceCoursRelationFilter, EspaceCoursWhereInput>
    Reponse?: ReponseListRelationFilter
    TestQuestion?: TestQuestionListRelationFilter
  }, "id" | "num">

  export type BanqueQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    espaceCoursId?: SortOrder
    _count?: BanqueQuestionCountOrderByAggregateInput
    _avg?: BanqueQuestionAvgOrderByAggregateInput
    _max?: BanqueQuestionMaxOrderByAggregateInput
    _min?: BanqueQuestionMinOrderByAggregateInput
    _sum?: BanqueQuestionSumOrderByAggregateInput
  }

  export type BanqueQuestionScalarWhereWithAggregatesInput = {
    AND?: BanqueQuestionScalarWhereWithAggregatesInput | BanqueQuestionScalarWhereWithAggregatesInput[]
    OR?: BanqueQuestionScalarWhereWithAggregatesInput[]
    NOT?: BanqueQuestionScalarWhereWithAggregatesInput | BanqueQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BanqueQuestion"> | number
    num?: IntWithAggregatesFilter<"BanqueQuestion"> | number
    desc?: StringWithAggregatesFilter<"BanqueQuestion"> | string
    espaceCoursId?: IntWithAggregatesFilter<"BanqueQuestion"> | number
  }

  export type ReponseWhereInput = {
    AND?: ReponseWhereInput | ReponseWhereInput[]
    OR?: ReponseWhereInput[]
    NOT?: ReponseWhereInput | ReponseWhereInput[]
    id?: IntFilter<"Reponse"> | number
    num?: IntFilter<"Reponse"> | number
    desc?: StringFilter<"Reponse"> | string
    isCorrecte?: BoolFilter<"Reponse"> | boolean
    banqueQuestionId?: IntFilter<"Reponse"> | number
    banqueQuestion?: XOR<BanqueQuestionRelationFilter, BanqueQuestionWhereInput>
  }

  export type ReponseOrderByWithRelationInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    isCorrecte?: SortOrder
    banqueQuestionId?: SortOrder
    banqueQuestion?: BanqueQuestionOrderByWithRelationInput
  }

  export type ReponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReponseWhereInput | ReponseWhereInput[]
    OR?: ReponseWhereInput[]
    NOT?: ReponseWhereInput | ReponseWhereInput[]
    num?: IntFilter<"Reponse"> | number
    desc?: StringFilter<"Reponse"> | string
    isCorrecte?: BoolFilter<"Reponse"> | boolean
    banqueQuestionId?: IntFilter<"Reponse"> | number
    banqueQuestion?: XOR<BanqueQuestionRelationFilter, BanqueQuestionWhereInput>
  }, "id">

  export type ReponseOrderByWithAggregationInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    isCorrecte?: SortOrder
    banqueQuestionId?: SortOrder
    _count?: ReponseCountOrderByAggregateInput
    _avg?: ReponseAvgOrderByAggregateInput
    _max?: ReponseMaxOrderByAggregateInput
    _min?: ReponseMinOrderByAggregateInput
    _sum?: ReponseSumOrderByAggregateInput
  }

  export type ReponseScalarWhereWithAggregatesInput = {
    AND?: ReponseScalarWhereWithAggregatesInput | ReponseScalarWhereWithAggregatesInput[]
    OR?: ReponseScalarWhereWithAggregatesInput[]
    NOT?: ReponseScalarWhereWithAggregatesInput | ReponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reponse"> | number
    num?: IntWithAggregatesFilter<"Reponse"> | number
    desc?: StringWithAggregatesFilter<"Reponse"> | string
    isCorrecte?: BoolWithAggregatesFilter<"Reponse"> | boolean
    banqueQuestionId?: IntWithAggregatesFilter<"Reponse"> | number
  }

  export type CommentaireWhereInput = {
    AND?: CommentaireWhereInput | CommentaireWhereInput[]
    OR?: CommentaireWhereInput[]
    NOT?: CommentaireWhereInput | CommentaireWhereInput[]
    id?: IntFilter<"Commentaire"> | number
    desc?: StringFilter<"Commentaire"> | string
    font?: StringFilter<"Commentaire"> | string
    italic?: BoolFilter<"Commentaire"> | boolean
    ressourceId?: IntFilter<"Commentaire"> | number
    userId?: IntFilter<"Commentaire"> | number
    ressource?: XOR<RessourceRelationFilter, RessourceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentaireOrderByWithRelationInput = {
    id?: SortOrder
    desc?: SortOrder
    font?: SortOrder
    italic?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
    ressource?: RessourceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentaireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentaireWhereInput | CommentaireWhereInput[]
    OR?: CommentaireWhereInput[]
    NOT?: CommentaireWhereInput | CommentaireWhereInput[]
    desc?: StringFilter<"Commentaire"> | string
    font?: StringFilter<"Commentaire"> | string
    italic?: BoolFilter<"Commentaire"> | boolean
    ressourceId?: IntFilter<"Commentaire"> | number
    userId?: IntFilter<"Commentaire"> | number
    ressource?: XOR<RessourceRelationFilter, RessourceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentaireOrderByWithAggregationInput = {
    id?: SortOrder
    desc?: SortOrder
    font?: SortOrder
    italic?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
    _count?: CommentaireCountOrderByAggregateInput
    _avg?: CommentaireAvgOrderByAggregateInput
    _max?: CommentaireMaxOrderByAggregateInput
    _min?: CommentaireMinOrderByAggregateInput
    _sum?: CommentaireSumOrderByAggregateInput
  }

  export type CommentaireScalarWhereWithAggregatesInput = {
    AND?: CommentaireScalarWhereWithAggregatesInput | CommentaireScalarWhereWithAggregatesInput[]
    OR?: CommentaireScalarWhereWithAggregatesInput[]
    NOT?: CommentaireScalarWhereWithAggregatesInput | CommentaireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commentaire"> | number
    desc?: StringWithAggregatesFilter<"Commentaire"> | string
    font?: StringWithAggregatesFilter<"Commentaire"> | string
    italic?: BoolWithAggregatesFilter<"Commentaire"> | boolean
    ressourceId?: IntWithAggregatesFilter<"Commentaire"> | number
    userId?: IntWithAggregatesFilter<"Commentaire"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    prenom?: StringFilter<"User"> | string
    nom?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    telephone?: IntFilter<"User"> | number
    role?: EnumRoleUserFilter<"User"> | $Enums.RoleUser
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Etudiant?: XOR<EtudiantNullableRelationFilter, EtudiantWhereInput> | null
    Enseingant?: XOR<EnseingantNullableRelationFilter, EnseingantWhereInput> | null
    Admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    Commentaire?: CommentaireListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    image?: SortOrder
    password?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Etudiant?: EtudiantOrderByWithRelationInput
    Enseingant?: EnseingantOrderByWithRelationInput
    Admin?: AdminOrderByWithRelationInput
    Commentaire?: CommentaireOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    prenom?: StringFilter<"User"> | string
    nom?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    telephone?: IntFilter<"User"> | number
    role?: EnumRoleUserFilter<"User"> | $Enums.RoleUser
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Etudiant?: XOR<EtudiantNullableRelationFilter, EtudiantWhereInput> | null
    Enseingant?: XOR<EnseingantNullableRelationFilter, EnseingantWhereInput> | null
    Admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    Commentaire?: CommentaireListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    image?: SortOrder
    password?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    prenom?: StringWithAggregatesFilter<"User"> | string
    nom?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    image?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    telephone?: IntWithAggregatesFilter<"User"> | number
    role?: EnumRoleUserWithAggregatesFilter<"User"> | $Enums.RoleUser
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EtudiantWhereInput = {
    AND?: EtudiantWhereInput | EtudiantWhereInput[]
    OR?: EtudiantWhereInput[]
    NOT?: EtudiantWhereInput | EtudiantWhereInput[]
    id?: IntFilter<"Etudiant"> | number
    userId?: IntFilter<"Etudiant"> | number
    matricule?: IntFilter<"Etudiant"> | number
    dateNaiss?: DateTimeFilter<"Etudiant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    Gamification?: GamificationListRelationFilter
    Resultat?: ResultatListRelationFilter
    Depot?: DepotListRelationFilter
  }

  export type EtudiantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    dateNaiss?: SortOrder
    user?: UserOrderByWithRelationInput
    Gamification?: GamificationOrderByRelationAggregateInput
    Resultat?: ResultatOrderByRelationAggregateInput
    Depot?: DepotOrderByRelationAggregateInput
  }

  export type EtudiantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    matricule?: number
    AND?: EtudiantWhereInput | EtudiantWhereInput[]
    OR?: EtudiantWhereInput[]
    NOT?: EtudiantWhereInput | EtudiantWhereInput[]
    dateNaiss?: DateTimeFilter<"Etudiant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    Gamification?: GamificationListRelationFilter
    Resultat?: ResultatListRelationFilter
    Depot?: DepotListRelationFilter
  }, "id" | "userId" | "matricule">

  export type EtudiantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    dateNaiss?: SortOrder
    _count?: EtudiantCountOrderByAggregateInput
    _avg?: EtudiantAvgOrderByAggregateInput
    _max?: EtudiantMaxOrderByAggregateInput
    _min?: EtudiantMinOrderByAggregateInput
    _sum?: EtudiantSumOrderByAggregateInput
  }

  export type EtudiantScalarWhereWithAggregatesInput = {
    AND?: EtudiantScalarWhereWithAggregatesInput | EtudiantScalarWhereWithAggregatesInput[]
    OR?: EtudiantScalarWhereWithAggregatesInput[]
    NOT?: EtudiantScalarWhereWithAggregatesInput | EtudiantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Etudiant"> | number
    userId?: IntWithAggregatesFilter<"Etudiant"> | number
    matricule?: IntWithAggregatesFilter<"Etudiant"> | number
    dateNaiss?: DateTimeWithAggregatesFilter<"Etudiant"> | Date | string
  }

  export type EnseingantWhereInput = {
    AND?: EnseingantWhereInput | EnseingantWhereInput[]
    OR?: EnseingantWhereInput[]
    NOT?: EnseingantWhereInput | EnseingantWhereInput[]
    id?: IntFilter<"Enseingant"> | number
    userId?: IntFilter<"Enseingant"> | number
    CIN?: IntFilter<"Enseingant"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    EspaceCours?: EspaceCoursListRelationFilter
  }

  export type EnseingantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    user?: UserOrderByWithRelationInput
    EspaceCours?: EspaceCoursOrderByRelationAggregateInput
  }

  export type EnseingantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    CIN?: number
    AND?: EnseingantWhereInput | EnseingantWhereInput[]
    OR?: EnseingantWhereInput[]
    NOT?: EnseingantWhereInput | EnseingantWhereInput[]
    user?: XOR<UserRelationFilter, UserWhereInput>
    EspaceCours?: EspaceCoursListRelationFilter
  }, "id" | "userId" | "CIN">

  export type EnseingantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    _count?: EnseingantCountOrderByAggregateInput
    _avg?: EnseingantAvgOrderByAggregateInput
    _max?: EnseingantMaxOrderByAggregateInput
    _min?: EnseingantMinOrderByAggregateInput
    _sum?: EnseingantSumOrderByAggregateInput
  }

  export type EnseingantScalarWhereWithAggregatesInput = {
    AND?: EnseingantScalarWhereWithAggregatesInput | EnseingantScalarWhereWithAggregatesInput[]
    OR?: EnseingantScalarWhereWithAggregatesInput[]
    NOT?: EnseingantScalarWhereWithAggregatesInput | EnseingantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enseingant"> | number
    userId?: IntWithAggregatesFilter<"Enseingant"> | number
    CIN?: IntWithAggregatesFilter<"Enseingant"> | number
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    userId?: IntFilter<"Admin"> | number
    CIN?: IntFilter<"Admin"> | number
    post?: StringFilter<"Admin"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    post?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    CIN?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    post?: StringFilter<"Admin"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "CIN">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    post?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    userId?: IntWithAggregatesFilter<"Admin"> | number
    CIN?: IntWithAggregatesFilter<"Admin"> | number
    post?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type GamificationWhereInput = {
    AND?: GamificationWhereInput | GamificationWhereInput[]
    OR?: GamificationWhereInput[]
    NOT?: GamificationWhereInput | GamificationWhereInput[]
    id?: IntFilter<"Gamification"> | number
    etudiantId?: IntFilter<"Gamification"> | number
    espaceCoursId?: IntFilter<"Gamification"> | number
    point?: IntFilter<"Gamification"> | number
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    espaceCours?: XOR<EspaceCoursRelationFilter, EspaceCoursWhereInput>
  }

  export type GamificationOrderByWithRelationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
    etudiant?: EtudiantOrderByWithRelationInput
    espaceCours?: EspaceCoursOrderByWithRelationInput
  }

  export type GamificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GamificationWhereInput | GamificationWhereInput[]
    OR?: GamificationWhereInput[]
    NOT?: GamificationWhereInput | GamificationWhereInput[]
    etudiantId?: IntFilter<"Gamification"> | number
    espaceCoursId?: IntFilter<"Gamification"> | number
    point?: IntFilter<"Gamification"> | number
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    espaceCours?: XOR<EspaceCoursRelationFilter, EspaceCoursWhereInput>
  }, "id">

  export type GamificationOrderByWithAggregationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
    _count?: GamificationCountOrderByAggregateInput
    _avg?: GamificationAvgOrderByAggregateInput
    _max?: GamificationMaxOrderByAggregateInput
    _min?: GamificationMinOrderByAggregateInput
    _sum?: GamificationSumOrderByAggregateInput
  }

  export type GamificationScalarWhereWithAggregatesInput = {
    AND?: GamificationScalarWhereWithAggregatesInput | GamificationScalarWhereWithAggregatesInput[]
    OR?: GamificationScalarWhereWithAggregatesInput[]
    NOT?: GamificationScalarWhereWithAggregatesInput | GamificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gamification"> | number
    etudiantId?: IntWithAggregatesFilter<"Gamification"> | number
    espaceCoursId?: IntWithAggregatesFilter<"Gamification"> | number
    point?: IntWithAggregatesFilter<"Gamification"> | number
  }

  export type ResultatWhereInput = {
    AND?: ResultatWhereInput | ResultatWhereInput[]
    OR?: ResultatWhereInput[]
    NOT?: ResultatWhereInput | ResultatWhereInput[]
    id?: IntFilter<"Resultat"> | number
    etudiantId?: IntFilter<"Resultat"> | number
    testId?: IntFilter<"Resultat"> | number
    point?: IntFilter<"Resultat"> | number
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    test?: XOR<TestRelationFilter, TestWhereInput>
  }

  export type ResultatOrderByWithRelationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
    etudiant?: EtudiantOrderByWithRelationInput
    test?: TestOrderByWithRelationInput
  }

  export type ResultatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResultatWhereInput | ResultatWhereInput[]
    OR?: ResultatWhereInput[]
    NOT?: ResultatWhereInput | ResultatWhereInput[]
    etudiantId?: IntFilter<"Resultat"> | number
    testId?: IntFilter<"Resultat"> | number
    point?: IntFilter<"Resultat"> | number
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    test?: XOR<TestRelationFilter, TestWhereInput>
  }, "id">

  export type ResultatOrderByWithAggregationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
    _count?: ResultatCountOrderByAggregateInput
    _avg?: ResultatAvgOrderByAggregateInput
    _max?: ResultatMaxOrderByAggregateInput
    _min?: ResultatMinOrderByAggregateInput
    _sum?: ResultatSumOrderByAggregateInput
  }

  export type ResultatScalarWhereWithAggregatesInput = {
    AND?: ResultatScalarWhereWithAggregatesInput | ResultatScalarWhereWithAggregatesInput[]
    OR?: ResultatScalarWhereWithAggregatesInput[]
    NOT?: ResultatScalarWhereWithAggregatesInput | ResultatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resultat"> | number
    etudiantId?: IntWithAggregatesFilter<"Resultat"> | number
    testId?: IntWithAggregatesFilter<"Resultat"> | number
    point?: IntWithAggregatesFilter<"Resultat"> | number
  }

  export type TestQuestionWhereInput = {
    AND?: TestQuestionWhereInput | TestQuestionWhereInput[]
    OR?: TestQuestionWhereInput[]
    NOT?: TestQuestionWhereInput | TestQuestionWhereInput[]
    id?: IntFilter<"TestQuestion"> | number
    point?: IntFilter<"TestQuestion"> | number
    banqueQuestionId?: IntFilter<"TestQuestion"> | number
    testId?: IntFilter<"TestQuestion"> | number
    banqueQuestion?: XOR<BanqueQuestionRelationFilter, BanqueQuestionWhereInput>
    test?: XOR<TestRelationFilter, TestWhereInput>
  }

  export type TestQuestionOrderByWithRelationInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
    banqueQuestion?: BanqueQuestionOrderByWithRelationInput
    test?: TestOrderByWithRelationInput
  }

  export type TestQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestQuestionWhereInput | TestQuestionWhereInput[]
    OR?: TestQuestionWhereInput[]
    NOT?: TestQuestionWhereInput | TestQuestionWhereInput[]
    point?: IntFilter<"TestQuestion"> | number
    banqueQuestionId?: IntFilter<"TestQuestion"> | number
    testId?: IntFilter<"TestQuestion"> | number
    banqueQuestion?: XOR<BanqueQuestionRelationFilter, BanqueQuestionWhereInput>
    test?: XOR<TestRelationFilter, TestWhereInput>
  }, "id">

  export type TestQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
    _count?: TestQuestionCountOrderByAggregateInput
    _avg?: TestQuestionAvgOrderByAggregateInput
    _max?: TestQuestionMaxOrderByAggregateInput
    _min?: TestQuestionMinOrderByAggregateInput
    _sum?: TestQuestionSumOrderByAggregateInput
  }

  export type TestQuestionScalarWhereWithAggregatesInput = {
    AND?: TestQuestionScalarWhereWithAggregatesInput | TestQuestionScalarWhereWithAggregatesInput[]
    OR?: TestQuestionScalarWhereWithAggregatesInput[]
    NOT?: TestQuestionScalarWhereWithAggregatesInput | TestQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestQuestion"> | number
    point?: IntWithAggregatesFilter<"TestQuestion"> | number
    banqueQuestionId?: IntWithAggregatesFilter<"TestQuestion"> | number
    testId?: IntWithAggregatesFilter<"TestQuestion"> | number
  }

  export type DepotWhereInput = {
    AND?: DepotWhereInput | DepotWhereInput[]
    OR?: DepotWhereInput[]
    NOT?: DepotWhereInput | DepotWhereInput[]
    id?: IntFilter<"Depot"> | number
    etudiantId?: IntFilter<"Depot"> | number
    espaceDepotId?: IntFilter<"Depot"> | number
    file?: StringFilter<"Depot"> | string
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    espaceDepot?: XOR<EspaceDepotRelationFilter, EspaceDepotWhereInput>
  }

  export type DepotOrderByWithRelationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
    file?: SortOrder
    etudiant?: EtudiantOrderByWithRelationInput
    espaceDepot?: EspaceDepotOrderByWithRelationInput
  }

  export type DepotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepotWhereInput | DepotWhereInput[]
    OR?: DepotWhereInput[]
    NOT?: DepotWhereInput | DepotWhereInput[]
    etudiantId?: IntFilter<"Depot"> | number
    espaceDepotId?: IntFilter<"Depot"> | number
    file?: StringFilter<"Depot"> | string
    etudiant?: XOR<EtudiantRelationFilter, EtudiantWhereInput>
    espaceDepot?: XOR<EspaceDepotRelationFilter, EspaceDepotWhereInput>
  }, "id">

  export type DepotOrderByWithAggregationInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
    file?: SortOrder
    _count?: DepotCountOrderByAggregateInput
    _avg?: DepotAvgOrderByAggregateInput
    _max?: DepotMaxOrderByAggregateInput
    _min?: DepotMinOrderByAggregateInput
    _sum?: DepotSumOrderByAggregateInput
  }

  export type DepotScalarWhereWithAggregatesInput = {
    AND?: DepotScalarWhereWithAggregatesInput | DepotScalarWhereWithAggregatesInput[]
    OR?: DepotScalarWhereWithAggregatesInput[]
    NOT?: DepotScalarWhereWithAggregatesInput | DepotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Depot"> | number
    etudiantId?: IntWithAggregatesFilter<"Depot"> | number
    espaceDepotId?: IntWithAggregatesFilter<"Depot"> | number
    file?: StringWithAggregatesFilter<"Depot"> | string
  }

  export type SpecialiteCreateInput = {
    nom: string
    image: string
    Niveau?: NiveauCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUncheckedCreateInput = {
    id?: number
    nom: string
    image: string
    Niveau?: NiveauUncheckedCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    Niveau?: NiveauUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    Niveau?: NiveauUncheckedUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteCreateManyInput = {
    id?: number
    nom: string
    image: string
  }

  export type SpecialiteUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type SpecialiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type NiveauCreateInput = {
    num: number
    specialite: SpecialiteCreateNestedOneWithoutNiveauInput
    EspaceCours?: EspaceCoursCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUncheckedCreateInput = {
    id?: number
    num: number
    specialiteId: number
    EspaceCours?: EspaceCoursUncheckedCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUpdateInput = {
    num?: IntFieldUpdateOperationsInput | number
    specialite?: SpecialiteUpdateOneRequiredWithoutNiveauNestedInput
    EspaceCours?: EspaceCoursUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
    EspaceCours?: EspaceCoursUncheckedUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauCreateManyInput = {
    id?: number
    num: number
    specialiteId: number
  }

  export type NiveauUpdateManyMutationInput = {
    num?: IntFieldUpdateOperationsInput | number
  }

  export type NiveauUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
  }

  export type EspaceCoursCreateInput = {
    nom: string
    image: string
    cleAccee: string
    niveau: NiveauCreateNestedOneWithoutEspaceCoursInput
    enseingant: EnseingantCreateNestedOneWithoutEspaceCoursInput
    Theme?: ThemeCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUncheckedCreateInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    enseingantId: number
    Theme?: ThemeUncheckedCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionUncheckedCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveau?: NiveauUpdateOneRequiredWithoutEspaceCoursNestedInput
    enseingant?: EnseingantUpdateOneRequiredWithoutEspaceCoursNestedInput
    Theme?: ThemeUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
    enseingantId?: IntFieldUpdateOperationsInput | number
    Theme?: ThemeUncheckedUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUncheckedUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursCreateManyInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    enseingantId: number
  }

  export type EspaceCoursUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
  }

  export type EspaceCoursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
    enseingantId?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeCreateInput = {
    nom: string
    espaceCours: EspaceCoursCreateNestedOneWithoutThemeInput
    EspaceDepot?: EspaceDepotCreateNestedManyWithoutThemeInput
    Ressource?: RessourceCreateNestedManyWithoutThemeInput
    Test?: TestCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateInput = {
    id?: number
    nom: string
    espaceCoursId: number
    EspaceDepot?: EspaceDepotUncheckedCreateNestedManyWithoutThemeInput
    Ressource?: RessourceUncheckedCreateNestedManyWithoutThemeInput
    Test?: TestUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutThemeNestedInput
    EspaceDepot?: EspaceDepotUpdateManyWithoutThemeNestedInput
    Ressource?: RessourceUpdateManyWithoutThemeNestedInput
    Test?: TestUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    EspaceDepot?: EspaceDepotUncheckedUpdateManyWithoutThemeNestedInput
    Ressource?: RessourceUncheckedUpdateManyWithoutThemeNestedInput
    Test?: TestUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ThemeCreateManyInput = {
    id?: number
    nom: string
    espaceCoursId: number
  }

  export type ThemeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
  }

  export type EspaceDepotCreateInput = {
    nom: string
    type: $Enums.TypeFile
    dateDebut?: Date | string
    dateFin: Date | string
    theme: ThemeCreateNestedOneWithoutEspaceDepotInput
    Depot?: DepotCreateNestedManyWithoutEspaceDepotInput
  }

  export type EspaceDepotUncheckedCreateInput = {
    id?: number
    nom: string
    type: $Enums.TypeFile
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
    Depot?: DepotUncheckedCreateNestedManyWithoutEspaceDepotInput
  }

  export type EspaceDepotUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutEspaceDepotNestedInput
    Depot?: DepotUpdateManyWithoutEspaceDepotNestedInput
  }

  export type EspaceDepotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Depot?: DepotUncheckedUpdateManyWithoutEspaceDepotNestedInput
  }

  export type EspaceDepotCreateManyInput = {
    id?: number
    nom: string
    type: $Enums.TypeFile
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
  }

  export type EspaceDepotUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EspaceDepotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RessourceCreateInput = {
    nom: string
    file: string
    type: $Enums.TypeFile
    dateDepot?: Date | string
    theme: ThemeCreateNestedOneWithoutRessourceInput
    Commentaire?: CommentaireCreateNestedManyWithoutRessourceInput
  }

  export type RessourceUncheckedCreateInput = {
    id?: number
    nom: string
    file: string
    type: $Enums.TypeFile
    themeId: number
    dateDepot?: Date | string
    Commentaire?: CommentaireUncheckedCreateNestedManyWithoutRessourceInput
  }

  export type RessourceUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutRessourceNestedInput
    Commentaire?: CommentaireUpdateManyWithoutRessourceNestedInput
  }

  export type RessourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    themeId?: IntFieldUpdateOperationsInput | number
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
    Commentaire?: CommentaireUncheckedUpdateManyWithoutRessourceNestedInput
  }

  export type RessourceCreateManyInput = {
    id?: number
    nom: string
    file: string
    type: $Enums.TypeFile
    themeId: number
    dateDepot?: Date | string
  }

  export type RessourceUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RessourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    themeId?: IntFieldUpdateOperationsInput | number
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCreateInput = {
    nom: string
    point: number
    periode: number
    dateDebut?: Date | string
    dateFin: Date | string
    theme: ThemeCreateNestedOneWithoutTestInput
    Resultat?: ResultatCreateNestedManyWithoutTestInput
    TestQuestion?: TestQuestionCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateInput = {
    id?: number
    nom: string
    point: number
    periode: number
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
    Resultat?: ResultatUncheckedCreateNestedManyWithoutTestInput
    TestQuestion?: TestQuestionUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutTestNestedInput
    Resultat?: ResultatUpdateManyWithoutTestNestedInput
    TestQuestion?: TestQuestionUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Resultat?: ResultatUncheckedUpdateManyWithoutTestNestedInput
    TestQuestion?: TestQuestionUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCreateManyInput = {
    id?: number
    nom: string
    point: number
    periode: number
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
  }

  export type TestUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanqueQuestionCreateInput = {
    num: number
    desc: string
    espaceCours: EspaceCoursCreateNestedOneWithoutBanqueQuestionInput
    Reponse?: ReponseCreateNestedManyWithoutBanqueQuestionInput
    TestQuestion?: TestQuestionCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionUncheckedCreateInput = {
    id?: number
    num: number
    desc: string
    espaceCoursId: number
    Reponse?: ReponseUncheckedCreateNestedManyWithoutBanqueQuestionInput
    TestQuestion?: TestQuestionUncheckedCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionUpdateInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutBanqueQuestionNestedInput
    Reponse?: ReponseUpdateManyWithoutBanqueQuestionNestedInput
    TestQuestion?: TestQuestionUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type BanqueQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    Reponse?: ReponseUncheckedUpdateManyWithoutBanqueQuestionNestedInput
    TestQuestion?: TestQuestionUncheckedUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type BanqueQuestionCreateManyInput = {
    id?: number
    num: number
    desc: string
    espaceCoursId: number
  }

  export type BanqueQuestionUpdateManyMutationInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type BanqueQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
  }

  export type ReponseCreateInput = {
    num: number
    desc: string
    isCorrecte: boolean
    banqueQuestion: BanqueQuestionCreateNestedOneWithoutReponseInput
  }

  export type ReponseUncheckedCreateInput = {
    id?: number
    num: number
    desc: string
    isCorrecte: boolean
    banqueQuestionId: number
  }

  export type ReponseUpdateInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
    banqueQuestion?: BanqueQuestionUpdateOneRequiredWithoutReponseNestedInput
  }

  export type ReponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
    banqueQuestionId?: IntFieldUpdateOperationsInput | number
  }

  export type ReponseCreateManyInput = {
    id?: number
    num: number
    desc: string
    isCorrecte: boolean
    banqueQuestionId: number
  }

  export type ReponseUpdateManyMutationInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
    banqueQuestionId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireCreateInput = {
    desc: string
    font: string
    italic: boolean
    ressource: RessourceCreateNestedOneWithoutCommentaireInput
    user: UserCreateNestedOneWithoutCommentaireInput
  }

  export type CommentaireUncheckedCreateInput = {
    id?: number
    desc: string
    font: string
    italic: boolean
    ressourceId: number
    userId: number
  }

  export type CommentaireUpdateInput = {
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    ressource?: RessourceUpdateOneRequiredWithoutCommentaireNestedInput
    user?: UserUpdateOneRequiredWithoutCommentaireNestedInput
  }

  export type CommentaireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    ressourceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireCreateManyInput = {
    id?: number
    desc: string
    font: string
    italic: boolean
    ressourceId: number
    userId: number
  }

  export type CommentaireUpdateManyMutationInput = {
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    ressourceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantCreateNestedOneWithoutUserInput
    Enseingant?: EnseingantCreateNestedOneWithoutUserInput
    Admin?: AdminCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantUncheckedCreateNestedOneWithoutUserInput
    Enseingant?: EnseingantUncheckedCreateNestedOneWithoutUserInput
    Admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUpdateOneWithoutUserNestedInput
    Enseingant?: EnseingantUpdateOneWithoutUserNestedInput
    Admin?: AdminUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUncheckedUpdateOneWithoutUserNestedInput
    Enseingant?: EnseingantUncheckedUpdateOneWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtudiantCreateInput = {
    matricule: number
    dateNaiss: Date | string
    user: UserCreateNestedOneWithoutEtudiantInput
    Gamification?: GamificationCreateNestedManyWithoutEtudiantInput
    Resultat?: ResultatCreateNestedManyWithoutEtudiantInput
    Depot?: DepotCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateInput = {
    id?: number
    userId: number
    matricule: number
    dateNaiss: Date | string
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEtudiantInput
    Resultat?: ResultatUncheckedCreateNestedManyWithoutEtudiantInput
    Depot?: DepotUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUpdateInput = {
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEtudiantNestedInput
    Gamification?: GamificationUpdateManyWithoutEtudiantNestedInput
    Resultat?: ResultatUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    Gamification?: GamificationUncheckedUpdateManyWithoutEtudiantNestedInput
    Resultat?: ResultatUncheckedUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantCreateManyInput = {
    id?: number
    userId: number
    matricule: number
    dateNaiss: Date | string
  }

  export type EtudiantUpdateManyMutationInput = {
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtudiantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnseingantCreateInput = {
    CIN: number
    user: UserCreateNestedOneWithoutEnseingantInput
    EspaceCours?: EspaceCoursCreateNestedManyWithoutEnseingantInput
  }

  export type EnseingantUncheckedCreateInput = {
    id?: number
    userId: number
    CIN: number
    EspaceCours?: EspaceCoursUncheckedCreateNestedManyWithoutEnseingantInput
  }

  export type EnseingantUpdateInput = {
    CIN?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutEnseingantNestedInput
    EspaceCours?: EspaceCoursUpdateManyWithoutEnseingantNestedInput
  }

  export type EnseingantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
    EspaceCours?: EspaceCoursUncheckedUpdateManyWithoutEnseingantNestedInput
  }

  export type EnseingantCreateManyInput = {
    id?: number
    userId: number
    CIN: number
  }

  export type EnseingantUpdateManyMutationInput = {
    CIN?: IntFieldUpdateOperationsInput | number
  }

  export type EnseingantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateInput = {
    CIN: number
    post: string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    userId: number
    CIN: number
    post: string
  }

  export type AdminUpdateInput = {
    CIN?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: number
    userId: number
    CIN: number
    post: string
  }

  export type AdminUpdateManyMutationInput = {
    CIN?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
  }

  export type GamificationCreateInput = {
    point?: number
    etudiant: EtudiantCreateNestedOneWithoutGamificationInput
    espaceCours: EspaceCoursCreateNestedOneWithoutGamificationInput
  }

  export type GamificationUncheckedCreateInput = {
    id?: number
    etudiantId: number
    espaceCoursId: number
    point?: number
  }

  export type GamificationUpdateInput = {
    point?: IntFieldUpdateOperationsInput | number
    etudiant?: EtudiantUpdateOneRequiredWithoutGamificationNestedInput
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutGamificationNestedInput
  }

  export type GamificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type GamificationCreateManyInput = {
    id?: number
    etudiantId: number
    espaceCoursId: number
    point?: number
  }

  export type GamificationUpdateManyMutationInput = {
    point?: IntFieldUpdateOperationsInput | number
  }

  export type GamificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatCreateInput = {
    point?: number
    etudiant: EtudiantCreateNestedOneWithoutResultatInput
    test: TestCreateNestedOneWithoutResultatInput
  }

  export type ResultatUncheckedCreateInput = {
    id?: number
    etudiantId: number
    testId: number
    point?: number
  }

  export type ResultatUpdateInput = {
    point?: IntFieldUpdateOperationsInput | number
    etudiant?: EtudiantUpdateOneRequiredWithoutResultatNestedInput
    test?: TestUpdateOneRequiredWithoutResultatNestedInput
  }

  export type ResultatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatCreateManyInput = {
    id?: number
    etudiantId: number
    testId: number
    point?: number
  }

  export type ResultatUpdateManyMutationInput = {
    point?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type TestQuestionCreateInput = {
    point?: number
    banqueQuestion: BanqueQuestionCreateNestedOneWithoutTestQuestionInput
    test: TestCreateNestedOneWithoutTestQuestionInput
  }

  export type TestQuestionUncheckedCreateInput = {
    id?: number
    point?: number
    banqueQuestionId: number
    testId: number
  }

  export type TestQuestionUpdateInput = {
    point?: IntFieldUpdateOperationsInput | number
    banqueQuestion?: BanqueQuestionUpdateOneRequiredWithoutTestQuestionNestedInput
    test?: TestUpdateOneRequiredWithoutTestQuestionNestedInput
  }

  export type TestQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    banqueQuestionId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type TestQuestionCreateManyInput = {
    id?: number
    point?: number
    banqueQuestionId: number
    testId: number
  }

  export type TestQuestionUpdateManyMutationInput = {
    point?: IntFieldUpdateOperationsInput | number
  }

  export type TestQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    banqueQuestionId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type DepotCreateInput = {
    file: string
    etudiant: EtudiantCreateNestedOneWithoutDepotInput
    espaceDepot: EspaceDepotCreateNestedOneWithoutDepotInput
  }

  export type DepotUncheckedCreateInput = {
    id?: number
    etudiantId: number
    espaceDepotId: number
    file: string
  }

  export type DepotUpdateInput = {
    file?: StringFieldUpdateOperationsInput | string
    etudiant?: EtudiantUpdateOneRequiredWithoutDepotNestedInput
    espaceDepot?: EspaceDepotUpdateOneRequiredWithoutDepotNestedInput
  }

  export type DepotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    espaceDepotId?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type DepotCreateManyInput = {
    id?: number
    etudiantId: number
    espaceDepotId: number
    file: string
  }

  export type DepotUpdateManyMutationInput = {
    file?: StringFieldUpdateOperationsInput | string
  }

  export type DepotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    espaceDepotId?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NiveauListRelationFilter = {
    every?: NiveauWhereInput
    some?: NiveauWhereInput
    none?: NiveauWhereInput
  }

  export type NiveauOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialiteCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
  }

  export type SpecialiteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpecialiteMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
  }

  export type SpecialiteMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
  }

  export type SpecialiteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type SpecialiteRelationFilter = {
    is?: SpecialiteWhereInput
    isNot?: SpecialiteWhereInput
  }

  export type EspaceCoursListRelationFilter = {
    every?: EspaceCoursWhereInput
    some?: EspaceCoursWhereInput
    none?: EspaceCoursWhereInput
  }

  export type EspaceCoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NiveauCountOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
  }

  export type NiveauAvgOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
  }

  export type NiveauMaxOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
  }

  export type NiveauMinOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
  }

  export type NiveauSumOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    specialiteId?: SortOrder
  }

  export type NiveauRelationFilter = {
    is?: NiveauWhereInput
    isNot?: NiveauWhereInput
  }

  export type EnseingantRelationFilter = {
    is?: EnseingantWhereInput
    isNot?: EnseingantWhereInput
  }

  export type ThemeListRelationFilter = {
    every?: ThemeWhereInput
    some?: ThemeWhereInput
    none?: ThemeWhereInput
  }

  export type BanqueQuestionListRelationFilter = {
    every?: BanqueQuestionWhereInput
    some?: BanqueQuestionWhereInput
    none?: BanqueQuestionWhereInput
  }

  export type GamificationListRelationFilter = {
    every?: GamificationWhereInput
    some?: GamificationWhereInput
    none?: GamificationWhereInput
  }

  export type ThemeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BanqueQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GamificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EspaceCoursCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    cleAccee?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
  }

  export type EspaceCoursAvgOrderByAggregateInput = {
    id?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
  }

  export type EspaceCoursMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    cleAccee?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
  }

  export type EspaceCoursMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    image?: SortOrder
    cleAccee?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
  }

  export type EspaceCoursSumOrderByAggregateInput = {
    id?: SortOrder
    niveauId?: SortOrder
    enseingantId?: SortOrder
  }

  export type EspaceCoursRelationFilter = {
    is?: EspaceCoursWhereInput
    isNot?: EspaceCoursWhereInput
  }

  export type EspaceDepotListRelationFilter = {
    every?: EspaceDepotWhereInput
    some?: EspaceDepotWhereInput
    none?: EspaceDepotWhereInput
  }

  export type RessourceListRelationFilter = {
    every?: RessourceWhereInput
    some?: RessourceWhereInput
    none?: RessourceWhereInput
  }

  export type TestListRelationFilter = {
    every?: TestWhereInput
    some?: TestWhereInput
    none?: TestWhereInput
  }

  export type EspaceDepotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RessourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThemeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type ThemeAvgOrderByAggregateInput = {
    id?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type ThemeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type ThemeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type ThemeSumOrderByAggregateInput = {
    id?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type EnumTypeFileFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeFile | EnumTypeFileFieldRefInput<$PrismaModel>
    in?: $Enums.TypeFile[]
    notIn?: $Enums.TypeFile[]
    not?: NestedEnumTypeFileFilter<$PrismaModel> | $Enums.TypeFile
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ThemeRelationFilter = {
    is?: ThemeWhereInput
    isNot?: ThemeWhereInput
  }

  export type DepotListRelationFilter = {
    every?: DepotWhereInput
    some?: DepotWhereInput
    none?: DepotWhereInput
  }

  export type DepotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EspaceDepotCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EspaceDepotAvgOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
  }

  export type EspaceDepotMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EspaceDepotMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type EspaceDepotSumOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
  }

  export type EnumTypeFileWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeFile | EnumTypeFileFieldRefInput<$PrismaModel>
    in?: $Enums.TypeFile[]
    notIn?: $Enums.TypeFile[]
    not?: NestedEnumTypeFileWithAggregatesFilter<$PrismaModel> | $Enums.TypeFile
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeFileFilter<$PrismaModel>
    _max?: NestedEnumTypeFileFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CommentaireListRelationFilter = {
    every?: CommentaireWhereInput
    some?: CommentaireWhereInput
    none?: CommentaireWhereInput
  }

  export type CommentaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RessourceCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    file?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDepot?: SortOrder
  }

  export type RessourceAvgOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
  }

  export type RessourceMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    file?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDepot?: SortOrder
  }

  export type RessourceMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    file?: SortOrder
    type?: SortOrder
    themeId?: SortOrder
    dateDepot?: SortOrder
  }

  export type RessourceSumOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
  }

  export type ResultatListRelationFilter = {
    every?: ResultatWhereInput
    some?: ResultatWhereInput
    none?: ResultatWhereInput
  }

  export type TestQuestionListRelationFilter = {
    every?: TestQuestionWhereInput
    some?: TestQuestionWhereInput
    none?: TestQuestionWhereInput
  }

  export type ResultatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    periode?: SortOrder
    themeId?: SortOrder
  }

  export type ReponseListRelationFilter = {
    every?: ReponseWhereInput
    some?: ReponseWhereInput
    none?: ReponseWhereInput
  }

  export type ReponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BanqueQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type BanqueQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type BanqueQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type BanqueQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type BanqueQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    espaceCoursId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BanqueQuestionRelationFilter = {
    is?: BanqueQuestionWhereInput
    isNot?: BanqueQuestionWhereInput
  }

  export type ReponseCountOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    isCorrecte?: SortOrder
    banqueQuestionId?: SortOrder
  }

  export type ReponseAvgOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    banqueQuestionId?: SortOrder
  }

  export type ReponseMaxOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    isCorrecte?: SortOrder
    banqueQuestionId?: SortOrder
  }

  export type ReponseMinOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    desc?: SortOrder
    isCorrecte?: SortOrder
    banqueQuestionId?: SortOrder
  }

  export type ReponseSumOrderByAggregateInput = {
    id?: SortOrder
    num?: SortOrder
    banqueQuestionId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RessourceRelationFilter = {
    is?: RessourceWhereInput
    isNot?: RessourceWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CommentaireCountOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    font?: SortOrder
    italic?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
  }

  export type CommentaireAvgOrderByAggregateInput = {
    id?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
  }

  export type CommentaireMaxOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    font?: SortOrder
    italic?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
  }

  export type CommentaireMinOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    font?: SortOrder
    italic?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
  }

  export type CommentaireSumOrderByAggregateInput = {
    id?: SortOrder
    ressourceId?: SortOrder
    userId?: SortOrder
  }

  export type EnumRoleUserFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleUser | EnumRoleUserFieldRefInput<$PrismaModel>
    in?: $Enums.RoleUser[]
    notIn?: $Enums.RoleUser[]
    not?: NestedEnumRoleUserFilter<$PrismaModel> | $Enums.RoleUser
  }

  export type EtudiantNullableRelationFilter = {
    is?: EtudiantWhereInput | null
    isNot?: EtudiantWhereInput | null
  }

  export type EnseingantNullableRelationFilter = {
    is?: EnseingantWhereInput | null
    isNot?: EnseingantWhereInput | null
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    image?: SortOrder
    password?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    telephone?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    image?: SortOrder
    password?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    image?: SortOrder
    password?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    telephone?: SortOrder
  }

  export type EnumRoleUserWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleUser | EnumRoleUserFieldRefInput<$PrismaModel>
    in?: $Enums.RoleUser[]
    notIn?: $Enums.RoleUser[]
    not?: NestedEnumRoleUserWithAggregatesFilter<$PrismaModel> | $Enums.RoleUser
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleUserFilter<$PrismaModel>
    _max?: NestedEnumRoleUserFilter<$PrismaModel>
  }

  export type EtudiantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    dateNaiss?: SortOrder
  }

  export type EtudiantAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
  }

  export type EtudiantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    dateNaiss?: SortOrder
  }

  export type EtudiantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    dateNaiss?: SortOrder
  }

  export type EtudiantSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
  }

  export type EnseingantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type EnseingantAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type EnseingantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type EnseingantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type EnseingantSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    post?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    post?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
    post?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    CIN?: SortOrder
  }

  export type EtudiantRelationFilter = {
    is?: EtudiantWhereInput
    isNot?: EtudiantWhereInput
  }

  export type GamificationCountOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
  }

  export type GamificationAvgOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
  }

  export type GamificationMaxOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
  }

  export type GamificationMinOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
  }

  export type GamificationSumOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceCoursId?: SortOrder
    point?: SortOrder
  }

  export type TestRelationFilter = {
    is?: TestWhereInput
    isNot?: TestWhereInput
  }

  export type ResultatCountOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
  }

  export type ResultatAvgOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
  }

  export type ResultatMaxOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
  }

  export type ResultatMinOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
  }

  export type ResultatSumOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    testId?: SortOrder
    point?: SortOrder
  }

  export type TestQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
  }

  export type TestQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
  }

  export type TestQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
  }

  export type TestQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
  }

  export type TestQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    banqueQuestionId?: SortOrder
    testId?: SortOrder
  }

  export type EspaceDepotRelationFilter = {
    is?: EspaceDepotWhereInput
    isNot?: EspaceDepotWhereInput
  }

  export type DepotCountOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
    file?: SortOrder
  }

  export type DepotAvgOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
  }

  export type DepotMaxOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
    file?: SortOrder
  }

  export type DepotMinOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
    file?: SortOrder
  }

  export type DepotSumOrderByAggregateInput = {
    id?: SortOrder
    etudiantId?: SortOrder
    espaceDepotId?: SortOrder
  }

  export type NiveauCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<NiveauCreateWithoutSpecialiteInput, NiveauUncheckedCreateWithoutSpecialiteInput> | NiveauCreateWithoutSpecialiteInput[] | NiveauUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: NiveauCreateOrConnectWithoutSpecialiteInput | NiveauCreateOrConnectWithoutSpecialiteInput[]
    createMany?: NiveauCreateManySpecialiteInputEnvelope
    connect?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
  }

  export type NiveauUncheckedCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<NiveauCreateWithoutSpecialiteInput, NiveauUncheckedCreateWithoutSpecialiteInput> | NiveauCreateWithoutSpecialiteInput[] | NiveauUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: NiveauCreateOrConnectWithoutSpecialiteInput | NiveauCreateOrConnectWithoutSpecialiteInput[]
    createMany?: NiveauCreateManySpecialiteInputEnvelope
    connect?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NiveauUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<NiveauCreateWithoutSpecialiteInput, NiveauUncheckedCreateWithoutSpecialiteInput> | NiveauCreateWithoutSpecialiteInput[] | NiveauUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: NiveauCreateOrConnectWithoutSpecialiteInput | NiveauCreateOrConnectWithoutSpecialiteInput[]
    upsert?: NiveauUpsertWithWhereUniqueWithoutSpecialiteInput | NiveauUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: NiveauCreateManySpecialiteInputEnvelope
    set?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    disconnect?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    delete?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    connect?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    update?: NiveauUpdateWithWhereUniqueWithoutSpecialiteInput | NiveauUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: NiveauUpdateManyWithWhereWithoutSpecialiteInput | NiveauUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: NiveauScalarWhereInput | NiveauScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NiveauUncheckedUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<NiveauCreateWithoutSpecialiteInput, NiveauUncheckedCreateWithoutSpecialiteInput> | NiveauCreateWithoutSpecialiteInput[] | NiveauUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: NiveauCreateOrConnectWithoutSpecialiteInput | NiveauCreateOrConnectWithoutSpecialiteInput[]
    upsert?: NiveauUpsertWithWhereUniqueWithoutSpecialiteInput | NiveauUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: NiveauCreateManySpecialiteInputEnvelope
    set?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    disconnect?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    delete?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    connect?: NiveauWhereUniqueInput | NiveauWhereUniqueInput[]
    update?: NiveauUpdateWithWhereUniqueWithoutSpecialiteInput | NiveauUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: NiveauUpdateManyWithWhereWithoutSpecialiteInput | NiveauUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: NiveauScalarWhereInput | NiveauScalarWhereInput[]
  }

  export type SpecialiteCreateNestedOneWithoutNiveauInput = {
    create?: XOR<SpecialiteCreateWithoutNiveauInput, SpecialiteUncheckedCreateWithoutNiveauInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutNiveauInput
    connect?: SpecialiteWhereUniqueInput
  }

  export type EspaceCoursCreateNestedManyWithoutNiveauInput = {
    create?: XOR<EspaceCoursCreateWithoutNiveauInput, EspaceCoursUncheckedCreateWithoutNiveauInput> | EspaceCoursCreateWithoutNiveauInput[] | EspaceCoursUncheckedCreateWithoutNiveauInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutNiveauInput | EspaceCoursCreateOrConnectWithoutNiveauInput[]
    createMany?: EspaceCoursCreateManyNiveauInputEnvelope
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
  }

  export type EspaceCoursUncheckedCreateNestedManyWithoutNiveauInput = {
    create?: XOR<EspaceCoursCreateWithoutNiveauInput, EspaceCoursUncheckedCreateWithoutNiveauInput> | EspaceCoursCreateWithoutNiveauInput[] | EspaceCoursUncheckedCreateWithoutNiveauInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutNiveauInput | EspaceCoursCreateOrConnectWithoutNiveauInput[]
    createMany?: EspaceCoursCreateManyNiveauInputEnvelope
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
  }

  export type SpecialiteUpdateOneRequiredWithoutNiveauNestedInput = {
    create?: XOR<SpecialiteCreateWithoutNiveauInput, SpecialiteUncheckedCreateWithoutNiveauInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutNiveauInput
    upsert?: SpecialiteUpsertWithoutNiveauInput
    connect?: SpecialiteWhereUniqueInput
    update?: XOR<XOR<SpecialiteUpdateToOneWithWhereWithoutNiveauInput, SpecialiteUpdateWithoutNiveauInput>, SpecialiteUncheckedUpdateWithoutNiveauInput>
  }

  export type EspaceCoursUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutNiveauInput, EspaceCoursUncheckedCreateWithoutNiveauInput> | EspaceCoursCreateWithoutNiveauInput[] | EspaceCoursUncheckedCreateWithoutNiveauInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutNiveauInput | EspaceCoursCreateOrConnectWithoutNiveauInput[]
    upsert?: EspaceCoursUpsertWithWhereUniqueWithoutNiveauInput | EspaceCoursUpsertWithWhereUniqueWithoutNiveauInput[]
    createMany?: EspaceCoursCreateManyNiveauInputEnvelope
    set?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    disconnect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    delete?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    update?: EspaceCoursUpdateWithWhereUniqueWithoutNiveauInput | EspaceCoursUpdateWithWhereUniqueWithoutNiveauInput[]
    updateMany?: EspaceCoursUpdateManyWithWhereWithoutNiveauInput | EspaceCoursUpdateManyWithWhereWithoutNiveauInput[]
    deleteMany?: EspaceCoursScalarWhereInput | EspaceCoursScalarWhereInput[]
  }

  export type EspaceCoursUncheckedUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutNiveauInput, EspaceCoursUncheckedCreateWithoutNiveauInput> | EspaceCoursCreateWithoutNiveauInput[] | EspaceCoursUncheckedCreateWithoutNiveauInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutNiveauInput | EspaceCoursCreateOrConnectWithoutNiveauInput[]
    upsert?: EspaceCoursUpsertWithWhereUniqueWithoutNiveauInput | EspaceCoursUpsertWithWhereUniqueWithoutNiveauInput[]
    createMany?: EspaceCoursCreateManyNiveauInputEnvelope
    set?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    disconnect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    delete?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    update?: EspaceCoursUpdateWithWhereUniqueWithoutNiveauInput | EspaceCoursUpdateWithWhereUniqueWithoutNiveauInput[]
    updateMany?: EspaceCoursUpdateManyWithWhereWithoutNiveauInput | EspaceCoursUpdateManyWithWhereWithoutNiveauInput[]
    deleteMany?: EspaceCoursScalarWhereInput | EspaceCoursScalarWhereInput[]
  }

  export type NiveauCreateNestedOneWithoutEspaceCoursInput = {
    create?: XOR<NiveauCreateWithoutEspaceCoursInput, NiveauUncheckedCreateWithoutEspaceCoursInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutEspaceCoursInput
    connect?: NiveauWhereUniqueInput
  }

  export type EnseingantCreateNestedOneWithoutEspaceCoursInput = {
    create?: XOR<EnseingantCreateWithoutEspaceCoursInput, EnseingantUncheckedCreateWithoutEspaceCoursInput>
    connectOrCreate?: EnseingantCreateOrConnectWithoutEspaceCoursInput
    connect?: EnseingantWhereUniqueInput
  }

  export type ThemeCreateNestedManyWithoutEspaceCoursInput = {
    create?: XOR<ThemeCreateWithoutEspaceCoursInput, ThemeUncheckedCreateWithoutEspaceCoursInput> | ThemeCreateWithoutEspaceCoursInput[] | ThemeUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutEspaceCoursInput | ThemeCreateOrConnectWithoutEspaceCoursInput[]
    createMany?: ThemeCreateManyEspaceCoursInputEnvelope
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
  }

  export type BanqueQuestionCreateNestedManyWithoutEspaceCoursInput = {
    create?: XOR<BanqueQuestionCreateWithoutEspaceCoursInput, BanqueQuestionUncheckedCreateWithoutEspaceCoursInput> | BanqueQuestionCreateWithoutEspaceCoursInput[] | BanqueQuestionUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutEspaceCoursInput | BanqueQuestionCreateOrConnectWithoutEspaceCoursInput[]
    createMany?: BanqueQuestionCreateManyEspaceCoursInputEnvelope
    connect?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
  }

  export type GamificationCreateNestedManyWithoutEspaceCoursInput = {
    create?: XOR<GamificationCreateWithoutEspaceCoursInput, GamificationUncheckedCreateWithoutEspaceCoursInput> | GamificationCreateWithoutEspaceCoursInput[] | GamificationUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEspaceCoursInput | GamificationCreateOrConnectWithoutEspaceCoursInput[]
    createMany?: GamificationCreateManyEspaceCoursInputEnvelope
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
  }

  export type ThemeUncheckedCreateNestedManyWithoutEspaceCoursInput = {
    create?: XOR<ThemeCreateWithoutEspaceCoursInput, ThemeUncheckedCreateWithoutEspaceCoursInput> | ThemeCreateWithoutEspaceCoursInput[] | ThemeUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutEspaceCoursInput | ThemeCreateOrConnectWithoutEspaceCoursInput[]
    createMany?: ThemeCreateManyEspaceCoursInputEnvelope
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
  }

  export type BanqueQuestionUncheckedCreateNestedManyWithoutEspaceCoursInput = {
    create?: XOR<BanqueQuestionCreateWithoutEspaceCoursInput, BanqueQuestionUncheckedCreateWithoutEspaceCoursInput> | BanqueQuestionCreateWithoutEspaceCoursInput[] | BanqueQuestionUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutEspaceCoursInput | BanqueQuestionCreateOrConnectWithoutEspaceCoursInput[]
    createMany?: BanqueQuestionCreateManyEspaceCoursInputEnvelope
    connect?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
  }

  export type GamificationUncheckedCreateNestedManyWithoutEspaceCoursInput = {
    create?: XOR<GamificationCreateWithoutEspaceCoursInput, GamificationUncheckedCreateWithoutEspaceCoursInput> | GamificationCreateWithoutEspaceCoursInput[] | GamificationUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEspaceCoursInput | GamificationCreateOrConnectWithoutEspaceCoursInput[]
    createMany?: GamificationCreateManyEspaceCoursInputEnvelope
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
  }

  export type NiveauUpdateOneRequiredWithoutEspaceCoursNestedInput = {
    create?: XOR<NiveauCreateWithoutEspaceCoursInput, NiveauUncheckedCreateWithoutEspaceCoursInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutEspaceCoursInput
    upsert?: NiveauUpsertWithoutEspaceCoursInput
    connect?: NiveauWhereUniqueInput
    update?: XOR<XOR<NiveauUpdateToOneWithWhereWithoutEspaceCoursInput, NiveauUpdateWithoutEspaceCoursInput>, NiveauUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type EnseingantUpdateOneRequiredWithoutEspaceCoursNestedInput = {
    create?: XOR<EnseingantCreateWithoutEspaceCoursInput, EnseingantUncheckedCreateWithoutEspaceCoursInput>
    connectOrCreate?: EnseingantCreateOrConnectWithoutEspaceCoursInput
    upsert?: EnseingantUpsertWithoutEspaceCoursInput
    connect?: EnseingantWhereUniqueInput
    update?: XOR<XOR<EnseingantUpdateToOneWithWhereWithoutEspaceCoursInput, EnseingantUpdateWithoutEspaceCoursInput>, EnseingantUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type ThemeUpdateManyWithoutEspaceCoursNestedInput = {
    create?: XOR<ThemeCreateWithoutEspaceCoursInput, ThemeUncheckedCreateWithoutEspaceCoursInput> | ThemeCreateWithoutEspaceCoursInput[] | ThemeUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutEspaceCoursInput | ThemeCreateOrConnectWithoutEspaceCoursInput[]
    upsert?: ThemeUpsertWithWhereUniqueWithoutEspaceCoursInput | ThemeUpsertWithWhereUniqueWithoutEspaceCoursInput[]
    createMany?: ThemeCreateManyEspaceCoursInputEnvelope
    set?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    disconnect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    delete?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    update?: ThemeUpdateWithWhereUniqueWithoutEspaceCoursInput | ThemeUpdateWithWhereUniqueWithoutEspaceCoursInput[]
    updateMany?: ThemeUpdateManyWithWhereWithoutEspaceCoursInput | ThemeUpdateManyWithWhereWithoutEspaceCoursInput[]
    deleteMany?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
  }

  export type BanqueQuestionUpdateManyWithoutEspaceCoursNestedInput = {
    create?: XOR<BanqueQuestionCreateWithoutEspaceCoursInput, BanqueQuestionUncheckedCreateWithoutEspaceCoursInput> | BanqueQuestionCreateWithoutEspaceCoursInput[] | BanqueQuestionUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutEspaceCoursInput | BanqueQuestionCreateOrConnectWithoutEspaceCoursInput[]
    upsert?: BanqueQuestionUpsertWithWhereUniqueWithoutEspaceCoursInput | BanqueQuestionUpsertWithWhereUniqueWithoutEspaceCoursInput[]
    createMany?: BanqueQuestionCreateManyEspaceCoursInputEnvelope
    set?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    disconnect?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    delete?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    connect?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    update?: BanqueQuestionUpdateWithWhereUniqueWithoutEspaceCoursInput | BanqueQuestionUpdateWithWhereUniqueWithoutEspaceCoursInput[]
    updateMany?: BanqueQuestionUpdateManyWithWhereWithoutEspaceCoursInput | BanqueQuestionUpdateManyWithWhereWithoutEspaceCoursInput[]
    deleteMany?: BanqueQuestionScalarWhereInput | BanqueQuestionScalarWhereInput[]
  }

  export type GamificationUpdateManyWithoutEspaceCoursNestedInput = {
    create?: XOR<GamificationCreateWithoutEspaceCoursInput, GamificationUncheckedCreateWithoutEspaceCoursInput> | GamificationCreateWithoutEspaceCoursInput[] | GamificationUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEspaceCoursInput | GamificationCreateOrConnectWithoutEspaceCoursInput[]
    upsert?: GamificationUpsertWithWhereUniqueWithoutEspaceCoursInput | GamificationUpsertWithWhereUniqueWithoutEspaceCoursInput[]
    createMany?: GamificationCreateManyEspaceCoursInputEnvelope
    set?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    disconnect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    delete?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    update?: GamificationUpdateWithWhereUniqueWithoutEspaceCoursInput | GamificationUpdateWithWhereUniqueWithoutEspaceCoursInput[]
    updateMany?: GamificationUpdateManyWithWhereWithoutEspaceCoursInput | GamificationUpdateManyWithWhereWithoutEspaceCoursInput[]
    deleteMany?: GamificationScalarWhereInput | GamificationScalarWhereInput[]
  }

  export type ThemeUncheckedUpdateManyWithoutEspaceCoursNestedInput = {
    create?: XOR<ThemeCreateWithoutEspaceCoursInput, ThemeUncheckedCreateWithoutEspaceCoursInput> | ThemeCreateWithoutEspaceCoursInput[] | ThemeUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutEspaceCoursInput | ThemeCreateOrConnectWithoutEspaceCoursInput[]
    upsert?: ThemeUpsertWithWhereUniqueWithoutEspaceCoursInput | ThemeUpsertWithWhereUniqueWithoutEspaceCoursInput[]
    createMany?: ThemeCreateManyEspaceCoursInputEnvelope
    set?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    disconnect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    delete?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    update?: ThemeUpdateWithWhereUniqueWithoutEspaceCoursInput | ThemeUpdateWithWhereUniqueWithoutEspaceCoursInput[]
    updateMany?: ThemeUpdateManyWithWhereWithoutEspaceCoursInput | ThemeUpdateManyWithWhereWithoutEspaceCoursInput[]
    deleteMany?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
  }

  export type BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursNestedInput = {
    create?: XOR<BanqueQuestionCreateWithoutEspaceCoursInput, BanqueQuestionUncheckedCreateWithoutEspaceCoursInput> | BanqueQuestionCreateWithoutEspaceCoursInput[] | BanqueQuestionUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutEspaceCoursInput | BanqueQuestionCreateOrConnectWithoutEspaceCoursInput[]
    upsert?: BanqueQuestionUpsertWithWhereUniqueWithoutEspaceCoursInput | BanqueQuestionUpsertWithWhereUniqueWithoutEspaceCoursInput[]
    createMany?: BanqueQuestionCreateManyEspaceCoursInputEnvelope
    set?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    disconnect?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    delete?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    connect?: BanqueQuestionWhereUniqueInput | BanqueQuestionWhereUniqueInput[]
    update?: BanqueQuestionUpdateWithWhereUniqueWithoutEspaceCoursInput | BanqueQuestionUpdateWithWhereUniqueWithoutEspaceCoursInput[]
    updateMany?: BanqueQuestionUpdateManyWithWhereWithoutEspaceCoursInput | BanqueQuestionUpdateManyWithWhereWithoutEspaceCoursInput[]
    deleteMany?: BanqueQuestionScalarWhereInput | BanqueQuestionScalarWhereInput[]
  }

  export type GamificationUncheckedUpdateManyWithoutEspaceCoursNestedInput = {
    create?: XOR<GamificationCreateWithoutEspaceCoursInput, GamificationUncheckedCreateWithoutEspaceCoursInput> | GamificationCreateWithoutEspaceCoursInput[] | GamificationUncheckedCreateWithoutEspaceCoursInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEspaceCoursInput | GamificationCreateOrConnectWithoutEspaceCoursInput[]
    upsert?: GamificationUpsertWithWhereUniqueWithoutEspaceCoursInput | GamificationUpsertWithWhereUniqueWithoutEspaceCoursInput[]
    createMany?: GamificationCreateManyEspaceCoursInputEnvelope
    set?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    disconnect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    delete?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    update?: GamificationUpdateWithWhereUniqueWithoutEspaceCoursInput | GamificationUpdateWithWhereUniqueWithoutEspaceCoursInput[]
    updateMany?: GamificationUpdateManyWithWhereWithoutEspaceCoursInput | GamificationUpdateManyWithWhereWithoutEspaceCoursInput[]
    deleteMany?: GamificationScalarWhereInput | GamificationScalarWhereInput[]
  }

  export type EspaceCoursCreateNestedOneWithoutThemeInput = {
    create?: XOR<EspaceCoursCreateWithoutThemeInput, EspaceCoursUncheckedCreateWithoutThemeInput>
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutThemeInput
    connect?: EspaceCoursWhereUniqueInput
  }

  export type EspaceDepotCreateNestedManyWithoutThemeInput = {
    create?: XOR<EspaceDepotCreateWithoutThemeInput, EspaceDepotUncheckedCreateWithoutThemeInput> | EspaceDepotCreateWithoutThemeInput[] | EspaceDepotUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: EspaceDepotCreateOrConnectWithoutThemeInput | EspaceDepotCreateOrConnectWithoutThemeInput[]
    createMany?: EspaceDepotCreateManyThemeInputEnvelope
    connect?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
  }

  export type RessourceCreateNestedManyWithoutThemeInput = {
    create?: XOR<RessourceCreateWithoutThemeInput, RessourceUncheckedCreateWithoutThemeInput> | RessourceCreateWithoutThemeInput[] | RessourceUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: RessourceCreateOrConnectWithoutThemeInput | RessourceCreateOrConnectWithoutThemeInput[]
    createMany?: RessourceCreateManyThemeInputEnvelope
    connect?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
  }

  export type TestCreateNestedManyWithoutThemeInput = {
    create?: XOR<TestCreateWithoutThemeInput, TestUncheckedCreateWithoutThemeInput> | TestCreateWithoutThemeInput[] | TestUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: TestCreateOrConnectWithoutThemeInput | TestCreateOrConnectWithoutThemeInput[]
    createMany?: TestCreateManyThemeInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type EspaceDepotUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<EspaceDepotCreateWithoutThemeInput, EspaceDepotUncheckedCreateWithoutThemeInput> | EspaceDepotCreateWithoutThemeInput[] | EspaceDepotUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: EspaceDepotCreateOrConnectWithoutThemeInput | EspaceDepotCreateOrConnectWithoutThemeInput[]
    createMany?: EspaceDepotCreateManyThemeInputEnvelope
    connect?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
  }

  export type RessourceUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<RessourceCreateWithoutThemeInput, RessourceUncheckedCreateWithoutThemeInput> | RessourceCreateWithoutThemeInput[] | RessourceUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: RessourceCreateOrConnectWithoutThemeInput | RessourceCreateOrConnectWithoutThemeInput[]
    createMany?: RessourceCreateManyThemeInputEnvelope
    connect?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
  }

  export type TestUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<TestCreateWithoutThemeInput, TestUncheckedCreateWithoutThemeInput> | TestCreateWithoutThemeInput[] | TestUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: TestCreateOrConnectWithoutThemeInput | TestCreateOrConnectWithoutThemeInput[]
    createMany?: TestCreateManyThemeInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type EspaceCoursUpdateOneRequiredWithoutThemeNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutThemeInput, EspaceCoursUncheckedCreateWithoutThemeInput>
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutThemeInput
    upsert?: EspaceCoursUpsertWithoutThemeInput
    connect?: EspaceCoursWhereUniqueInput
    update?: XOR<XOR<EspaceCoursUpdateToOneWithWhereWithoutThemeInput, EspaceCoursUpdateWithoutThemeInput>, EspaceCoursUncheckedUpdateWithoutThemeInput>
  }

  export type EspaceDepotUpdateManyWithoutThemeNestedInput = {
    create?: XOR<EspaceDepotCreateWithoutThemeInput, EspaceDepotUncheckedCreateWithoutThemeInput> | EspaceDepotCreateWithoutThemeInput[] | EspaceDepotUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: EspaceDepotCreateOrConnectWithoutThemeInput | EspaceDepotCreateOrConnectWithoutThemeInput[]
    upsert?: EspaceDepotUpsertWithWhereUniqueWithoutThemeInput | EspaceDepotUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: EspaceDepotCreateManyThemeInputEnvelope
    set?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    disconnect?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    delete?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    connect?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    update?: EspaceDepotUpdateWithWhereUniqueWithoutThemeInput | EspaceDepotUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: EspaceDepotUpdateManyWithWhereWithoutThemeInput | EspaceDepotUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: EspaceDepotScalarWhereInput | EspaceDepotScalarWhereInput[]
  }

  export type RessourceUpdateManyWithoutThemeNestedInput = {
    create?: XOR<RessourceCreateWithoutThemeInput, RessourceUncheckedCreateWithoutThemeInput> | RessourceCreateWithoutThemeInput[] | RessourceUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: RessourceCreateOrConnectWithoutThemeInput | RessourceCreateOrConnectWithoutThemeInput[]
    upsert?: RessourceUpsertWithWhereUniqueWithoutThemeInput | RessourceUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: RessourceCreateManyThemeInputEnvelope
    set?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    disconnect?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    delete?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    connect?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    update?: RessourceUpdateWithWhereUniqueWithoutThemeInput | RessourceUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: RessourceUpdateManyWithWhereWithoutThemeInput | RessourceUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: RessourceScalarWhereInput | RessourceScalarWhereInput[]
  }

  export type TestUpdateManyWithoutThemeNestedInput = {
    create?: XOR<TestCreateWithoutThemeInput, TestUncheckedCreateWithoutThemeInput> | TestCreateWithoutThemeInput[] | TestUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: TestCreateOrConnectWithoutThemeInput | TestCreateOrConnectWithoutThemeInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutThemeInput | TestUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: TestCreateManyThemeInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutThemeInput | TestUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: TestUpdateManyWithWhereWithoutThemeInput | TestUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type EspaceDepotUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<EspaceDepotCreateWithoutThemeInput, EspaceDepotUncheckedCreateWithoutThemeInput> | EspaceDepotCreateWithoutThemeInput[] | EspaceDepotUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: EspaceDepotCreateOrConnectWithoutThemeInput | EspaceDepotCreateOrConnectWithoutThemeInput[]
    upsert?: EspaceDepotUpsertWithWhereUniqueWithoutThemeInput | EspaceDepotUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: EspaceDepotCreateManyThemeInputEnvelope
    set?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    disconnect?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    delete?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    connect?: EspaceDepotWhereUniqueInput | EspaceDepotWhereUniqueInput[]
    update?: EspaceDepotUpdateWithWhereUniqueWithoutThemeInput | EspaceDepotUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: EspaceDepotUpdateManyWithWhereWithoutThemeInput | EspaceDepotUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: EspaceDepotScalarWhereInput | EspaceDepotScalarWhereInput[]
  }

  export type RessourceUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<RessourceCreateWithoutThemeInput, RessourceUncheckedCreateWithoutThemeInput> | RessourceCreateWithoutThemeInput[] | RessourceUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: RessourceCreateOrConnectWithoutThemeInput | RessourceCreateOrConnectWithoutThemeInput[]
    upsert?: RessourceUpsertWithWhereUniqueWithoutThemeInput | RessourceUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: RessourceCreateManyThemeInputEnvelope
    set?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    disconnect?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    delete?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    connect?: RessourceWhereUniqueInput | RessourceWhereUniqueInput[]
    update?: RessourceUpdateWithWhereUniqueWithoutThemeInput | RessourceUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: RessourceUpdateManyWithWhereWithoutThemeInput | RessourceUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: RessourceScalarWhereInput | RessourceScalarWhereInput[]
  }

  export type TestUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<TestCreateWithoutThemeInput, TestUncheckedCreateWithoutThemeInput> | TestCreateWithoutThemeInput[] | TestUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: TestCreateOrConnectWithoutThemeInput | TestCreateOrConnectWithoutThemeInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutThemeInput | TestUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: TestCreateManyThemeInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutThemeInput | TestUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: TestUpdateManyWithWhereWithoutThemeInput | TestUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type ThemeCreateNestedOneWithoutEspaceDepotInput = {
    create?: XOR<ThemeCreateWithoutEspaceDepotInput, ThemeUncheckedCreateWithoutEspaceDepotInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutEspaceDepotInput
    connect?: ThemeWhereUniqueInput
  }

  export type DepotCreateNestedManyWithoutEspaceDepotInput = {
    create?: XOR<DepotCreateWithoutEspaceDepotInput, DepotUncheckedCreateWithoutEspaceDepotInput> | DepotCreateWithoutEspaceDepotInput[] | DepotUncheckedCreateWithoutEspaceDepotInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEspaceDepotInput | DepotCreateOrConnectWithoutEspaceDepotInput[]
    createMany?: DepotCreateManyEspaceDepotInputEnvelope
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
  }

  export type DepotUncheckedCreateNestedManyWithoutEspaceDepotInput = {
    create?: XOR<DepotCreateWithoutEspaceDepotInput, DepotUncheckedCreateWithoutEspaceDepotInput> | DepotCreateWithoutEspaceDepotInput[] | DepotUncheckedCreateWithoutEspaceDepotInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEspaceDepotInput | DepotCreateOrConnectWithoutEspaceDepotInput[]
    createMany?: DepotCreateManyEspaceDepotInputEnvelope
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
  }

  export type EnumTypeFileFieldUpdateOperationsInput = {
    set?: $Enums.TypeFile
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ThemeUpdateOneRequiredWithoutEspaceDepotNestedInput = {
    create?: XOR<ThemeCreateWithoutEspaceDepotInput, ThemeUncheckedCreateWithoutEspaceDepotInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutEspaceDepotInput
    upsert?: ThemeUpsertWithoutEspaceDepotInput
    connect?: ThemeWhereUniqueInput
    update?: XOR<XOR<ThemeUpdateToOneWithWhereWithoutEspaceDepotInput, ThemeUpdateWithoutEspaceDepotInput>, ThemeUncheckedUpdateWithoutEspaceDepotInput>
  }

  export type DepotUpdateManyWithoutEspaceDepotNestedInput = {
    create?: XOR<DepotCreateWithoutEspaceDepotInput, DepotUncheckedCreateWithoutEspaceDepotInput> | DepotCreateWithoutEspaceDepotInput[] | DepotUncheckedCreateWithoutEspaceDepotInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEspaceDepotInput | DepotCreateOrConnectWithoutEspaceDepotInput[]
    upsert?: DepotUpsertWithWhereUniqueWithoutEspaceDepotInput | DepotUpsertWithWhereUniqueWithoutEspaceDepotInput[]
    createMany?: DepotCreateManyEspaceDepotInputEnvelope
    set?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    disconnect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    delete?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    update?: DepotUpdateWithWhereUniqueWithoutEspaceDepotInput | DepotUpdateWithWhereUniqueWithoutEspaceDepotInput[]
    updateMany?: DepotUpdateManyWithWhereWithoutEspaceDepotInput | DepotUpdateManyWithWhereWithoutEspaceDepotInput[]
    deleteMany?: DepotScalarWhereInput | DepotScalarWhereInput[]
  }

  export type DepotUncheckedUpdateManyWithoutEspaceDepotNestedInput = {
    create?: XOR<DepotCreateWithoutEspaceDepotInput, DepotUncheckedCreateWithoutEspaceDepotInput> | DepotCreateWithoutEspaceDepotInput[] | DepotUncheckedCreateWithoutEspaceDepotInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEspaceDepotInput | DepotCreateOrConnectWithoutEspaceDepotInput[]
    upsert?: DepotUpsertWithWhereUniqueWithoutEspaceDepotInput | DepotUpsertWithWhereUniqueWithoutEspaceDepotInput[]
    createMany?: DepotCreateManyEspaceDepotInputEnvelope
    set?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    disconnect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    delete?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    update?: DepotUpdateWithWhereUniqueWithoutEspaceDepotInput | DepotUpdateWithWhereUniqueWithoutEspaceDepotInput[]
    updateMany?: DepotUpdateManyWithWhereWithoutEspaceDepotInput | DepotUpdateManyWithWhereWithoutEspaceDepotInput[]
    deleteMany?: DepotScalarWhereInput | DepotScalarWhereInput[]
  }

  export type ThemeCreateNestedOneWithoutRessourceInput = {
    create?: XOR<ThemeCreateWithoutRessourceInput, ThemeUncheckedCreateWithoutRessourceInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutRessourceInput
    connect?: ThemeWhereUniqueInput
  }

  export type CommentaireCreateNestedManyWithoutRessourceInput = {
    create?: XOR<CommentaireCreateWithoutRessourceInput, CommentaireUncheckedCreateWithoutRessourceInput> | CommentaireCreateWithoutRessourceInput[] | CommentaireUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutRessourceInput | CommentaireCreateOrConnectWithoutRessourceInput[]
    createMany?: CommentaireCreateManyRessourceInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type CommentaireUncheckedCreateNestedManyWithoutRessourceInput = {
    create?: XOR<CommentaireCreateWithoutRessourceInput, CommentaireUncheckedCreateWithoutRessourceInput> | CommentaireCreateWithoutRessourceInput[] | CommentaireUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutRessourceInput | CommentaireCreateOrConnectWithoutRessourceInput[]
    createMany?: CommentaireCreateManyRessourceInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type ThemeUpdateOneRequiredWithoutRessourceNestedInput = {
    create?: XOR<ThemeCreateWithoutRessourceInput, ThemeUncheckedCreateWithoutRessourceInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutRessourceInput
    upsert?: ThemeUpsertWithoutRessourceInput
    connect?: ThemeWhereUniqueInput
    update?: XOR<XOR<ThemeUpdateToOneWithWhereWithoutRessourceInput, ThemeUpdateWithoutRessourceInput>, ThemeUncheckedUpdateWithoutRessourceInput>
  }

  export type CommentaireUpdateManyWithoutRessourceNestedInput = {
    create?: XOR<CommentaireCreateWithoutRessourceInput, CommentaireUncheckedCreateWithoutRessourceInput> | CommentaireCreateWithoutRessourceInput[] | CommentaireUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutRessourceInput | CommentaireCreateOrConnectWithoutRessourceInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutRessourceInput | CommentaireUpsertWithWhereUniqueWithoutRessourceInput[]
    createMany?: CommentaireCreateManyRessourceInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutRessourceInput | CommentaireUpdateWithWhereUniqueWithoutRessourceInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutRessourceInput | CommentaireUpdateManyWithWhereWithoutRessourceInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type CommentaireUncheckedUpdateManyWithoutRessourceNestedInput = {
    create?: XOR<CommentaireCreateWithoutRessourceInput, CommentaireUncheckedCreateWithoutRessourceInput> | CommentaireCreateWithoutRessourceInput[] | CommentaireUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutRessourceInput | CommentaireCreateOrConnectWithoutRessourceInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutRessourceInput | CommentaireUpsertWithWhereUniqueWithoutRessourceInput[]
    createMany?: CommentaireCreateManyRessourceInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutRessourceInput | CommentaireUpdateWithWhereUniqueWithoutRessourceInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutRessourceInput | CommentaireUpdateManyWithWhereWithoutRessourceInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type ThemeCreateNestedOneWithoutTestInput = {
    create?: XOR<ThemeCreateWithoutTestInput, ThemeUncheckedCreateWithoutTestInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutTestInput
    connect?: ThemeWhereUniqueInput
  }

  export type ResultatCreateNestedManyWithoutTestInput = {
    create?: XOR<ResultatCreateWithoutTestInput, ResultatUncheckedCreateWithoutTestInput> | ResultatCreateWithoutTestInput[] | ResultatUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutTestInput | ResultatCreateOrConnectWithoutTestInput[]
    createMany?: ResultatCreateManyTestInputEnvelope
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
  }

  export type TestQuestionCreateNestedManyWithoutTestInput = {
    create?: XOR<TestQuestionCreateWithoutTestInput, TestQuestionUncheckedCreateWithoutTestInput> | TestQuestionCreateWithoutTestInput[] | TestQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutTestInput | TestQuestionCreateOrConnectWithoutTestInput[]
    createMany?: TestQuestionCreateManyTestInputEnvelope
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
  }

  export type ResultatUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<ResultatCreateWithoutTestInput, ResultatUncheckedCreateWithoutTestInput> | ResultatCreateWithoutTestInput[] | ResultatUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutTestInput | ResultatCreateOrConnectWithoutTestInput[]
    createMany?: ResultatCreateManyTestInputEnvelope
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
  }

  export type TestQuestionUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<TestQuestionCreateWithoutTestInput, TestQuestionUncheckedCreateWithoutTestInput> | TestQuestionCreateWithoutTestInput[] | TestQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutTestInput | TestQuestionCreateOrConnectWithoutTestInput[]
    createMany?: TestQuestionCreateManyTestInputEnvelope
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
  }

  export type ThemeUpdateOneRequiredWithoutTestNestedInput = {
    create?: XOR<ThemeCreateWithoutTestInput, ThemeUncheckedCreateWithoutTestInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutTestInput
    upsert?: ThemeUpsertWithoutTestInput
    connect?: ThemeWhereUniqueInput
    update?: XOR<XOR<ThemeUpdateToOneWithWhereWithoutTestInput, ThemeUpdateWithoutTestInput>, ThemeUncheckedUpdateWithoutTestInput>
  }

  export type ResultatUpdateManyWithoutTestNestedInput = {
    create?: XOR<ResultatCreateWithoutTestInput, ResultatUncheckedCreateWithoutTestInput> | ResultatCreateWithoutTestInput[] | ResultatUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutTestInput | ResultatCreateOrConnectWithoutTestInput[]
    upsert?: ResultatUpsertWithWhereUniqueWithoutTestInput | ResultatUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ResultatCreateManyTestInputEnvelope
    set?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    disconnect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    delete?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    update?: ResultatUpdateWithWhereUniqueWithoutTestInput | ResultatUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ResultatUpdateManyWithWhereWithoutTestInput | ResultatUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ResultatScalarWhereInput | ResultatScalarWhereInput[]
  }

  export type TestQuestionUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestQuestionCreateWithoutTestInput, TestQuestionUncheckedCreateWithoutTestInput> | TestQuestionCreateWithoutTestInput[] | TestQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutTestInput | TestQuestionCreateOrConnectWithoutTestInput[]
    upsert?: TestQuestionUpsertWithWhereUniqueWithoutTestInput | TestQuestionUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestQuestionCreateManyTestInputEnvelope
    set?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    disconnect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    delete?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    update?: TestQuestionUpdateWithWhereUniqueWithoutTestInput | TestQuestionUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestQuestionUpdateManyWithWhereWithoutTestInput | TestQuestionUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestQuestionScalarWhereInput | TestQuestionScalarWhereInput[]
  }

  export type ResultatUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<ResultatCreateWithoutTestInput, ResultatUncheckedCreateWithoutTestInput> | ResultatCreateWithoutTestInput[] | ResultatUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutTestInput | ResultatCreateOrConnectWithoutTestInput[]
    upsert?: ResultatUpsertWithWhereUniqueWithoutTestInput | ResultatUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ResultatCreateManyTestInputEnvelope
    set?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    disconnect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    delete?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    update?: ResultatUpdateWithWhereUniqueWithoutTestInput | ResultatUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ResultatUpdateManyWithWhereWithoutTestInput | ResultatUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ResultatScalarWhereInput | ResultatScalarWhereInput[]
  }

  export type TestQuestionUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestQuestionCreateWithoutTestInput, TestQuestionUncheckedCreateWithoutTestInput> | TestQuestionCreateWithoutTestInput[] | TestQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutTestInput | TestQuestionCreateOrConnectWithoutTestInput[]
    upsert?: TestQuestionUpsertWithWhereUniqueWithoutTestInput | TestQuestionUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestQuestionCreateManyTestInputEnvelope
    set?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    disconnect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    delete?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    update?: TestQuestionUpdateWithWhereUniqueWithoutTestInput | TestQuestionUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestQuestionUpdateManyWithWhereWithoutTestInput | TestQuestionUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestQuestionScalarWhereInput | TestQuestionScalarWhereInput[]
  }

  export type EspaceCoursCreateNestedOneWithoutBanqueQuestionInput = {
    create?: XOR<EspaceCoursCreateWithoutBanqueQuestionInput, EspaceCoursUncheckedCreateWithoutBanqueQuestionInput>
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutBanqueQuestionInput
    connect?: EspaceCoursWhereUniqueInput
  }

  export type ReponseCreateNestedManyWithoutBanqueQuestionInput = {
    create?: XOR<ReponseCreateWithoutBanqueQuestionInput, ReponseUncheckedCreateWithoutBanqueQuestionInput> | ReponseCreateWithoutBanqueQuestionInput[] | ReponseUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: ReponseCreateOrConnectWithoutBanqueQuestionInput | ReponseCreateOrConnectWithoutBanqueQuestionInput[]
    createMany?: ReponseCreateManyBanqueQuestionInputEnvelope
    connect?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
  }

  export type TestQuestionCreateNestedManyWithoutBanqueQuestionInput = {
    create?: XOR<TestQuestionCreateWithoutBanqueQuestionInput, TestQuestionUncheckedCreateWithoutBanqueQuestionInput> | TestQuestionCreateWithoutBanqueQuestionInput[] | TestQuestionUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutBanqueQuestionInput | TestQuestionCreateOrConnectWithoutBanqueQuestionInput[]
    createMany?: TestQuestionCreateManyBanqueQuestionInputEnvelope
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
  }

  export type ReponseUncheckedCreateNestedManyWithoutBanqueQuestionInput = {
    create?: XOR<ReponseCreateWithoutBanqueQuestionInput, ReponseUncheckedCreateWithoutBanqueQuestionInput> | ReponseCreateWithoutBanqueQuestionInput[] | ReponseUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: ReponseCreateOrConnectWithoutBanqueQuestionInput | ReponseCreateOrConnectWithoutBanqueQuestionInput[]
    createMany?: ReponseCreateManyBanqueQuestionInputEnvelope
    connect?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
  }

  export type TestQuestionUncheckedCreateNestedManyWithoutBanqueQuestionInput = {
    create?: XOR<TestQuestionCreateWithoutBanqueQuestionInput, TestQuestionUncheckedCreateWithoutBanqueQuestionInput> | TestQuestionCreateWithoutBanqueQuestionInput[] | TestQuestionUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutBanqueQuestionInput | TestQuestionCreateOrConnectWithoutBanqueQuestionInput[]
    createMany?: TestQuestionCreateManyBanqueQuestionInputEnvelope
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
  }

  export type EspaceCoursUpdateOneRequiredWithoutBanqueQuestionNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutBanqueQuestionInput, EspaceCoursUncheckedCreateWithoutBanqueQuestionInput>
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutBanqueQuestionInput
    upsert?: EspaceCoursUpsertWithoutBanqueQuestionInput
    connect?: EspaceCoursWhereUniqueInput
    update?: XOR<XOR<EspaceCoursUpdateToOneWithWhereWithoutBanqueQuestionInput, EspaceCoursUpdateWithoutBanqueQuestionInput>, EspaceCoursUncheckedUpdateWithoutBanqueQuestionInput>
  }

  export type ReponseUpdateManyWithoutBanqueQuestionNestedInput = {
    create?: XOR<ReponseCreateWithoutBanqueQuestionInput, ReponseUncheckedCreateWithoutBanqueQuestionInput> | ReponseCreateWithoutBanqueQuestionInput[] | ReponseUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: ReponseCreateOrConnectWithoutBanqueQuestionInput | ReponseCreateOrConnectWithoutBanqueQuestionInput[]
    upsert?: ReponseUpsertWithWhereUniqueWithoutBanqueQuestionInput | ReponseUpsertWithWhereUniqueWithoutBanqueQuestionInput[]
    createMany?: ReponseCreateManyBanqueQuestionInputEnvelope
    set?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    disconnect?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    delete?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    connect?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    update?: ReponseUpdateWithWhereUniqueWithoutBanqueQuestionInput | ReponseUpdateWithWhereUniqueWithoutBanqueQuestionInput[]
    updateMany?: ReponseUpdateManyWithWhereWithoutBanqueQuestionInput | ReponseUpdateManyWithWhereWithoutBanqueQuestionInput[]
    deleteMany?: ReponseScalarWhereInput | ReponseScalarWhereInput[]
  }

  export type TestQuestionUpdateManyWithoutBanqueQuestionNestedInput = {
    create?: XOR<TestQuestionCreateWithoutBanqueQuestionInput, TestQuestionUncheckedCreateWithoutBanqueQuestionInput> | TestQuestionCreateWithoutBanqueQuestionInput[] | TestQuestionUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutBanqueQuestionInput | TestQuestionCreateOrConnectWithoutBanqueQuestionInput[]
    upsert?: TestQuestionUpsertWithWhereUniqueWithoutBanqueQuestionInput | TestQuestionUpsertWithWhereUniqueWithoutBanqueQuestionInput[]
    createMany?: TestQuestionCreateManyBanqueQuestionInputEnvelope
    set?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    disconnect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    delete?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    update?: TestQuestionUpdateWithWhereUniqueWithoutBanqueQuestionInput | TestQuestionUpdateWithWhereUniqueWithoutBanqueQuestionInput[]
    updateMany?: TestQuestionUpdateManyWithWhereWithoutBanqueQuestionInput | TestQuestionUpdateManyWithWhereWithoutBanqueQuestionInput[]
    deleteMany?: TestQuestionScalarWhereInput | TestQuestionScalarWhereInput[]
  }

  export type ReponseUncheckedUpdateManyWithoutBanqueQuestionNestedInput = {
    create?: XOR<ReponseCreateWithoutBanqueQuestionInput, ReponseUncheckedCreateWithoutBanqueQuestionInput> | ReponseCreateWithoutBanqueQuestionInput[] | ReponseUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: ReponseCreateOrConnectWithoutBanqueQuestionInput | ReponseCreateOrConnectWithoutBanqueQuestionInput[]
    upsert?: ReponseUpsertWithWhereUniqueWithoutBanqueQuestionInput | ReponseUpsertWithWhereUniqueWithoutBanqueQuestionInput[]
    createMany?: ReponseCreateManyBanqueQuestionInputEnvelope
    set?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    disconnect?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    delete?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    connect?: ReponseWhereUniqueInput | ReponseWhereUniqueInput[]
    update?: ReponseUpdateWithWhereUniqueWithoutBanqueQuestionInput | ReponseUpdateWithWhereUniqueWithoutBanqueQuestionInput[]
    updateMany?: ReponseUpdateManyWithWhereWithoutBanqueQuestionInput | ReponseUpdateManyWithWhereWithoutBanqueQuestionInput[]
    deleteMany?: ReponseScalarWhereInput | ReponseScalarWhereInput[]
  }

  export type TestQuestionUncheckedUpdateManyWithoutBanqueQuestionNestedInput = {
    create?: XOR<TestQuestionCreateWithoutBanqueQuestionInput, TestQuestionUncheckedCreateWithoutBanqueQuestionInput> | TestQuestionCreateWithoutBanqueQuestionInput[] | TestQuestionUncheckedCreateWithoutBanqueQuestionInput[]
    connectOrCreate?: TestQuestionCreateOrConnectWithoutBanqueQuestionInput | TestQuestionCreateOrConnectWithoutBanqueQuestionInput[]
    upsert?: TestQuestionUpsertWithWhereUniqueWithoutBanqueQuestionInput | TestQuestionUpsertWithWhereUniqueWithoutBanqueQuestionInput[]
    createMany?: TestQuestionCreateManyBanqueQuestionInputEnvelope
    set?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    disconnect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    delete?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    connect?: TestQuestionWhereUniqueInput | TestQuestionWhereUniqueInput[]
    update?: TestQuestionUpdateWithWhereUniqueWithoutBanqueQuestionInput | TestQuestionUpdateWithWhereUniqueWithoutBanqueQuestionInput[]
    updateMany?: TestQuestionUpdateManyWithWhereWithoutBanqueQuestionInput | TestQuestionUpdateManyWithWhereWithoutBanqueQuestionInput[]
    deleteMany?: TestQuestionScalarWhereInput | TestQuestionScalarWhereInput[]
  }

  export type BanqueQuestionCreateNestedOneWithoutReponseInput = {
    create?: XOR<BanqueQuestionCreateWithoutReponseInput, BanqueQuestionUncheckedCreateWithoutReponseInput>
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutReponseInput
    connect?: BanqueQuestionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BanqueQuestionUpdateOneRequiredWithoutReponseNestedInput = {
    create?: XOR<BanqueQuestionCreateWithoutReponseInput, BanqueQuestionUncheckedCreateWithoutReponseInput>
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutReponseInput
    upsert?: BanqueQuestionUpsertWithoutReponseInput
    connect?: BanqueQuestionWhereUniqueInput
    update?: XOR<XOR<BanqueQuestionUpdateToOneWithWhereWithoutReponseInput, BanqueQuestionUpdateWithoutReponseInput>, BanqueQuestionUncheckedUpdateWithoutReponseInput>
  }

  export type RessourceCreateNestedOneWithoutCommentaireInput = {
    create?: XOR<RessourceCreateWithoutCommentaireInput, RessourceUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: RessourceCreateOrConnectWithoutCommentaireInput
    connect?: RessourceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentaireInput = {
    create?: XOR<UserCreateWithoutCommentaireInput, UserUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentaireInput
    connect?: UserWhereUniqueInput
  }

  export type RessourceUpdateOneRequiredWithoutCommentaireNestedInput = {
    create?: XOR<RessourceCreateWithoutCommentaireInput, RessourceUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: RessourceCreateOrConnectWithoutCommentaireInput
    upsert?: RessourceUpsertWithoutCommentaireInput
    connect?: RessourceWhereUniqueInput
    update?: XOR<XOR<RessourceUpdateToOneWithWhereWithoutCommentaireInput, RessourceUpdateWithoutCommentaireInput>, RessourceUncheckedUpdateWithoutCommentaireInput>
  }

  export type UserUpdateOneRequiredWithoutCommentaireNestedInput = {
    create?: XOR<UserCreateWithoutCommentaireInput, UserUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentaireInput
    upsert?: UserUpsertWithoutCommentaireInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentaireInput, UserUpdateWithoutCommentaireInput>, UserUncheckedUpdateWithoutCommentaireInput>
  }

  export type EtudiantCreateNestedOneWithoutUserInput = {
    create?: XOR<EtudiantCreateWithoutUserInput, EtudiantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutUserInput
    connect?: EtudiantWhereUniqueInput
  }

  export type EnseingantCreateNestedOneWithoutUserInput = {
    create?: XOR<EnseingantCreateWithoutUserInput, EnseingantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EnseingantCreateOrConnectWithoutUserInput
    connect?: EnseingantWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type CommentaireCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput> | CommentaireCreateWithoutUserInput[] | CommentaireUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutUserInput | CommentaireCreateOrConnectWithoutUserInput[]
    createMany?: CommentaireCreateManyUserInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type EtudiantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EtudiantCreateWithoutUserInput, EtudiantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutUserInput
    connect?: EtudiantWhereUniqueInput
  }

  export type EnseingantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EnseingantCreateWithoutUserInput, EnseingantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EnseingantCreateOrConnectWithoutUserInput
    connect?: EnseingantWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type CommentaireUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput> | CommentaireCreateWithoutUserInput[] | CommentaireUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutUserInput | CommentaireCreateOrConnectWithoutUserInput[]
    createMany?: CommentaireCreateManyUserInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type EnumRoleUserFieldUpdateOperationsInput = {
    set?: $Enums.RoleUser
  }

  export type EtudiantUpdateOneWithoutUserNestedInput = {
    create?: XOR<EtudiantCreateWithoutUserInput, EtudiantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutUserInput
    upsert?: EtudiantUpsertWithoutUserInput
    disconnect?: EtudiantWhereInput | boolean
    delete?: EtudiantWhereInput | boolean
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutUserInput, EtudiantUpdateWithoutUserInput>, EtudiantUncheckedUpdateWithoutUserInput>
  }

  export type EnseingantUpdateOneWithoutUserNestedInput = {
    create?: XOR<EnseingantCreateWithoutUserInput, EnseingantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EnseingantCreateOrConnectWithoutUserInput
    upsert?: EnseingantUpsertWithoutUserInput
    disconnect?: EnseingantWhereInput | boolean
    delete?: EnseingantWhereInput | boolean
    connect?: EnseingantWhereUniqueInput
    update?: XOR<XOR<EnseingantUpdateToOneWithWhereWithoutUserInput, EnseingantUpdateWithoutUserInput>, EnseingantUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type CommentaireUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput> | CommentaireCreateWithoutUserInput[] | CommentaireUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutUserInput | CommentaireCreateOrConnectWithoutUserInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutUserInput | CommentaireUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentaireCreateManyUserInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutUserInput | CommentaireUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutUserInput | CommentaireUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type EtudiantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EtudiantCreateWithoutUserInput, EtudiantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutUserInput
    upsert?: EtudiantUpsertWithoutUserInput
    disconnect?: EtudiantWhereInput | boolean
    delete?: EtudiantWhereInput | boolean
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutUserInput, EtudiantUpdateWithoutUserInput>, EtudiantUncheckedUpdateWithoutUserInput>
  }

  export type EnseingantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EnseingantCreateWithoutUserInput, EnseingantUncheckedCreateWithoutUserInput>
    connectOrCreate?: EnseingantCreateOrConnectWithoutUserInput
    upsert?: EnseingantUpsertWithoutUserInput
    disconnect?: EnseingantWhereInput | boolean
    delete?: EnseingantWhereInput | boolean
    connect?: EnseingantWhereUniqueInput
    update?: XOR<XOR<EnseingantUpdateToOneWithWhereWithoutUserInput, EnseingantUpdateWithoutUserInput>, EnseingantUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type CommentaireUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput> | CommentaireCreateWithoutUserInput[] | CommentaireUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutUserInput | CommentaireCreateOrConnectWithoutUserInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutUserInput | CommentaireUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentaireCreateManyUserInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutUserInput | CommentaireUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutUserInput | CommentaireUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEtudiantInput = {
    create?: XOR<UserCreateWithoutEtudiantInput, UserUncheckedCreateWithoutEtudiantInput>
    connectOrCreate?: UserCreateOrConnectWithoutEtudiantInput
    connect?: UserWhereUniqueInput
  }

  export type GamificationCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<GamificationCreateWithoutEtudiantInput, GamificationUncheckedCreateWithoutEtudiantInput> | GamificationCreateWithoutEtudiantInput[] | GamificationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEtudiantInput | GamificationCreateOrConnectWithoutEtudiantInput[]
    createMany?: GamificationCreateManyEtudiantInputEnvelope
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
  }

  export type ResultatCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<ResultatCreateWithoutEtudiantInput, ResultatUncheckedCreateWithoutEtudiantInput> | ResultatCreateWithoutEtudiantInput[] | ResultatUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutEtudiantInput | ResultatCreateOrConnectWithoutEtudiantInput[]
    createMany?: ResultatCreateManyEtudiantInputEnvelope
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
  }

  export type DepotCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<DepotCreateWithoutEtudiantInput, DepotUncheckedCreateWithoutEtudiantInput> | DepotCreateWithoutEtudiantInput[] | DepotUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEtudiantInput | DepotCreateOrConnectWithoutEtudiantInput[]
    createMany?: DepotCreateManyEtudiantInputEnvelope
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
  }

  export type GamificationUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<GamificationCreateWithoutEtudiantInput, GamificationUncheckedCreateWithoutEtudiantInput> | GamificationCreateWithoutEtudiantInput[] | GamificationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEtudiantInput | GamificationCreateOrConnectWithoutEtudiantInput[]
    createMany?: GamificationCreateManyEtudiantInputEnvelope
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
  }

  export type ResultatUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<ResultatCreateWithoutEtudiantInput, ResultatUncheckedCreateWithoutEtudiantInput> | ResultatCreateWithoutEtudiantInput[] | ResultatUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutEtudiantInput | ResultatCreateOrConnectWithoutEtudiantInput[]
    createMany?: ResultatCreateManyEtudiantInputEnvelope
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
  }

  export type DepotUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<DepotCreateWithoutEtudiantInput, DepotUncheckedCreateWithoutEtudiantInput> | DepotCreateWithoutEtudiantInput[] | DepotUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEtudiantInput | DepotCreateOrConnectWithoutEtudiantInput[]
    createMany?: DepotCreateManyEtudiantInputEnvelope
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEtudiantNestedInput = {
    create?: XOR<UserCreateWithoutEtudiantInput, UserUncheckedCreateWithoutEtudiantInput>
    connectOrCreate?: UserCreateOrConnectWithoutEtudiantInput
    upsert?: UserUpsertWithoutEtudiantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEtudiantInput, UserUpdateWithoutEtudiantInput>, UserUncheckedUpdateWithoutEtudiantInput>
  }

  export type GamificationUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<GamificationCreateWithoutEtudiantInput, GamificationUncheckedCreateWithoutEtudiantInput> | GamificationCreateWithoutEtudiantInput[] | GamificationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEtudiantInput | GamificationCreateOrConnectWithoutEtudiantInput[]
    upsert?: GamificationUpsertWithWhereUniqueWithoutEtudiantInput | GamificationUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: GamificationCreateManyEtudiantInputEnvelope
    set?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    disconnect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    delete?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    update?: GamificationUpdateWithWhereUniqueWithoutEtudiantInput | GamificationUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: GamificationUpdateManyWithWhereWithoutEtudiantInput | GamificationUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: GamificationScalarWhereInput | GamificationScalarWhereInput[]
  }

  export type ResultatUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<ResultatCreateWithoutEtudiantInput, ResultatUncheckedCreateWithoutEtudiantInput> | ResultatCreateWithoutEtudiantInput[] | ResultatUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutEtudiantInput | ResultatCreateOrConnectWithoutEtudiantInput[]
    upsert?: ResultatUpsertWithWhereUniqueWithoutEtudiantInput | ResultatUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: ResultatCreateManyEtudiantInputEnvelope
    set?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    disconnect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    delete?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    update?: ResultatUpdateWithWhereUniqueWithoutEtudiantInput | ResultatUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: ResultatUpdateManyWithWhereWithoutEtudiantInput | ResultatUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: ResultatScalarWhereInput | ResultatScalarWhereInput[]
  }

  export type DepotUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<DepotCreateWithoutEtudiantInput, DepotUncheckedCreateWithoutEtudiantInput> | DepotCreateWithoutEtudiantInput[] | DepotUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEtudiantInput | DepotCreateOrConnectWithoutEtudiantInput[]
    upsert?: DepotUpsertWithWhereUniqueWithoutEtudiantInput | DepotUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: DepotCreateManyEtudiantInputEnvelope
    set?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    disconnect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    delete?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    update?: DepotUpdateWithWhereUniqueWithoutEtudiantInput | DepotUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: DepotUpdateManyWithWhereWithoutEtudiantInput | DepotUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: DepotScalarWhereInput | DepotScalarWhereInput[]
  }

  export type GamificationUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<GamificationCreateWithoutEtudiantInput, GamificationUncheckedCreateWithoutEtudiantInput> | GamificationCreateWithoutEtudiantInput[] | GamificationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: GamificationCreateOrConnectWithoutEtudiantInput | GamificationCreateOrConnectWithoutEtudiantInput[]
    upsert?: GamificationUpsertWithWhereUniqueWithoutEtudiantInput | GamificationUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: GamificationCreateManyEtudiantInputEnvelope
    set?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    disconnect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    delete?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    connect?: GamificationWhereUniqueInput | GamificationWhereUniqueInput[]
    update?: GamificationUpdateWithWhereUniqueWithoutEtudiantInput | GamificationUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: GamificationUpdateManyWithWhereWithoutEtudiantInput | GamificationUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: GamificationScalarWhereInput | GamificationScalarWhereInput[]
  }

  export type ResultatUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<ResultatCreateWithoutEtudiantInput, ResultatUncheckedCreateWithoutEtudiantInput> | ResultatCreateWithoutEtudiantInput[] | ResultatUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: ResultatCreateOrConnectWithoutEtudiantInput | ResultatCreateOrConnectWithoutEtudiantInput[]
    upsert?: ResultatUpsertWithWhereUniqueWithoutEtudiantInput | ResultatUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: ResultatCreateManyEtudiantInputEnvelope
    set?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    disconnect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    delete?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    connect?: ResultatWhereUniqueInput | ResultatWhereUniqueInput[]
    update?: ResultatUpdateWithWhereUniqueWithoutEtudiantInput | ResultatUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: ResultatUpdateManyWithWhereWithoutEtudiantInput | ResultatUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: ResultatScalarWhereInput | ResultatScalarWhereInput[]
  }

  export type DepotUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<DepotCreateWithoutEtudiantInput, DepotUncheckedCreateWithoutEtudiantInput> | DepotCreateWithoutEtudiantInput[] | DepotUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: DepotCreateOrConnectWithoutEtudiantInput | DepotCreateOrConnectWithoutEtudiantInput[]
    upsert?: DepotUpsertWithWhereUniqueWithoutEtudiantInput | DepotUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: DepotCreateManyEtudiantInputEnvelope
    set?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    disconnect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    delete?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    connect?: DepotWhereUniqueInput | DepotWhereUniqueInput[]
    update?: DepotUpdateWithWhereUniqueWithoutEtudiantInput | DepotUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: DepotUpdateManyWithWhereWithoutEtudiantInput | DepotUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: DepotScalarWhereInput | DepotScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEnseingantInput = {
    create?: XOR<UserCreateWithoutEnseingantInput, UserUncheckedCreateWithoutEnseingantInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnseingantInput
    connect?: UserWhereUniqueInput
  }

  export type EspaceCoursCreateNestedManyWithoutEnseingantInput = {
    create?: XOR<EspaceCoursCreateWithoutEnseingantInput, EspaceCoursUncheckedCreateWithoutEnseingantInput> | EspaceCoursCreateWithoutEnseingantInput[] | EspaceCoursUncheckedCreateWithoutEnseingantInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutEnseingantInput | EspaceCoursCreateOrConnectWithoutEnseingantInput[]
    createMany?: EspaceCoursCreateManyEnseingantInputEnvelope
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
  }

  export type EspaceCoursUncheckedCreateNestedManyWithoutEnseingantInput = {
    create?: XOR<EspaceCoursCreateWithoutEnseingantInput, EspaceCoursUncheckedCreateWithoutEnseingantInput> | EspaceCoursCreateWithoutEnseingantInput[] | EspaceCoursUncheckedCreateWithoutEnseingantInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutEnseingantInput | EspaceCoursCreateOrConnectWithoutEnseingantInput[]
    createMany?: EspaceCoursCreateManyEnseingantInputEnvelope
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEnseingantNestedInput = {
    create?: XOR<UserCreateWithoutEnseingantInput, UserUncheckedCreateWithoutEnseingantInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnseingantInput
    upsert?: UserUpsertWithoutEnseingantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnseingantInput, UserUpdateWithoutEnseingantInput>, UserUncheckedUpdateWithoutEnseingantInput>
  }

  export type EspaceCoursUpdateManyWithoutEnseingantNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutEnseingantInput, EspaceCoursUncheckedCreateWithoutEnseingantInput> | EspaceCoursCreateWithoutEnseingantInput[] | EspaceCoursUncheckedCreateWithoutEnseingantInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutEnseingantInput | EspaceCoursCreateOrConnectWithoutEnseingantInput[]
    upsert?: EspaceCoursUpsertWithWhereUniqueWithoutEnseingantInput | EspaceCoursUpsertWithWhereUniqueWithoutEnseingantInput[]
    createMany?: EspaceCoursCreateManyEnseingantInputEnvelope
    set?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    disconnect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    delete?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    update?: EspaceCoursUpdateWithWhereUniqueWithoutEnseingantInput | EspaceCoursUpdateWithWhereUniqueWithoutEnseingantInput[]
    updateMany?: EspaceCoursUpdateManyWithWhereWithoutEnseingantInput | EspaceCoursUpdateManyWithWhereWithoutEnseingantInput[]
    deleteMany?: EspaceCoursScalarWhereInput | EspaceCoursScalarWhereInput[]
  }

  export type EspaceCoursUncheckedUpdateManyWithoutEnseingantNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutEnseingantInput, EspaceCoursUncheckedCreateWithoutEnseingantInput> | EspaceCoursCreateWithoutEnseingantInput[] | EspaceCoursUncheckedCreateWithoutEnseingantInput[]
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutEnseingantInput | EspaceCoursCreateOrConnectWithoutEnseingantInput[]
    upsert?: EspaceCoursUpsertWithWhereUniqueWithoutEnseingantInput | EspaceCoursUpsertWithWhereUniqueWithoutEnseingantInput[]
    createMany?: EspaceCoursCreateManyEnseingantInputEnvelope
    set?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    disconnect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    delete?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    connect?: EspaceCoursWhereUniqueInput | EspaceCoursWhereUniqueInput[]
    update?: EspaceCoursUpdateWithWhereUniqueWithoutEnseingantInput | EspaceCoursUpdateWithWhereUniqueWithoutEnseingantInput[]
    updateMany?: EspaceCoursUpdateManyWithWhereWithoutEnseingantInput | EspaceCoursUpdateManyWithWhereWithoutEnseingantInput[]
    deleteMany?: EspaceCoursScalarWhereInput | EspaceCoursScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type EtudiantCreateNestedOneWithoutGamificationInput = {
    create?: XOR<EtudiantCreateWithoutGamificationInput, EtudiantUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutGamificationInput
    connect?: EtudiantWhereUniqueInput
  }

  export type EspaceCoursCreateNestedOneWithoutGamificationInput = {
    create?: XOR<EspaceCoursCreateWithoutGamificationInput, EspaceCoursUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutGamificationInput
    connect?: EspaceCoursWhereUniqueInput
  }

  export type EtudiantUpdateOneRequiredWithoutGamificationNestedInput = {
    create?: XOR<EtudiantCreateWithoutGamificationInput, EtudiantUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutGamificationInput
    upsert?: EtudiantUpsertWithoutGamificationInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutGamificationInput, EtudiantUpdateWithoutGamificationInput>, EtudiantUncheckedUpdateWithoutGamificationInput>
  }

  export type EspaceCoursUpdateOneRequiredWithoutGamificationNestedInput = {
    create?: XOR<EspaceCoursCreateWithoutGamificationInput, EspaceCoursUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: EspaceCoursCreateOrConnectWithoutGamificationInput
    upsert?: EspaceCoursUpsertWithoutGamificationInput
    connect?: EspaceCoursWhereUniqueInput
    update?: XOR<XOR<EspaceCoursUpdateToOneWithWhereWithoutGamificationInput, EspaceCoursUpdateWithoutGamificationInput>, EspaceCoursUncheckedUpdateWithoutGamificationInput>
  }

  export type EtudiantCreateNestedOneWithoutResultatInput = {
    create?: XOR<EtudiantCreateWithoutResultatInput, EtudiantUncheckedCreateWithoutResultatInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutResultatInput
    connect?: EtudiantWhereUniqueInput
  }

  export type TestCreateNestedOneWithoutResultatInput = {
    create?: XOR<TestCreateWithoutResultatInput, TestUncheckedCreateWithoutResultatInput>
    connectOrCreate?: TestCreateOrConnectWithoutResultatInput
    connect?: TestWhereUniqueInput
  }

  export type EtudiantUpdateOneRequiredWithoutResultatNestedInput = {
    create?: XOR<EtudiantCreateWithoutResultatInput, EtudiantUncheckedCreateWithoutResultatInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutResultatInput
    upsert?: EtudiantUpsertWithoutResultatInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutResultatInput, EtudiantUpdateWithoutResultatInput>, EtudiantUncheckedUpdateWithoutResultatInput>
  }

  export type TestUpdateOneRequiredWithoutResultatNestedInput = {
    create?: XOR<TestCreateWithoutResultatInput, TestUncheckedCreateWithoutResultatInput>
    connectOrCreate?: TestCreateOrConnectWithoutResultatInput
    upsert?: TestUpsertWithoutResultatInput
    connect?: TestWhereUniqueInput
    update?: XOR<XOR<TestUpdateToOneWithWhereWithoutResultatInput, TestUpdateWithoutResultatInput>, TestUncheckedUpdateWithoutResultatInput>
  }

  export type BanqueQuestionCreateNestedOneWithoutTestQuestionInput = {
    create?: XOR<BanqueQuestionCreateWithoutTestQuestionInput, BanqueQuestionUncheckedCreateWithoutTestQuestionInput>
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutTestQuestionInput
    connect?: BanqueQuestionWhereUniqueInput
  }

  export type TestCreateNestedOneWithoutTestQuestionInput = {
    create?: XOR<TestCreateWithoutTestQuestionInput, TestUncheckedCreateWithoutTestQuestionInput>
    connectOrCreate?: TestCreateOrConnectWithoutTestQuestionInput
    connect?: TestWhereUniqueInput
  }

  export type BanqueQuestionUpdateOneRequiredWithoutTestQuestionNestedInput = {
    create?: XOR<BanqueQuestionCreateWithoutTestQuestionInput, BanqueQuestionUncheckedCreateWithoutTestQuestionInput>
    connectOrCreate?: BanqueQuestionCreateOrConnectWithoutTestQuestionInput
    upsert?: BanqueQuestionUpsertWithoutTestQuestionInput
    connect?: BanqueQuestionWhereUniqueInput
    update?: XOR<XOR<BanqueQuestionUpdateToOneWithWhereWithoutTestQuestionInput, BanqueQuestionUpdateWithoutTestQuestionInput>, BanqueQuestionUncheckedUpdateWithoutTestQuestionInput>
  }

  export type TestUpdateOneRequiredWithoutTestQuestionNestedInput = {
    create?: XOR<TestCreateWithoutTestQuestionInput, TestUncheckedCreateWithoutTestQuestionInput>
    connectOrCreate?: TestCreateOrConnectWithoutTestQuestionInput
    upsert?: TestUpsertWithoutTestQuestionInput
    connect?: TestWhereUniqueInput
    update?: XOR<XOR<TestUpdateToOneWithWhereWithoutTestQuestionInput, TestUpdateWithoutTestQuestionInput>, TestUncheckedUpdateWithoutTestQuestionInput>
  }

  export type EtudiantCreateNestedOneWithoutDepotInput = {
    create?: XOR<EtudiantCreateWithoutDepotInput, EtudiantUncheckedCreateWithoutDepotInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutDepotInput
    connect?: EtudiantWhereUniqueInput
  }

  export type EspaceDepotCreateNestedOneWithoutDepotInput = {
    create?: XOR<EspaceDepotCreateWithoutDepotInput, EspaceDepotUncheckedCreateWithoutDepotInput>
    connectOrCreate?: EspaceDepotCreateOrConnectWithoutDepotInput
    connect?: EspaceDepotWhereUniqueInput
  }

  export type EtudiantUpdateOneRequiredWithoutDepotNestedInput = {
    create?: XOR<EtudiantCreateWithoutDepotInput, EtudiantUncheckedCreateWithoutDepotInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutDepotInput
    upsert?: EtudiantUpsertWithoutDepotInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutDepotInput, EtudiantUpdateWithoutDepotInput>, EtudiantUncheckedUpdateWithoutDepotInput>
  }

  export type EspaceDepotUpdateOneRequiredWithoutDepotNestedInput = {
    create?: XOR<EspaceDepotCreateWithoutDepotInput, EspaceDepotUncheckedCreateWithoutDepotInput>
    connectOrCreate?: EspaceDepotCreateOrConnectWithoutDepotInput
    upsert?: EspaceDepotUpsertWithoutDepotInput
    connect?: EspaceDepotWhereUniqueInput
    update?: XOR<XOR<EspaceDepotUpdateToOneWithWhereWithoutDepotInput, EspaceDepotUpdateWithoutDepotInput>, EspaceDepotUncheckedUpdateWithoutDepotInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumTypeFileFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeFile | EnumTypeFileFieldRefInput<$PrismaModel>
    in?: $Enums.TypeFile[]
    notIn?: $Enums.TypeFile[]
    not?: NestedEnumTypeFileFilter<$PrismaModel> | $Enums.TypeFile
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumTypeFileWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeFile | EnumTypeFileFieldRefInput<$PrismaModel>
    in?: $Enums.TypeFile[]
    notIn?: $Enums.TypeFile[]
    not?: NestedEnumTypeFileWithAggregatesFilter<$PrismaModel> | $Enums.TypeFile
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeFileFilter<$PrismaModel>
    _max?: NestedEnumTypeFileFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleUserFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleUser | EnumRoleUserFieldRefInput<$PrismaModel>
    in?: $Enums.RoleUser[]
    notIn?: $Enums.RoleUser[]
    not?: NestedEnumRoleUserFilter<$PrismaModel> | $Enums.RoleUser
  }

  export type NestedEnumRoleUserWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleUser | EnumRoleUserFieldRefInput<$PrismaModel>
    in?: $Enums.RoleUser[]
    notIn?: $Enums.RoleUser[]
    not?: NestedEnumRoleUserWithAggregatesFilter<$PrismaModel> | $Enums.RoleUser
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleUserFilter<$PrismaModel>
    _max?: NestedEnumRoleUserFilter<$PrismaModel>
  }

  export type NiveauCreateWithoutSpecialiteInput = {
    num: number
    EspaceCours?: EspaceCoursCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUncheckedCreateWithoutSpecialiteInput = {
    id?: number
    num: number
    EspaceCours?: EspaceCoursUncheckedCreateNestedManyWithoutNiveauInput
  }

  export type NiveauCreateOrConnectWithoutSpecialiteInput = {
    where: NiveauWhereUniqueInput
    create: XOR<NiveauCreateWithoutSpecialiteInput, NiveauUncheckedCreateWithoutSpecialiteInput>
  }

  export type NiveauCreateManySpecialiteInputEnvelope = {
    data: NiveauCreateManySpecialiteInput | NiveauCreateManySpecialiteInput[]
    skipDuplicates?: boolean
  }

  export type NiveauUpsertWithWhereUniqueWithoutSpecialiteInput = {
    where: NiveauWhereUniqueInput
    update: XOR<NiveauUpdateWithoutSpecialiteInput, NiveauUncheckedUpdateWithoutSpecialiteInput>
    create: XOR<NiveauCreateWithoutSpecialiteInput, NiveauUncheckedCreateWithoutSpecialiteInput>
  }

  export type NiveauUpdateWithWhereUniqueWithoutSpecialiteInput = {
    where: NiveauWhereUniqueInput
    data: XOR<NiveauUpdateWithoutSpecialiteInput, NiveauUncheckedUpdateWithoutSpecialiteInput>
  }

  export type NiveauUpdateManyWithWhereWithoutSpecialiteInput = {
    where: NiveauScalarWhereInput
    data: XOR<NiveauUpdateManyMutationInput, NiveauUncheckedUpdateManyWithoutSpecialiteInput>
  }

  export type NiveauScalarWhereInput = {
    AND?: NiveauScalarWhereInput | NiveauScalarWhereInput[]
    OR?: NiveauScalarWhereInput[]
    NOT?: NiveauScalarWhereInput | NiveauScalarWhereInput[]
    id?: IntFilter<"Niveau"> | number
    num?: IntFilter<"Niveau"> | number
    specialiteId?: IntFilter<"Niveau"> | number
  }

  export type SpecialiteCreateWithoutNiveauInput = {
    nom: string
    image: string
  }

  export type SpecialiteUncheckedCreateWithoutNiveauInput = {
    id?: number
    nom: string
    image: string
  }

  export type SpecialiteCreateOrConnectWithoutNiveauInput = {
    where: SpecialiteWhereUniqueInput
    create: XOR<SpecialiteCreateWithoutNiveauInput, SpecialiteUncheckedCreateWithoutNiveauInput>
  }

  export type EspaceCoursCreateWithoutNiveauInput = {
    nom: string
    image: string
    cleAccee: string
    enseingant: EnseingantCreateNestedOneWithoutEspaceCoursInput
    Theme?: ThemeCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUncheckedCreateWithoutNiveauInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    enseingantId: number
    Theme?: ThemeUncheckedCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionUncheckedCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursCreateOrConnectWithoutNiveauInput = {
    where: EspaceCoursWhereUniqueInput
    create: XOR<EspaceCoursCreateWithoutNiveauInput, EspaceCoursUncheckedCreateWithoutNiveauInput>
  }

  export type EspaceCoursCreateManyNiveauInputEnvelope = {
    data: EspaceCoursCreateManyNiveauInput | EspaceCoursCreateManyNiveauInput[]
    skipDuplicates?: boolean
  }

  export type SpecialiteUpsertWithoutNiveauInput = {
    update: XOR<SpecialiteUpdateWithoutNiveauInput, SpecialiteUncheckedUpdateWithoutNiveauInput>
    create: XOR<SpecialiteCreateWithoutNiveauInput, SpecialiteUncheckedCreateWithoutNiveauInput>
    where?: SpecialiteWhereInput
  }

  export type SpecialiteUpdateToOneWithWhereWithoutNiveauInput = {
    where?: SpecialiteWhereInput
    data: XOR<SpecialiteUpdateWithoutNiveauInput, SpecialiteUncheckedUpdateWithoutNiveauInput>
  }

  export type SpecialiteUpdateWithoutNiveauInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type SpecialiteUncheckedUpdateWithoutNiveauInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type EspaceCoursUpsertWithWhereUniqueWithoutNiveauInput = {
    where: EspaceCoursWhereUniqueInput
    update: XOR<EspaceCoursUpdateWithoutNiveauInput, EspaceCoursUncheckedUpdateWithoutNiveauInput>
    create: XOR<EspaceCoursCreateWithoutNiveauInput, EspaceCoursUncheckedCreateWithoutNiveauInput>
  }

  export type EspaceCoursUpdateWithWhereUniqueWithoutNiveauInput = {
    where: EspaceCoursWhereUniqueInput
    data: XOR<EspaceCoursUpdateWithoutNiveauInput, EspaceCoursUncheckedUpdateWithoutNiveauInput>
  }

  export type EspaceCoursUpdateManyWithWhereWithoutNiveauInput = {
    where: EspaceCoursScalarWhereInput
    data: XOR<EspaceCoursUpdateManyMutationInput, EspaceCoursUncheckedUpdateManyWithoutNiveauInput>
  }

  export type EspaceCoursScalarWhereInput = {
    AND?: EspaceCoursScalarWhereInput | EspaceCoursScalarWhereInput[]
    OR?: EspaceCoursScalarWhereInput[]
    NOT?: EspaceCoursScalarWhereInput | EspaceCoursScalarWhereInput[]
    id?: IntFilter<"EspaceCours"> | number
    nom?: StringFilter<"EspaceCours"> | string
    image?: StringFilter<"EspaceCours"> | string
    cleAccee?: StringFilter<"EspaceCours"> | string
    niveauId?: IntFilter<"EspaceCours"> | number
    enseingantId?: IntFilter<"EspaceCours"> | number
  }

  export type NiveauCreateWithoutEspaceCoursInput = {
    num: number
    specialite: SpecialiteCreateNestedOneWithoutNiveauInput
  }

  export type NiveauUncheckedCreateWithoutEspaceCoursInput = {
    id?: number
    num: number
    specialiteId: number
  }

  export type NiveauCreateOrConnectWithoutEspaceCoursInput = {
    where: NiveauWhereUniqueInput
    create: XOR<NiveauCreateWithoutEspaceCoursInput, NiveauUncheckedCreateWithoutEspaceCoursInput>
  }

  export type EnseingantCreateWithoutEspaceCoursInput = {
    CIN: number
    user: UserCreateNestedOneWithoutEnseingantInput
  }

  export type EnseingantUncheckedCreateWithoutEspaceCoursInput = {
    id?: number
    userId: number
    CIN: number
  }

  export type EnseingantCreateOrConnectWithoutEspaceCoursInput = {
    where: EnseingantWhereUniqueInput
    create: XOR<EnseingantCreateWithoutEspaceCoursInput, EnseingantUncheckedCreateWithoutEspaceCoursInput>
  }

  export type ThemeCreateWithoutEspaceCoursInput = {
    nom: string
    EspaceDepot?: EspaceDepotCreateNestedManyWithoutThemeInput
    Ressource?: RessourceCreateNestedManyWithoutThemeInput
    Test?: TestCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutEspaceCoursInput = {
    id?: number
    nom: string
    EspaceDepot?: EspaceDepotUncheckedCreateNestedManyWithoutThemeInput
    Ressource?: RessourceUncheckedCreateNestedManyWithoutThemeInput
    Test?: TestUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutEspaceCoursInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutEspaceCoursInput, ThemeUncheckedCreateWithoutEspaceCoursInput>
  }

  export type ThemeCreateManyEspaceCoursInputEnvelope = {
    data: ThemeCreateManyEspaceCoursInput | ThemeCreateManyEspaceCoursInput[]
    skipDuplicates?: boolean
  }

  export type BanqueQuestionCreateWithoutEspaceCoursInput = {
    num: number
    desc: string
    Reponse?: ReponseCreateNestedManyWithoutBanqueQuestionInput
    TestQuestion?: TestQuestionCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionUncheckedCreateWithoutEspaceCoursInput = {
    id?: number
    num: number
    desc: string
    Reponse?: ReponseUncheckedCreateNestedManyWithoutBanqueQuestionInput
    TestQuestion?: TestQuestionUncheckedCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionCreateOrConnectWithoutEspaceCoursInput = {
    where: BanqueQuestionWhereUniqueInput
    create: XOR<BanqueQuestionCreateWithoutEspaceCoursInput, BanqueQuestionUncheckedCreateWithoutEspaceCoursInput>
  }

  export type BanqueQuestionCreateManyEspaceCoursInputEnvelope = {
    data: BanqueQuestionCreateManyEspaceCoursInput | BanqueQuestionCreateManyEspaceCoursInput[]
    skipDuplicates?: boolean
  }

  export type GamificationCreateWithoutEspaceCoursInput = {
    point?: number
    etudiant: EtudiantCreateNestedOneWithoutGamificationInput
  }

  export type GamificationUncheckedCreateWithoutEspaceCoursInput = {
    id?: number
    etudiantId: number
    point?: number
  }

  export type GamificationCreateOrConnectWithoutEspaceCoursInput = {
    where: GamificationWhereUniqueInput
    create: XOR<GamificationCreateWithoutEspaceCoursInput, GamificationUncheckedCreateWithoutEspaceCoursInput>
  }

  export type GamificationCreateManyEspaceCoursInputEnvelope = {
    data: GamificationCreateManyEspaceCoursInput | GamificationCreateManyEspaceCoursInput[]
    skipDuplicates?: boolean
  }

  export type NiveauUpsertWithoutEspaceCoursInput = {
    update: XOR<NiveauUpdateWithoutEspaceCoursInput, NiveauUncheckedUpdateWithoutEspaceCoursInput>
    create: XOR<NiveauCreateWithoutEspaceCoursInput, NiveauUncheckedCreateWithoutEspaceCoursInput>
    where?: NiveauWhereInput
  }

  export type NiveauUpdateToOneWithWhereWithoutEspaceCoursInput = {
    where?: NiveauWhereInput
    data: XOR<NiveauUpdateWithoutEspaceCoursInput, NiveauUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type NiveauUpdateWithoutEspaceCoursInput = {
    num?: IntFieldUpdateOperationsInput | number
    specialite?: SpecialiteUpdateOneRequiredWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    specialiteId?: IntFieldUpdateOperationsInput | number
  }

  export type EnseingantUpsertWithoutEspaceCoursInput = {
    update: XOR<EnseingantUpdateWithoutEspaceCoursInput, EnseingantUncheckedUpdateWithoutEspaceCoursInput>
    create: XOR<EnseingantCreateWithoutEspaceCoursInput, EnseingantUncheckedCreateWithoutEspaceCoursInput>
    where?: EnseingantWhereInput
  }

  export type EnseingantUpdateToOneWithWhereWithoutEspaceCoursInput = {
    where?: EnseingantWhereInput
    data: XOR<EnseingantUpdateWithoutEspaceCoursInput, EnseingantUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type EnseingantUpdateWithoutEspaceCoursInput = {
    CIN?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutEnseingantNestedInput
  }

  export type EnseingantUncheckedUpdateWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeUpsertWithWhereUniqueWithoutEspaceCoursInput = {
    where: ThemeWhereUniqueInput
    update: XOR<ThemeUpdateWithoutEspaceCoursInput, ThemeUncheckedUpdateWithoutEspaceCoursInput>
    create: XOR<ThemeCreateWithoutEspaceCoursInput, ThemeUncheckedCreateWithoutEspaceCoursInput>
  }

  export type ThemeUpdateWithWhereUniqueWithoutEspaceCoursInput = {
    where: ThemeWhereUniqueInput
    data: XOR<ThemeUpdateWithoutEspaceCoursInput, ThemeUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type ThemeUpdateManyWithWhereWithoutEspaceCoursInput = {
    where: ThemeScalarWhereInput
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyWithoutEspaceCoursInput>
  }

  export type ThemeScalarWhereInput = {
    AND?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
    OR?: ThemeScalarWhereInput[]
    NOT?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
    id?: IntFilter<"Theme"> | number
    nom?: StringFilter<"Theme"> | string
    espaceCoursId?: IntFilter<"Theme"> | number
  }

  export type BanqueQuestionUpsertWithWhereUniqueWithoutEspaceCoursInput = {
    where: BanqueQuestionWhereUniqueInput
    update: XOR<BanqueQuestionUpdateWithoutEspaceCoursInput, BanqueQuestionUncheckedUpdateWithoutEspaceCoursInput>
    create: XOR<BanqueQuestionCreateWithoutEspaceCoursInput, BanqueQuestionUncheckedCreateWithoutEspaceCoursInput>
  }

  export type BanqueQuestionUpdateWithWhereUniqueWithoutEspaceCoursInput = {
    where: BanqueQuestionWhereUniqueInput
    data: XOR<BanqueQuestionUpdateWithoutEspaceCoursInput, BanqueQuestionUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type BanqueQuestionUpdateManyWithWhereWithoutEspaceCoursInput = {
    where: BanqueQuestionScalarWhereInput
    data: XOR<BanqueQuestionUpdateManyMutationInput, BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursInput>
  }

  export type BanqueQuestionScalarWhereInput = {
    AND?: BanqueQuestionScalarWhereInput | BanqueQuestionScalarWhereInput[]
    OR?: BanqueQuestionScalarWhereInput[]
    NOT?: BanqueQuestionScalarWhereInput | BanqueQuestionScalarWhereInput[]
    id?: IntFilter<"BanqueQuestion"> | number
    num?: IntFilter<"BanqueQuestion"> | number
    desc?: StringFilter<"BanqueQuestion"> | string
    espaceCoursId?: IntFilter<"BanqueQuestion"> | number
  }

  export type GamificationUpsertWithWhereUniqueWithoutEspaceCoursInput = {
    where: GamificationWhereUniqueInput
    update: XOR<GamificationUpdateWithoutEspaceCoursInput, GamificationUncheckedUpdateWithoutEspaceCoursInput>
    create: XOR<GamificationCreateWithoutEspaceCoursInput, GamificationUncheckedCreateWithoutEspaceCoursInput>
  }

  export type GamificationUpdateWithWhereUniqueWithoutEspaceCoursInput = {
    where: GamificationWhereUniqueInput
    data: XOR<GamificationUpdateWithoutEspaceCoursInput, GamificationUncheckedUpdateWithoutEspaceCoursInput>
  }

  export type GamificationUpdateManyWithWhereWithoutEspaceCoursInput = {
    where: GamificationScalarWhereInput
    data: XOR<GamificationUpdateManyMutationInput, GamificationUncheckedUpdateManyWithoutEspaceCoursInput>
  }

  export type GamificationScalarWhereInput = {
    AND?: GamificationScalarWhereInput | GamificationScalarWhereInput[]
    OR?: GamificationScalarWhereInput[]
    NOT?: GamificationScalarWhereInput | GamificationScalarWhereInput[]
    id?: IntFilter<"Gamification"> | number
    etudiantId?: IntFilter<"Gamification"> | number
    espaceCoursId?: IntFilter<"Gamification"> | number
    point?: IntFilter<"Gamification"> | number
  }

  export type EspaceCoursCreateWithoutThemeInput = {
    nom: string
    image: string
    cleAccee: string
    niveau: NiveauCreateNestedOneWithoutEspaceCoursInput
    enseingant: EnseingantCreateNestedOneWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUncheckedCreateWithoutThemeInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    enseingantId: number
    BanqueQuestion?: BanqueQuestionUncheckedCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursCreateOrConnectWithoutThemeInput = {
    where: EspaceCoursWhereUniqueInput
    create: XOR<EspaceCoursCreateWithoutThemeInput, EspaceCoursUncheckedCreateWithoutThemeInput>
  }

  export type EspaceDepotCreateWithoutThemeInput = {
    nom: string
    type: $Enums.TypeFile
    dateDebut?: Date | string
    dateFin: Date | string
    Depot?: DepotCreateNestedManyWithoutEspaceDepotInput
  }

  export type EspaceDepotUncheckedCreateWithoutThemeInput = {
    id?: number
    nom: string
    type: $Enums.TypeFile
    dateDebut?: Date | string
    dateFin: Date | string
    Depot?: DepotUncheckedCreateNestedManyWithoutEspaceDepotInput
  }

  export type EspaceDepotCreateOrConnectWithoutThemeInput = {
    where: EspaceDepotWhereUniqueInput
    create: XOR<EspaceDepotCreateWithoutThemeInput, EspaceDepotUncheckedCreateWithoutThemeInput>
  }

  export type EspaceDepotCreateManyThemeInputEnvelope = {
    data: EspaceDepotCreateManyThemeInput | EspaceDepotCreateManyThemeInput[]
    skipDuplicates?: boolean
  }

  export type RessourceCreateWithoutThemeInput = {
    nom: string
    file: string
    type: $Enums.TypeFile
    dateDepot?: Date | string
    Commentaire?: CommentaireCreateNestedManyWithoutRessourceInput
  }

  export type RessourceUncheckedCreateWithoutThemeInput = {
    id?: number
    nom: string
    file: string
    type: $Enums.TypeFile
    dateDepot?: Date | string
    Commentaire?: CommentaireUncheckedCreateNestedManyWithoutRessourceInput
  }

  export type RessourceCreateOrConnectWithoutThemeInput = {
    where: RessourceWhereUniqueInput
    create: XOR<RessourceCreateWithoutThemeInput, RessourceUncheckedCreateWithoutThemeInput>
  }

  export type RessourceCreateManyThemeInputEnvelope = {
    data: RessourceCreateManyThemeInput | RessourceCreateManyThemeInput[]
    skipDuplicates?: boolean
  }

  export type TestCreateWithoutThemeInput = {
    nom: string
    point: number
    periode: number
    dateDebut?: Date | string
    dateFin: Date | string
    Resultat?: ResultatCreateNestedManyWithoutTestInput
    TestQuestion?: TestQuestionCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateWithoutThemeInput = {
    id?: number
    nom: string
    point: number
    periode: number
    dateDebut?: Date | string
    dateFin: Date | string
    Resultat?: ResultatUncheckedCreateNestedManyWithoutTestInput
    TestQuestion?: TestQuestionUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCreateOrConnectWithoutThemeInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutThemeInput, TestUncheckedCreateWithoutThemeInput>
  }

  export type TestCreateManyThemeInputEnvelope = {
    data: TestCreateManyThemeInput | TestCreateManyThemeInput[]
    skipDuplicates?: boolean
  }

  export type EspaceCoursUpsertWithoutThemeInput = {
    update: XOR<EspaceCoursUpdateWithoutThemeInput, EspaceCoursUncheckedUpdateWithoutThemeInput>
    create: XOR<EspaceCoursCreateWithoutThemeInput, EspaceCoursUncheckedCreateWithoutThemeInput>
    where?: EspaceCoursWhereInput
  }

  export type EspaceCoursUpdateToOneWithWhereWithoutThemeInput = {
    where?: EspaceCoursWhereInput
    data: XOR<EspaceCoursUpdateWithoutThemeInput, EspaceCoursUncheckedUpdateWithoutThemeInput>
  }

  export type EspaceCoursUpdateWithoutThemeInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveau?: NiveauUpdateOneRequiredWithoutEspaceCoursNestedInput
    enseingant?: EnseingantUpdateOneRequiredWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
    enseingantId?: IntFieldUpdateOperationsInput | number
    BanqueQuestion?: BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUncheckedUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceDepotUpsertWithWhereUniqueWithoutThemeInput = {
    where: EspaceDepotWhereUniqueInput
    update: XOR<EspaceDepotUpdateWithoutThemeInput, EspaceDepotUncheckedUpdateWithoutThemeInput>
    create: XOR<EspaceDepotCreateWithoutThemeInput, EspaceDepotUncheckedCreateWithoutThemeInput>
  }

  export type EspaceDepotUpdateWithWhereUniqueWithoutThemeInput = {
    where: EspaceDepotWhereUniqueInput
    data: XOR<EspaceDepotUpdateWithoutThemeInput, EspaceDepotUncheckedUpdateWithoutThemeInput>
  }

  export type EspaceDepotUpdateManyWithWhereWithoutThemeInput = {
    where: EspaceDepotScalarWhereInput
    data: XOR<EspaceDepotUpdateManyMutationInput, EspaceDepotUncheckedUpdateManyWithoutThemeInput>
  }

  export type EspaceDepotScalarWhereInput = {
    AND?: EspaceDepotScalarWhereInput | EspaceDepotScalarWhereInput[]
    OR?: EspaceDepotScalarWhereInput[]
    NOT?: EspaceDepotScalarWhereInput | EspaceDepotScalarWhereInput[]
    id?: IntFilter<"EspaceDepot"> | number
    nom?: StringFilter<"EspaceDepot"> | string
    type?: EnumTypeFileFilter<"EspaceDepot"> | $Enums.TypeFile
    themeId?: IntFilter<"EspaceDepot"> | number
    dateDebut?: DateTimeFilter<"EspaceDepot"> | Date | string
    dateFin?: DateTimeFilter<"EspaceDepot"> | Date | string
  }

  export type RessourceUpsertWithWhereUniqueWithoutThemeInput = {
    where: RessourceWhereUniqueInput
    update: XOR<RessourceUpdateWithoutThemeInput, RessourceUncheckedUpdateWithoutThemeInput>
    create: XOR<RessourceCreateWithoutThemeInput, RessourceUncheckedCreateWithoutThemeInput>
  }

  export type RessourceUpdateWithWhereUniqueWithoutThemeInput = {
    where: RessourceWhereUniqueInput
    data: XOR<RessourceUpdateWithoutThemeInput, RessourceUncheckedUpdateWithoutThemeInput>
  }

  export type RessourceUpdateManyWithWhereWithoutThemeInput = {
    where: RessourceScalarWhereInput
    data: XOR<RessourceUpdateManyMutationInput, RessourceUncheckedUpdateManyWithoutThemeInput>
  }

  export type RessourceScalarWhereInput = {
    AND?: RessourceScalarWhereInput | RessourceScalarWhereInput[]
    OR?: RessourceScalarWhereInput[]
    NOT?: RessourceScalarWhereInput | RessourceScalarWhereInput[]
    id?: IntFilter<"Ressource"> | number
    nom?: StringFilter<"Ressource"> | string
    file?: StringFilter<"Ressource"> | string
    type?: EnumTypeFileFilter<"Ressource"> | $Enums.TypeFile
    themeId?: IntFilter<"Ressource"> | number
    dateDepot?: DateTimeFilter<"Ressource"> | Date | string
  }

  export type TestUpsertWithWhereUniqueWithoutThemeInput = {
    where: TestWhereUniqueInput
    update: XOR<TestUpdateWithoutThemeInput, TestUncheckedUpdateWithoutThemeInput>
    create: XOR<TestCreateWithoutThemeInput, TestUncheckedCreateWithoutThemeInput>
  }

  export type TestUpdateWithWhereUniqueWithoutThemeInput = {
    where: TestWhereUniqueInput
    data: XOR<TestUpdateWithoutThemeInput, TestUncheckedUpdateWithoutThemeInput>
  }

  export type TestUpdateManyWithWhereWithoutThemeInput = {
    where: TestScalarWhereInput
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyWithoutThemeInput>
  }

  export type TestScalarWhereInput = {
    AND?: TestScalarWhereInput | TestScalarWhereInput[]
    OR?: TestScalarWhereInput[]
    NOT?: TestScalarWhereInput | TestScalarWhereInput[]
    id?: IntFilter<"Test"> | number
    nom?: StringFilter<"Test"> | string
    point?: IntFilter<"Test"> | number
    periode?: IntFilter<"Test"> | number
    themeId?: IntFilter<"Test"> | number
    dateDebut?: DateTimeFilter<"Test"> | Date | string
    dateFin?: DateTimeFilter<"Test"> | Date | string
  }

  export type ThemeCreateWithoutEspaceDepotInput = {
    nom: string
    espaceCours: EspaceCoursCreateNestedOneWithoutThemeInput
    Ressource?: RessourceCreateNestedManyWithoutThemeInput
    Test?: TestCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutEspaceDepotInput = {
    id?: number
    nom: string
    espaceCoursId: number
    Ressource?: RessourceUncheckedCreateNestedManyWithoutThemeInput
    Test?: TestUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutEspaceDepotInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutEspaceDepotInput, ThemeUncheckedCreateWithoutEspaceDepotInput>
  }

  export type DepotCreateWithoutEspaceDepotInput = {
    file: string
    etudiant: EtudiantCreateNestedOneWithoutDepotInput
  }

  export type DepotUncheckedCreateWithoutEspaceDepotInput = {
    id?: number
    etudiantId: number
    file: string
  }

  export type DepotCreateOrConnectWithoutEspaceDepotInput = {
    where: DepotWhereUniqueInput
    create: XOR<DepotCreateWithoutEspaceDepotInput, DepotUncheckedCreateWithoutEspaceDepotInput>
  }

  export type DepotCreateManyEspaceDepotInputEnvelope = {
    data: DepotCreateManyEspaceDepotInput | DepotCreateManyEspaceDepotInput[]
    skipDuplicates?: boolean
  }

  export type ThemeUpsertWithoutEspaceDepotInput = {
    update: XOR<ThemeUpdateWithoutEspaceDepotInput, ThemeUncheckedUpdateWithoutEspaceDepotInput>
    create: XOR<ThemeCreateWithoutEspaceDepotInput, ThemeUncheckedCreateWithoutEspaceDepotInput>
    where?: ThemeWhereInput
  }

  export type ThemeUpdateToOneWithWhereWithoutEspaceDepotInput = {
    where?: ThemeWhereInput
    data: XOR<ThemeUpdateWithoutEspaceDepotInput, ThemeUncheckedUpdateWithoutEspaceDepotInput>
  }

  export type ThemeUpdateWithoutEspaceDepotInput = {
    nom?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutThemeNestedInput
    Ressource?: RessourceUpdateManyWithoutThemeNestedInput
    Test?: TestUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutEspaceDepotInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    Ressource?: RessourceUncheckedUpdateManyWithoutThemeNestedInput
    Test?: TestUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type DepotUpsertWithWhereUniqueWithoutEspaceDepotInput = {
    where: DepotWhereUniqueInput
    update: XOR<DepotUpdateWithoutEspaceDepotInput, DepotUncheckedUpdateWithoutEspaceDepotInput>
    create: XOR<DepotCreateWithoutEspaceDepotInput, DepotUncheckedCreateWithoutEspaceDepotInput>
  }

  export type DepotUpdateWithWhereUniqueWithoutEspaceDepotInput = {
    where: DepotWhereUniqueInput
    data: XOR<DepotUpdateWithoutEspaceDepotInput, DepotUncheckedUpdateWithoutEspaceDepotInput>
  }

  export type DepotUpdateManyWithWhereWithoutEspaceDepotInput = {
    where: DepotScalarWhereInput
    data: XOR<DepotUpdateManyMutationInput, DepotUncheckedUpdateManyWithoutEspaceDepotInput>
  }

  export type DepotScalarWhereInput = {
    AND?: DepotScalarWhereInput | DepotScalarWhereInput[]
    OR?: DepotScalarWhereInput[]
    NOT?: DepotScalarWhereInput | DepotScalarWhereInput[]
    id?: IntFilter<"Depot"> | number
    etudiantId?: IntFilter<"Depot"> | number
    espaceDepotId?: IntFilter<"Depot"> | number
    file?: StringFilter<"Depot"> | string
  }

  export type ThemeCreateWithoutRessourceInput = {
    nom: string
    espaceCours: EspaceCoursCreateNestedOneWithoutThemeInput
    EspaceDepot?: EspaceDepotCreateNestedManyWithoutThemeInput
    Test?: TestCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutRessourceInput = {
    id?: number
    nom: string
    espaceCoursId: number
    EspaceDepot?: EspaceDepotUncheckedCreateNestedManyWithoutThemeInput
    Test?: TestUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutRessourceInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutRessourceInput, ThemeUncheckedCreateWithoutRessourceInput>
  }

  export type CommentaireCreateWithoutRessourceInput = {
    desc: string
    font: string
    italic: boolean
    user: UserCreateNestedOneWithoutCommentaireInput
  }

  export type CommentaireUncheckedCreateWithoutRessourceInput = {
    id?: number
    desc: string
    font: string
    italic: boolean
    userId: number
  }

  export type CommentaireCreateOrConnectWithoutRessourceInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutRessourceInput, CommentaireUncheckedCreateWithoutRessourceInput>
  }

  export type CommentaireCreateManyRessourceInputEnvelope = {
    data: CommentaireCreateManyRessourceInput | CommentaireCreateManyRessourceInput[]
    skipDuplicates?: boolean
  }

  export type ThemeUpsertWithoutRessourceInput = {
    update: XOR<ThemeUpdateWithoutRessourceInput, ThemeUncheckedUpdateWithoutRessourceInput>
    create: XOR<ThemeCreateWithoutRessourceInput, ThemeUncheckedCreateWithoutRessourceInput>
    where?: ThemeWhereInput
  }

  export type ThemeUpdateToOneWithWhereWithoutRessourceInput = {
    where?: ThemeWhereInput
    data: XOR<ThemeUpdateWithoutRessourceInput, ThemeUncheckedUpdateWithoutRessourceInput>
  }

  export type ThemeUpdateWithoutRessourceInput = {
    nom?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutThemeNestedInput
    EspaceDepot?: EspaceDepotUpdateManyWithoutThemeNestedInput
    Test?: TestUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutRessourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    EspaceDepot?: EspaceDepotUncheckedUpdateManyWithoutThemeNestedInput
    Test?: TestUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type CommentaireUpsertWithWhereUniqueWithoutRessourceInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutRessourceInput, CommentaireUncheckedUpdateWithoutRessourceInput>
    create: XOR<CommentaireCreateWithoutRessourceInput, CommentaireUncheckedCreateWithoutRessourceInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutRessourceInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutRessourceInput, CommentaireUncheckedUpdateWithoutRessourceInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutRessourceInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutRessourceInput>
  }

  export type CommentaireScalarWhereInput = {
    AND?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
    OR?: CommentaireScalarWhereInput[]
    NOT?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
    id?: IntFilter<"Commentaire"> | number
    desc?: StringFilter<"Commentaire"> | string
    font?: StringFilter<"Commentaire"> | string
    italic?: BoolFilter<"Commentaire"> | boolean
    ressourceId?: IntFilter<"Commentaire"> | number
    userId?: IntFilter<"Commentaire"> | number
  }

  export type ThemeCreateWithoutTestInput = {
    nom: string
    espaceCours: EspaceCoursCreateNestedOneWithoutThemeInput
    EspaceDepot?: EspaceDepotCreateNestedManyWithoutThemeInput
    Ressource?: RessourceCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutTestInput = {
    id?: number
    nom: string
    espaceCoursId: number
    EspaceDepot?: EspaceDepotUncheckedCreateNestedManyWithoutThemeInput
    Ressource?: RessourceUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutTestInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutTestInput, ThemeUncheckedCreateWithoutTestInput>
  }

  export type ResultatCreateWithoutTestInput = {
    point?: number
    etudiant: EtudiantCreateNestedOneWithoutResultatInput
  }

  export type ResultatUncheckedCreateWithoutTestInput = {
    id?: number
    etudiantId: number
    point?: number
  }

  export type ResultatCreateOrConnectWithoutTestInput = {
    where: ResultatWhereUniqueInput
    create: XOR<ResultatCreateWithoutTestInput, ResultatUncheckedCreateWithoutTestInput>
  }

  export type ResultatCreateManyTestInputEnvelope = {
    data: ResultatCreateManyTestInput | ResultatCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TestQuestionCreateWithoutTestInput = {
    point?: number
    banqueQuestion: BanqueQuestionCreateNestedOneWithoutTestQuestionInput
  }

  export type TestQuestionUncheckedCreateWithoutTestInput = {
    id?: number
    point?: number
    banqueQuestionId: number
  }

  export type TestQuestionCreateOrConnectWithoutTestInput = {
    where: TestQuestionWhereUniqueInput
    create: XOR<TestQuestionCreateWithoutTestInput, TestQuestionUncheckedCreateWithoutTestInput>
  }

  export type TestQuestionCreateManyTestInputEnvelope = {
    data: TestQuestionCreateManyTestInput | TestQuestionCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type ThemeUpsertWithoutTestInput = {
    update: XOR<ThemeUpdateWithoutTestInput, ThemeUncheckedUpdateWithoutTestInput>
    create: XOR<ThemeCreateWithoutTestInput, ThemeUncheckedCreateWithoutTestInput>
    where?: ThemeWhereInput
  }

  export type ThemeUpdateToOneWithWhereWithoutTestInput = {
    where?: ThemeWhereInput
    data: XOR<ThemeUpdateWithoutTestInput, ThemeUncheckedUpdateWithoutTestInput>
  }

  export type ThemeUpdateWithoutTestInput = {
    nom?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutThemeNestedInput
    EspaceDepot?: EspaceDepotUpdateManyWithoutThemeNestedInput
    Ressource?: RessourceUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    EspaceDepot?: EspaceDepotUncheckedUpdateManyWithoutThemeNestedInput
    Ressource?: RessourceUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ResultatUpsertWithWhereUniqueWithoutTestInput = {
    where: ResultatWhereUniqueInput
    update: XOR<ResultatUpdateWithoutTestInput, ResultatUncheckedUpdateWithoutTestInput>
    create: XOR<ResultatCreateWithoutTestInput, ResultatUncheckedCreateWithoutTestInput>
  }

  export type ResultatUpdateWithWhereUniqueWithoutTestInput = {
    where: ResultatWhereUniqueInput
    data: XOR<ResultatUpdateWithoutTestInput, ResultatUncheckedUpdateWithoutTestInput>
  }

  export type ResultatUpdateManyWithWhereWithoutTestInput = {
    where: ResultatScalarWhereInput
    data: XOR<ResultatUpdateManyMutationInput, ResultatUncheckedUpdateManyWithoutTestInput>
  }

  export type ResultatScalarWhereInput = {
    AND?: ResultatScalarWhereInput | ResultatScalarWhereInput[]
    OR?: ResultatScalarWhereInput[]
    NOT?: ResultatScalarWhereInput | ResultatScalarWhereInput[]
    id?: IntFilter<"Resultat"> | number
    etudiantId?: IntFilter<"Resultat"> | number
    testId?: IntFilter<"Resultat"> | number
    point?: IntFilter<"Resultat"> | number
  }

  export type TestQuestionUpsertWithWhereUniqueWithoutTestInput = {
    where: TestQuestionWhereUniqueInput
    update: XOR<TestQuestionUpdateWithoutTestInput, TestQuestionUncheckedUpdateWithoutTestInput>
    create: XOR<TestQuestionCreateWithoutTestInput, TestQuestionUncheckedCreateWithoutTestInput>
  }

  export type TestQuestionUpdateWithWhereUniqueWithoutTestInput = {
    where: TestQuestionWhereUniqueInput
    data: XOR<TestQuestionUpdateWithoutTestInput, TestQuestionUncheckedUpdateWithoutTestInput>
  }

  export type TestQuestionUpdateManyWithWhereWithoutTestInput = {
    where: TestQuestionScalarWhereInput
    data: XOR<TestQuestionUpdateManyMutationInput, TestQuestionUncheckedUpdateManyWithoutTestInput>
  }

  export type TestQuestionScalarWhereInput = {
    AND?: TestQuestionScalarWhereInput | TestQuestionScalarWhereInput[]
    OR?: TestQuestionScalarWhereInput[]
    NOT?: TestQuestionScalarWhereInput | TestQuestionScalarWhereInput[]
    id?: IntFilter<"TestQuestion"> | number
    point?: IntFilter<"TestQuestion"> | number
    banqueQuestionId?: IntFilter<"TestQuestion"> | number
    testId?: IntFilter<"TestQuestion"> | number
  }

  export type EspaceCoursCreateWithoutBanqueQuestionInput = {
    nom: string
    image: string
    cleAccee: string
    niveau: NiveauCreateNestedOneWithoutEspaceCoursInput
    enseingant: EnseingantCreateNestedOneWithoutEspaceCoursInput
    Theme?: ThemeCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUncheckedCreateWithoutBanqueQuestionInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    enseingantId: number
    Theme?: ThemeUncheckedCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursCreateOrConnectWithoutBanqueQuestionInput = {
    where: EspaceCoursWhereUniqueInput
    create: XOR<EspaceCoursCreateWithoutBanqueQuestionInput, EspaceCoursUncheckedCreateWithoutBanqueQuestionInput>
  }

  export type ReponseCreateWithoutBanqueQuestionInput = {
    num: number
    desc: string
    isCorrecte: boolean
  }

  export type ReponseUncheckedCreateWithoutBanqueQuestionInput = {
    id?: number
    num: number
    desc: string
    isCorrecte: boolean
  }

  export type ReponseCreateOrConnectWithoutBanqueQuestionInput = {
    where: ReponseWhereUniqueInput
    create: XOR<ReponseCreateWithoutBanqueQuestionInput, ReponseUncheckedCreateWithoutBanqueQuestionInput>
  }

  export type ReponseCreateManyBanqueQuestionInputEnvelope = {
    data: ReponseCreateManyBanqueQuestionInput | ReponseCreateManyBanqueQuestionInput[]
    skipDuplicates?: boolean
  }

  export type TestQuestionCreateWithoutBanqueQuestionInput = {
    point?: number
    test: TestCreateNestedOneWithoutTestQuestionInput
  }

  export type TestQuestionUncheckedCreateWithoutBanqueQuestionInput = {
    id?: number
    point?: number
    testId: number
  }

  export type TestQuestionCreateOrConnectWithoutBanqueQuestionInput = {
    where: TestQuestionWhereUniqueInput
    create: XOR<TestQuestionCreateWithoutBanqueQuestionInput, TestQuestionUncheckedCreateWithoutBanqueQuestionInput>
  }

  export type TestQuestionCreateManyBanqueQuestionInputEnvelope = {
    data: TestQuestionCreateManyBanqueQuestionInput | TestQuestionCreateManyBanqueQuestionInput[]
    skipDuplicates?: boolean
  }

  export type EspaceCoursUpsertWithoutBanqueQuestionInput = {
    update: XOR<EspaceCoursUpdateWithoutBanqueQuestionInput, EspaceCoursUncheckedUpdateWithoutBanqueQuestionInput>
    create: XOR<EspaceCoursCreateWithoutBanqueQuestionInput, EspaceCoursUncheckedCreateWithoutBanqueQuestionInput>
    where?: EspaceCoursWhereInput
  }

  export type EspaceCoursUpdateToOneWithWhereWithoutBanqueQuestionInput = {
    where?: EspaceCoursWhereInput
    data: XOR<EspaceCoursUpdateWithoutBanqueQuestionInput, EspaceCoursUncheckedUpdateWithoutBanqueQuestionInput>
  }

  export type EspaceCoursUpdateWithoutBanqueQuestionInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveau?: NiveauUpdateOneRequiredWithoutEspaceCoursNestedInput
    enseingant?: EnseingantUpdateOneRequiredWithoutEspaceCoursNestedInput
    Theme?: ThemeUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateWithoutBanqueQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
    enseingantId?: IntFieldUpdateOperationsInput | number
    Theme?: ThemeUncheckedUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUncheckedUpdateManyWithoutEspaceCoursNestedInput
  }

  export type ReponseUpsertWithWhereUniqueWithoutBanqueQuestionInput = {
    where: ReponseWhereUniqueInput
    update: XOR<ReponseUpdateWithoutBanqueQuestionInput, ReponseUncheckedUpdateWithoutBanqueQuestionInput>
    create: XOR<ReponseCreateWithoutBanqueQuestionInput, ReponseUncheckedCreateWithoutBanqueQuestionInput>
  }

  export type ReponseUpdateWithWhereUniqueWithoutBanqueQuestionInput = {
    where: ReponseWhereUniqueInput
    data: XOR<ReponseUpdateWithoutBanqueQuestionInput, ReponseUncheckedUpdateWithoutBanqueQuestionInput>
  }

  export type ReponseUpdateManyWithWhereWithoutBanqueQuestionInput = {
    where: ReponseScalarWhereInput
    data: XOR<ReponseUpdateManyMutationInput, ReponseUncheckedUpdateManyWithoutBanqueQuestionInput>
  }

  export type ReponseScalarWhereInput = {
    AND?: ReponseScalarWhereInput | ReponseScalarWhereInput[]
    OR?: ReponseScalarWhereInput[]
    NOT?: ReponseScalarWhereInput | ReponseScalarWhereInput[]
    id?: IntFilter<"Reponse"> | number
    num?: IntFilter<"Reponse"> | number
    desc?: StringFilter<"Reponse"> | string
    isCorrecte?: BoolFilter<"Reponse"> | boolean
    banqueQuestionId?: IntFilter<"Reponse"> | number
  }

  export type TestQuestionUpsertWithWhereUniqueWithoutBanqueQuestionInput = {
    where: TestQuestionWhereUniqueInput
    update: XOR<TestQuestionUpdateWithoutBanqueQuestionInput, TestQuestionUncheckedUpdateWithoutBanqueQuestionInput>
    create: XOR<TestQuestionCreateWithoutBanqueQuestionInput, TestQuestionUncheckedCreateWithoutBanqueQuestionInput>
  }

  export type TestQuestionUpdateWithWhereUniqueWithoutBanqueQuestionInput = {
    where: TestQuestionWhereUniqueInput
    data: XOR<TestQuestionUpdateWithoutBanqueQuestionInput, TestQuestionUncheckedUpdateWithoutBanqueQuestionInput>
  }

  export type TestQuestionUpdateManyWithWhereWithoutBanqueQuestionInput = {
    where: TestQuestionScalarWhereInput
    data: XOR<TestQuestionUpdateManyMutationInput, TestQuestionUncheckedUpdateManyWithoutBanqueQuestionInput>
  }

  export type BanqueQuestionCreateWithoutReponseInput = {
    num: number
    desc: string
    espaceCours: EspaceCoursCreateNestedOneWithoutBanqueQuestionInput
    TestQuestion?: TestQuestionCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionUncheckedCreateWithoutReponseInput = {
    id?: number
    num: number
    desc: string
    espaceCoursId: number
    TestQuestion?: TestQuestionUncheckedCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionCreateOrConnectWithoutReponseInput = {
    where: BanqueQuestionWhereUniqueInput
    create: XOR<BanqueQuestionCreateWithoutReponseInput, BanqueQuestionUncheckedCreateWithoutReponseInput>
  }

  export type BanqueQuestionUpsertWithoutReponseInput = {
    update: XOR<BanqueQuestionUpdateWithoutReponseInput, BanqueQuestionUncheckedUpdateWithoutReponseInput>
    create: XOR<BanqueQuestionCreateWithoutReponseInput, BanqueQuestionUncheckedCreateWithoutReponseInput>
    where?: BanqueQuestionWhereInput
  }

  export type BanqueQuestionUpdateToOneWithWhereWithoutReponseInput = {
    where?: BanqueQuestionWhereInput
    data: XOR<BanqueQuestionUpdateWithoutReponseInput, BanqueQuestionUncheckedUpdateWithoutReponseInput>
  }

  export type BanqueQuestionUpdateWithoutReponseInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutBanqueQuestionNestedInput
    TestQuestion?: TestQuestionUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type BanqueQuestionUncheckedUpdateWithoutReponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    TestQuestion?: TestQuestionUncheckedUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type RessourceCreateWithoutCommentaireInput = {
    nom: string
    file: string
    type: $Enums.TypeFile
    dateDepot?: Date | string
    theme: ThemeCreateNestedOneWithoutRessourceInput
  }

  export type RessourceUncheckedCreateWithoutCommentaireInput = {
    id?: number
    nom: string
    file: string
    type: $Enums.TypeFile
    themeId: number
    dateDepot?: Date | string
  }

  export type RessourceCreateOrConnectWithoutCommentaireInput = {
    where: RessourceWhereUniqueInput
    create: XOR<RessourceCreateWithoutCommentaireInput, RessourceUncheckedCreateWithoutCommentaireInput>
  }

  export type UserCreateWithoutCommentaireInput = {
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantCreateNestedOneWithoutUserInput
    Enseingant?: EnseingantCreateNestedOneWithoutUserInput
    Admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentaireInput = {
    id?: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantUncheckedCreateNestedOneWithoutUserInput
    Enseingant?: EnseingantUncheckedCreateNestedOneWithoutUserInput
    Admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentaireInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentaireInput, UserUncheckedCreateWithoutCommentaireInput>
  }

  export type RessourceUpsertWithoutCommentaireInput = {
    update: XOR<RessourceUpdateWithoutCommentaireInput, RessourceUncheckedUpdateWithoutCommentaireInput>
    create: XOR<RessourceCreateWithoutCommentaireInput, RessourceUncheckedCreateWithoutCommentaireInput>
    where?: RessourceWhereInput
  }

  export type RessourceUpdateToOneWithWhereWithoutCommentaireInput = {
    where?: RessourceWhereInput
    data: XOR<RessourceUpdateWithoutCommentaireInput, RessourceUncheckedUpdateWithoutCommentaireInput>
  }

  export type RessourceUpdateWithoutCommentaireInput = {
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutRessourceNestedInput
  }

  export type RessourceUncheckedUpdateWithoutCommentaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    themeId?: IntFieldUpdateOperationsInput | number
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentaireInput = {
    update: XOR<UserUpdateWithoutCommentaireInput, UserUncheckedUpdateWithoutCommentaireInput>
    create: XOR<UserCreateWithoutCommentaireInput, UserUncheckedCreateWithoutCommentaireInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentaireInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentaireInput, UserUncheckedUpdateWithoutCommentaireInput>
  }

  export type UserUpdateWithoutCommentaireInput = {
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUpdateOneWithoutUserNestedInput
    Enseingant?: EnseingantUpdateOneWithoutUserNestedInput
    Admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUncheckedUpdateOneWithoutUserNestedInput
    Enseingant?: EnseingantUncheckedUpdateOneWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EtudiantCreateWithoutUserInput = {
    matricule: number
    dateNaiss: Date | string
    Gamification?: GamificationCreateNestedManyWithoutEtudiantInput
    Resultat?: ResultatCreateNestedManyWithoutEtudiantInput
    Depot?: DepotCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutUserInput = {
    id?: number
    matricule: number
    dateNaiss: Date | string
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEtudiantInput
    Resultat?: ResultatUncheckedCreateNestedManyWithoutEtudiantInput
    Depot?: DepotUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutUserInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutUserInput, EtudiantUncheckedCreateWithoutUserInput>
  }

  export type EnseingantCreateWithoutUserInput = {
    CIN: number
    EspaceCours?: EspaceCoursCreateNestedManyWithoutEnseingantInput
  }

  export type EnseingantUncheckedCreateWithoutUserInput = {
    id?: number
    CIN: number
    EspaceCours?: EspaceCoursUncheckedCreateNestedManyWithoutEnseingantInput
  }

  export type EnseingantCreateOrConnectWithoutUserInput = {
    where: EnseingantWhereUniqueInput
    create: XOR<EnseingantCreateWithoutUserInput, EnseingantUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    CIN: number
    post: string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: number
    CIN: number
    post: string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type CommentaireCreateWithoutUserInput = {
    desc: string
    font: string
    italic: boolean
    ressource: RessourceCreateNestedOneWithoutCommentaireInput
  }

  export type CommentaireUncheckedCreateWithoutUserInput = {
    id?: number
    desc: string
    font: string
    italic: boolean
    ressourceId: number
  }

  export type CommentaireCreateOrConnectWithoutUserInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput>
  }

  export type CommentaireCreateManyUserInputEnvelope = {
    data: CommentaireCreateManyUserInput | CommentaireCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EtudiantUpsertWithoutUserInput = {
    update: XOR<EtudiantUpdateWithoutUserInput, EtudiantUncheckedUpdateWithoutUserInput>
    create: XOR<EtudiantCreateWithoutUserInput, EtudiantUncheckedCreateWithoutUserInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutUserInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutUserInput, EtudiantUncheckedUpdateWithoutUserInput>
  }

  export type EtudiantUpdateWithoutUserInput = {
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    Gamification?: GamificationUpdateManyWithoutEtudiantNestedInput
    Resultat?: ResultatUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    Gamification?: GamificationUncheckedUpdateManyWithoutEtudiantNestedInput
    Resultat?: ResultatUncheckedUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type EnseingantUpsertWithoutUserInput = {
    update: XOR<EnseingantUpdateWithoutUserInput, EnseingantUncheckedUpdateWithoutUserInput>
    create: XOR<EnseingantCreateWithoutUserInput, EnseingantUncheckedCreateWithoutUserInput>
    where?: EnseingantWhereInput
  }

  export type EnseingantUpdateToOneWithWhereWithoutUserInput = {
    where?: EnseingantWhereInput
    data: XOR<EnseingantUpdateWithoutUserInput, EnseingantUncheckedUpdateWithoutUserInput>
  }

  export type EnseingantUpdateWithoutUserInput = {
    CIN?: IntFieldUpdateOperationsInput | number
    EspaceCours?: EspaceCoursUpdateManyWithoutEnseingantNestedInput
  }

  export type EnseingantUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
    EspaceCours?: EspaceCoursUncheckedUpdateManyWithoutEnseingantNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    CIN?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    CIN?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
  }

  export type CommentaireUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutUserInput, CommentaireUncheckedUpdateWithoutUserInput>
    create: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutUserInput, CommentaireUncheckedUpdateWithoutUserInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutUserInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutEtudiantInput = {
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Enseingant?: EnseingantCreateNestedOneWithoutUserInput
    Admin?: AdminCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEtudiantInput = {
    id?: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Enseingant?: EnseingantUncheckedCreateNestedOneWithoutUserInput
    Admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEtudiantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEtudiantInput, UserUncheckedCreateWithoutEtudiantInput>
  }

  export type GamificationCreateWithoutEtudiantInput = {
    point?: number
    espaceCours: EspaceCoursCreateNestedOneWithoutGamificationInput
  }

  export type GamificationUncheckedCreateWithoutEtudiantInput = {
    id?: number
    espaceCoursId: number
    point?: number
  }

  export type GamificationCreateOrConnectWithoutEtudiantInput = {
    where: GamificationWhereUniqueInput
    create: XOR<GamificationCreateWithoutEtudiantInput, GamificationUncheckedCreateWithoutEtudiantInput>
  }

  export type GamificationCreateManyEtudiantInputEnvelope = {
    data: GamificationCreateManyEtudiantInput | GamificationCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type ResultatCreateWithoutEtudiantInput = {
    point?: number
    test: TestCreateNestedOneWithoutResultatInput
  }

  export type ResultatUncheckedCreateWithoutEtudiantInput = {
    id?: number
    testId: number
    point?: number
  }

  export type ResultatCreateOrConnectWithoutEtudiantInput = {
    where: ResultatWhereUniqueInput
    create: XOR<ResultatCreateWithoutEtudiantInput, ResultatUncheckedCreateWithoutEtudiantInput>
  }

  export type ResultatCreateManyEtudiantInputEnvelope = {
    data: ResultatCreateManyEtudiantInput | ResultatCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type DepotCreateWithoutEtudiantInput = {
    file: string
    espaceDepot: EspaceDepotCreateNestedOneWithoutDepotInput
  }

  export type DepotUncheckedCreateWithoutEtudiantInput = {
    id?: number
    espaceDepotId: number
    file: string
  }

  export type DepotCreateOrConnectWithoutEtudiantInput = {
    where: DepotWhereUniqueInput
    create: XOR<DepotCreateWithoutEtudiantInput, DepotUncheckedCreateWithoutEtudiantInput>
  }

  export type DepotCreateManyEtudiantInputEnvelope = {
    data: DepotCreateManyEtudiantInput | DepotCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEtudiantInput = {
    update: XOR<UserUpdateWithoutEtudiantInput, UserUncheckedUpdateWithoutEtudiantInput>
    create: XOR<UserCreateWithoutEtudiantInput, UserUncheckedCreateWithoutEtudiantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEtudiantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEtudiantInput, UserUncheckedUpdateWithoutEtudiantInput>
  }

  export type UserUpdateWithoutEtudiantInput = {
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Enseingant?: EnseingantUpdateOneWithoutUserNestedInput
    Admin?: AdminUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Enseingant?: EnseingantUncheckedUpdateOneWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GamificationUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: GamificationWhereUniqueInput
    update: XOR<GamificationUpdateWithoutEtudiantInput, GamificationUncheckedUpdateWithoutEtudiantInput>
    create: XOR<GamificationCreateWithoutEtudiantInput, GamificationUncheckedCreateWithoutEtudiantInput>
  }

  export type GamificationUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: GamificationWhereUniqueInput
    data: XOR<GamificationUpdateWithoutEtudiantInput, GamificationUncheckedUpdateWithoutEtudiantInput>
  }

  export type GamificationUpdateManyWithWhereWithoutEtudiantInput = {
    where: GamificationScalarWhereInput
    data: XOR<GamificationUpdateManyMutationInput, GamificationUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type ResultatUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: ResultatWhereUniqueInput
    update: XOR<ResultatUpdateWithoutEtudiantInput, ResultatUncheckedUpdateWithoutEtudiantInput>
    create: XOR<ResultatCreateWithoutEtudiantInput, ResultatUncheckedCreateWithoutEtudiantInput>
  }

  export type ResultatUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: ResultatWhereUniqueInput
    data: XOR<ResultatUpdateWithoutEtudiantInput, ResultatUncheckedUpdateWithoutEtudiantInput>
  }

  export type ResultatUpdateManyWithWhereWithoutEtudiantInput = {
    where: ResultatScalarWhereInput
    data: XOR<ResultatUpdateManyMutationInput, ResultatUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type DepotUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: DepotWhereUniqueInput
    update: XOR<DepotUpdateWithoutEtudiantInput, DepotUncheckedUpdateWithoutEtudiantInput>
    create: XOR<DepotCreateWithoutEtudiantInput, DepotUncheckedCreateWithoutEtudiantInput>
  }

  export type DepotUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: DepotWhereUniqueInput
    data: XOR<DepotUpdateWithoutEtudiantInput, DepotUncheckedUpdateWithoutEtudiantInput>
  }

  export type DepotUpdateManyWithWhereWithoutEtudiantInput = {
    where: DepotScalarWhereInput
    data: XOR<DepotUpdateManyMutationInput, DepotUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type UserCreateWithoutEnseingantInput = {
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantCreateNestedOneWithoutUserInput
    Admin?: AdminCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnseingantInput = {
    id?: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantUncheckedCreateNestedOneWithoutUserInput
    Admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnseingantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnseingantInput, UserUncheckedCreateWithoutEnseingantInput>
  }

  export type EspaceCoursCreateWithoutEnseingantInput = {
    nom: string
    image: string
    cleAccee: string
    niveau: NiveauCreateNestedOneWithoutEspaceCoursInput
    Theme?: ThemeCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUncheckedCreateWithoutEnseingantInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    Theme?: ThemeUncheckedCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionUncheckedCreateNestedManyWithoutEspaceCoursInput
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursCreateOrConnectWithoutEnseingantInput = {
    where: EspaceCoursWhereUniqueInput
    create: XOR<EspaceCoursCreateWithoutEnseingantInput, EspaceCoursUncheckedCreateWithoutEnseingantInput>
  }

  export type EspaceCoursCreateManyEnseingantInputEnvelope = {
    data: EspaceCoursCreateManyEnseingantInput | EspaceCoursCreateManyEnseingantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEnseingantInput = {
    update: XOR<UserUpdateWithoutEnseingantInput, UserUncheckedUpdateWithoutEnseingantInput>
    create: XOR<UserCreateWithoutEnseingantInput, UserUncheckedCreateWithoutEnseingantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnseingantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnseingantInput, UserUncheckedUpdateWithoutEnseingantInput>
  }

  export type UserUpdateWithoutEnseingantInput = {
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUpdateOneWithoutUserNestedInput
    Admin?: AdminUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnseingantInput = {
    id?: IntFieldUpdateOperationsInput | number
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUncheckedUpdateOneWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EspaceCoursUpsertWithWhereUniqueWithoutEnseingantInput = {
    where: EspaceCoursWhereUniqueInput
    update: XOR<EspaceCoursUpdateWithoutEnseingantInput, EspaceCoursUncheckedUpdateWithoutEnseingantInput>
    create: XOR<EspaceCoursCreateWithoutEnseingantInput, EspaceCoursUncheckedCreateWithoutEnseingantInput>
  }

  export type EspaceCoursUpdateWithWhereUniqueWithoutEnseingantInput = {
    where: EspaceCoursWhereUniqueInput
    data: XOR<EspaceCoursUpdateWithoutEnseingantInput, EspaceCoursUncheckedUpdateWithoutEnseingantInput>
  }

  export type EspaceCoursUpdateManyWithWhereWithoutEnseingantInput = {
    where: EspaceCoursScalarWhereInput
    data: XOR<EspaceCoursUpdateManyMutationInput, EspaceCoursUncheckedUpdateManyWithoutEnseingantInput>
  }

  export type UserCreateWithoutAdminInput = {
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantCreateNestedOneWithoutUserInput
    Enseingant?: EnseingantCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    prenom: string
    nom: string
    email: string
    image: string
    password: string
    telephone: number
    role: $Enums.RoleUser
    createdAt?: Date | string
    updatedAt?: Date | string
    Etudiant?: EtudiantUncheckedCreateNestedOneWithoutUserInput
    Enseingant?: EnseingantUncheckedCreateNestedOneWithoutUserInput
    Commentaire?: CommentaireUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUpdateOneWithoutUserNestedInput
    Enseingant?: EnseingantUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telephone?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleUserFieldUpdateOperationsInput | $Enums.RoleUser
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etudiant?: EtudiantUncheckedUpdateOneWithoutUserNestedInput
    Enseingant?: EnseingantUncheckedUpdateOneWithoutUserNestedInput
    Commentaire?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EtudiantCreateWithoutGamificationInput = {
    matricule: number
    dateNaiss: Date | string
    user: UserCreateNestedOneWithoutEtudiantInput
    Resultat?: ResultatCreateNestedManyWithoutEtudiantInput
    Depot?: DepotCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutGamificationInput = {
    id?: number
    userId: number
    matricule: number
    dateNaiss: Date | string
    Resultat?: ResultatUncheckedCreateNestedManyWithoutEtudiantInput
    Depot?: DepotUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutGamificationInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutGamificationInput, EtudiantUncheckedCreateWithoutGamificationInput>
  }

  export type EspaceCoursCreateWithoutGamificationInput = {
    nom: string
    image: string
    cleAccee: string
    niveau: NiveauCreateNestedOneWithoutEspaceCoursInput
    enseingant: EnseingantCreateNestedOneWithoutEspaceCoursInput
    Theme?: ThemeCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursUncheckedCreateWithoutGamificationInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
    enseingantId: number
    Theme?: ThemeUncheckedCreateNestedManyWithoutEspaceCoursInput
    BanqueQuestion?: BanqueQuestionUncheckedCreateNestedManyWithoutEspaceCoursInput
  }

  export type EspaceCoursCreateOrConnectWithoutGamificationInput = {
    where: EspaceCoursWhereUniqueInput
    create: XOR<EspaceCoursCreateWithoutGamificationInput, EspaceCoursUncheckedCreateWithoutGamificationInput>
  }

  export type EtudiantUpsertWithoutGamificationInput = {
    update: XOR<EtudiantUpdateWithoutGamificationInput, EtudiantUncheckedUpdateWithoutGamificationInput>
    create: XOR<EtudiantCreateWithoutGamificationInput, EtudiantUncheckedCreateWithoutGamificationInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutGamificationInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutGamificationInput, EtudiantUncheckedUpdateWithoutGamificationInput>
  }

  export type EtudiantUpdateWithoutGamificationInput = {
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEtudiantNestedInput
    Resultat?: ResultatUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutGamificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    Resultat?: ResultatUncheckedUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type EspaceCoursUpsertWithoutGamificationInput = {
    update: XOR<EspaceCoursUpdateWithoutGamificationInput, EspaceCoursUncheckedUpdateWithoutGamificationInput>
    create: XOR<EspaceCoursCreateWithoutGamificationInput, EspaceCoursUncheckedCreateWithoutGamificationInput>
    where?: EspaceCoursWhereInput
  }

  export type EspaceCoursUpdateToOneWithWhereWithoutGamificationInput = {
    where?: EspaceCoursWhereInput
    data: XOR<EspaceCoursUpdateWithoutGamificationInput, EspaceCoursUncheckedUpdateWithoutGamificationInput>
  }

  export type EspaceCoursUpdateWithoutGamificationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveau?: NiveauUpdateOneRequiredWithoutEspaceCoursNestedInput
    enseingant?: EnseingantUpdateOneRequiredWithoutEspaceCoursNestedInput
    Theme?: ThemeUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateWithoutGamificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
    enseingantId?: IntFieldUpdateOperationsInput | number
    Theme?: ThemeUncheckedUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EtudiantCreateWithoutResultatInput = {
    matricule: number
    dateNaiss: Date | string
    user: UserCreateNestedOneWithoutEtudiantInput
    Gamification?: GamificationCreateNestedManyWithoutEtudiantInput
    Depot?: DepotCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutResultatInput = {
    id?: number
    userId: number
    matricule: number
    dateNaiss: Date | string
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEtudiantInput
    Depot?: DepotUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutResultatInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutResultatInput, EtudiantUncheckedCreateWithoutResultatInput>
  }

  export type TestCreateWithoutResultatInput = {
    nom: string
    point: number
    periode: number
    dateDebut?: Date | string
    dateFin: Date | string
    theme: ThemeCreateNestedOneWithoutTestInput
    TestQuestion?: TestQuestionCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateWithoutResultatInput = {
    id?: number
    nom: string
    point: number
    periode: number
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
    TestQuestion?: TestQuestionUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCreateOrConnectWithoutResultatInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutResultatInput, TestUncheckedCreateWithoutResultatInput>
  }

  export type EtudiantUpsertWithoutResultatInput = {
    update: XOR<EtudiantUpdateWithoutResultatInput, EtudiantUncheckedUpdateWithoutResultatInput>
    create: XOR<EtudiantCreateWithoutResultatInput, EtudiantUncheckedCreateWithoutResultatInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutResultatInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutResultatInput, EtudiantUncheckedUpdateWithoutResultatInput>
  }

  export type EtudiantUpdateWithoutResultatInput = {
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEtudiantNestedInput
    Gamification?: GamificationUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutResultatInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    Gamification?: GamificationUncheckedUpdateManyWithoutEtudiantNestedInput
    Depot?: DepotUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type TestUpsertWithoutResultatInput = {
    update: XOR<TestUpdateWithoutResultatInput, TestUncheckedUpdateWithoutResultatInput>
    create: XOR<TestCreateWithoutResultatInput, TestUncheckedCreateWithoutResultatInput>
    where?: TestWhereInput
  }

  export type TestUpdateToOneWithWhereWithoutResultatInput = {
    where?: TestWhereInput
    data: XOR<TestUpdateWithoutResultatInput, TestUncheckedUpdateWithoutResultatInput>
  }

  export type TestUpdateWithoutResultatInput = {
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutTestNestedInput
    TestQuestion?: TestQuestionUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateWithoutResultatInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    TestQuestion?: TestQuestionUncheckedUpdateManyWithoutTestNestedInput
  }

  export type BanqueQuestionCreateWithoutTestQuestionInput = {
    num: number
    desc: string
    espaceCours: EspaceCoursCreateNestedOneWithoutBanqueQuestionInput
    Reponse?: ReponseCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionUncheckedCreateWithoutTestQuestionInput = {
    id?: number
    num: number
    desc: string
    espaceCoursId: number
    Reponse?: ReponseUncheckedCreateNestedManyWithoutBanqueQuestionInput
  }

  export type BanqueQuestionCreateOrConnectWithoutTestQuestionInput = {
    where: BanqueQuestionWhereUniqueInput
    create: XOR<BanqueQuestionCreateWithoutTestQuestionInput, BanqueQuestionUncheckedCreateWithoutTestQuestionInput>
  }

  export type TestCreateWithoutTestQuestionInput = {
    nom: string
    point: number
    periode: number
    dateDebut?: Date | string
    dateFin: Date | string
    theme: ThemeCreateNestedOneWithoutTestInput
    Resultat?: ResultatCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateWithoutTestQuestionInput = {
    id?: number
    nom: string
    point: number
    periode: number
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
    Resultat?: ResultatUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCreateOrConnectWithoutTestQuestionInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutTestQuestionInput, TestUncheckedCreateWithoutTestQuestionInput>
  }

  export type BanqueQuestionUpsertWithoutTestQuestionInput = {
    update: XOR<BanqueQuestionUpdateWithoutTestQuestionInput, BanqueQuestionUncheckedUpdateWithoutTestQuestionInput>
    create: XOR<BanqueQuestionCreateWithoutTestQuestionInput, BanqueQuestionUncheckedCreateWithoutTestQuestionInput>
    where?: BanqueQuestionWhereInput
  }

  export type BanqueQuestionUpdateToOneWithWhereWithoutTestQuestionInput = {
    where?: BanqueQuestionWhereInput
    data: XOR<BanqueQuestionUpdateWithoutTestQuestionInput, BanqueQuestionUncheckedUpdateWithoutTestQuestionInput>
  }

  export type BanqueQuestionUpdateWithoutTestQuestionInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutBanqueQuestionNestedInput
    Reponse?: ReponseUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type BanqueQuestionUncheckedUpdateWithoutTestQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    Reponse?: ReponseUncheckedUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type TestUpsertWithoutTestQuestionInput = {
    update: XOR<TestUpdateWithoutTestQuestionInput, TestUncheckedUpdateWithoutTestQuestionInput>
    create: XOR<TestCreateWithoutTestQuestionInput, TestUncheckedCreateWithoutTestQuestionInput>
    where?: TestWhereInput
  }

  export type TestUpdateToOneWithWhereWithoutTestQuestionInput = {
    where?: TestWhereInput
    data: XOR<TestUpdateWithoutTestQuestionInput, TestUncheckedUpdateWithoutTestQuestionInput>
  }

  export type TestUpdateWithoutTestQuestionInput = {
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutTestNestedInput
    Resultat?: ResultatUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateWithoutTestQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Resultat?: ResultatUncheckedUpdateManyWithoutTestNestedInput
  }

  export type EtudiantCreateWithoutDepotInput = {
    matricule: number
    dateNaiss: Date | string
    user: UserCreateNestedOneWithoutEtudiantInput
    Gamification?: GamificationCreateNestedManyWithoutEtudiantInput
    Resultat?: ResultatCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutDepotInput = {
    id?: number
    userId: number
    matricule: number
    dateNaiss: Date | string
    Gamification?: GamificationUncheckedCreateNestedManyWithoutEtudiantInput
    Resultat?: ResultatUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutDepotInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutDepotInput, EtudiantUncheckedCreateWithoutDepotInput>
  }

  export type EspaceDepotCreateWithoutDepotInput = {
    nom: string
    type: $Enums.TypeFile
    dateDebut?: Date | string
    dateFin: Date | string
    theme: ThemeCreateNestedOneWithoutEspaceDepotInput
  }

  export type EspaceDepotUncheckedCreateWithoutDepotInput = {
    id?: number
    nom: string
    type: $Enums.TypeFile
    themeId: number
    dateDebut?: Date | string
    dateFin: Date | string
  }

  export type EspaceDepotCreateOrConnectWithoutDepotInput = {
    where: EspaceDepotWhereUniqueInput
    create: XOR<EspaceDepotCreateWithoutDepotInput, EspaceDepotUncheckedCreateWithoutDepotInput>
  }

  export type EtudiantUpsertWithoutDepotInput = {
    update: XOR<EtudiantUpdateWithoutDepotInput, EtudiantUncheckedUpdateWithoutDepotInput>
    create: XOR<EtudiantCreateWithoutDepotInput, EtudiantUncheckedCreateWithoutDepotInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutDepotInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutDepotInput, EtudiantUncheckedUpdateWithoutDepotInput>
  }

  export type EtudiantUpdateWithoutDepotInput = {
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEtudiantNestedInput
    Gamification?: GamificationUpdateManyWithoutEtudiantNestedInput
    Resultat?: ResultatUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutDepotInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    matricule?: IntFieldUpdateOperationsInput | number
    dateNaiss?: DateTimeFieldUpdateOperationsInput | Date | string
    Gamification?: GamificationUncheckedUpdateManyWithoutEtudiantNestedInput
    Resultat?: ResultatUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type EspaceDepotUpsertWithoutDepotInput = {
    update: XOR<EspaceDepotUpdateWithoutDepotInput, EspaceDepotUncheckedUpdateWithoutDepotInput>
    create: XOR<EspaceDepotCreateWithoutDepotInput, EspaceDepotUncheckedCreateWithoutDepotInput>
    where?: EspaceDepotWhereInput
  }

  export type EspaceDepotUpdateToOneWithWhereWithoutDepotInput = {
    where?: EspaceDepotWhereInput
    data: XOR<EspaceDepotUpdateWithoutDepotInput, EspaceDepotUncheckedUpdateWithoutDepotInput>
  }

  export type EspaceDepotUpdateWithoutDepotInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ThemeUpdateOneRequiredWithoutEspaceDepotNestedInput
  }

  export type EspaceDepotUncheckedUpdateWithoutDepotInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    themeId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NiveauCreateManySpecialiteInput = {
    id?: number
    num: number
  }

  export type NiveauUpdateWithoutSpecialiteInput = {
    num?: IntFieldUpdateOperationsInput | number
    EspaceCours?: EspaceCoursUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    EspaceCours?: EspaceCoursUncheckedUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateManyWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
  }

  export type EspaceCoursCreateManyNiveauInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    enseingantId: number
  }

  export type EspaceCoursUpdateWithoutNiveauInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    enseingant?: EnseingantUpdateOneRequiredWithoutEspaceCoursNestedInput
    Theme?: ThemeUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateWithoutNiveauInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    enseingantId?: IntFieldUpdateOperationsInput | number
    Theme?: ThemeUncheckedUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUncheckedUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateManyWithoutNiveauInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    enseingantId?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeCreateManyEspaceCoursInput = {
    id?: number
    nom: string
  }

  export type BanqueQuestionCreateManyEspaceCoursInput = {
    id?: number
    num: number
    desc: string
  }

  export type GamificationCreateManyEspaceCoursInput = {
    id?: number
    etudiantId: number
    point?: number
  }

  export type ThemeUpdateWithoutEspaceCoursInput = {
    nom?: StringFieldUpdateOperationsInput | string
    EspaceDepot?: EspaceDepotUpdateManyWithoutThemeNestedInput
    Ressource?: RessourceUpdateManyWithoutThemeNestedInput
    Test?: TestUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    EspaceDepot?: EspaceDepotUncheckedUpdateManyWithoutThemeNestedInput
    Ressource?: RessourceUncheckedUpdateManyWithoutThemeNestedInput
    Test?: TestUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateManyWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BanqueQuestionUpdateWithoutEspaceCoursInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    Reponse?: ReponseUpdateManyWithoutBanqueQuestionNestedInput
    TestQuestion?: TestQuestionUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type BanqueQuestionUncheckedUpdateWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    Reponse?: ReponseUncheckedUpdateManyWithoutBanqueQuestionNestedInput
    TestQuestion?: TestQuestionUncheckedUpdateManyWithoutBanqueQuestionNestedInput
  }

  export type BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type GamificationUpdateWithoutEspaceCoursInput = {
    point?: IntFieldUpdateOperationsInput | number
    etudiant?: EtudiantUpdateOneRequiredWithoutGamificationNestedInput
  }

  export type GamificationUncheckedUpdateWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type GamificationUncheckedUpdateManyWithoutEspaceCoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type EspaceDepotCreateManyThemeInput = {
    id?: number
    nom: string
    type: $Enums.TypeFile
    dateDebut?: Date | string
    dateFin: Date | string
  }

  export type RessourceCreateManyThemeInput = {
    id?: number
    nom: string
    file: string
    type: $Enums.TypeFile
    dateDepot?: Date | string
  }

  export type TestCreateManyThemeInput = {
    id?: number
    nom: string
    point: number
    periode: number
    dateDebut?: Date | string
    dateFin: Date | string
  }

  export type EspaceDepotUpdateWithoutThemeInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Depot?: DepotUpdateManyWithoutEspaceDepotNestedInput
  }

  export type EspaceDepotUncheckedUpdateWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Depot?: DepotUncheckedUpdateManyWithoutEspaceDepotNestedInput
  }

  export type EspaceDepotUncheckedUpdateManyWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RessourceUpdateWithoutThemeInput = {
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
    Commentaire?: CommentaireUpdateManyWithoutRessourceNestedInput
  }

  export type RessourceUncheckedUpdateWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
    Commentaire?: CommentaireUncheckedUpdateManyWithoutRessourceNestedInput
  }

  export type RessourceUncheckedUpdateManyWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeFileFieldUpdateOperationsInput | $Enums.TypeFile
    dateDepot?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUpdateWithoutThemeInput = {
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Resultat?: ResultatUpdateManyWithoutTestNestedInput
    TestQuestion?: TestQuestionUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    Resultat?: ResultatUncheckedUpdateManyWithoutTestNestedInput
    TestQuestion?: TestQuestionUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateManyWithoutThemeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    periode?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepotCreateManyEspaceDepotInput = {
    id?: number
    etudiantId: number
    file: string
  }

  export type DepotUpdateWithoutEspaceDepotInput = {
    file?: StringFieldUpdateOperationsInput | string
    etudiant?: EtudiantUpdateOneRequiredWithoutDepotNestedInput
  }

  export type DepotUncheckedUpdateWithoutEspaceDepotInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type DepotUncheckedUpdateManyWithoutEspaceDepotInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type CommentaireCreateManyRessourceInput = {
    id?: number
    desc: string
    font: string
    italic: boolean
    userId: number
  }

  export type CommentaireUpdateWithoutRessourceInput = {
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommentaireNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutRessourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireUncheckedUpdateManyWithoutRessourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatCreateManyTestInput = {
    id?: number
    etudiantId: number
    point?: number
  }

  export type TestQuestionCreateManyTestInput = {
    id?: number
    point?: number
    banqueQuestionId: number
  }

  export type ResultatUpdateWithoutTestInput = {
    point?: IntFieldUpdateOperationsInput | number
    etudiant?: EtudiantUpdateOneRequiredWithoutResultatNestedInput
  }

  export type ResultatUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    etudiantId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type TestQuestionUpdateWithoutTestInput = {
    point?: IntFieldUpdateOperationsInput | number
    banqueQuestion?: BanqueQuestionUpdateOneRequiredWithoutTestQuestionNestedInput
  }

  export type TestQuestionUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    banqueQuestionId?: IntFieldUpdateOperationsInput | number
  }

  export type TestQuestionUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    banqueQuestionId?: IntFieldUpdateOperationsInput | number
  }

  export type ReponseCreateManyBanqueQuestionInput = {
    id?: number
    num: number
    desc: string
    isCorrecte: boolean
  }

  export type TestQuestionCreateManyBanqueQuestionInput = {
    id?: number
    point?: number
    testId: number
  }

  export type ReponseUpdateWithoutBanqueQuestionInput = {
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReponseUncheckedUpdateWithoutBanqueQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReponseUncheckedUpdateManyWithoutBanqueQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    num?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    isCorrecte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestQuestionUpdateWithoutBanqueQuestionInput = {
    point?: IntFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutTestQuestionNestedInput
  }

  export type TestQuestionUncheckedUpdateWithoutBanqueQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type TestQuestionUncheckedUpdateManyWithoutBanqueQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireCreateManyUserInput = {
    id?: number
    desc: string
    font: string
    italic: boolean
    ressourceId: number
  }

  export type CommentaireUpdateWithoutUserInput = {
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    ressource?: RessourceUpdateOneRequiredWithoutCommentaireNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    ressourceId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: StringFieldUpdateOperationsInput | string
    font?: StringFieldUpdateOperationsInput | string
    italic?: BoolFieldUpdateOperationsInput | boolean
    ressourceId?: IntFieldUpdateOperationsInput | number
  }

  export type GamificationCreateManyEtudiantInput = {
    id?: number
    espaceCoursId: number
    point?: number
  }

  export type ResultatCreateManyEtudiantInput = {
    id?: number
    testId: number
    point?: number
  }

  export type DepotCreateManyEtudiantInput = {
    id?: number
    espaceDepotId: number
    file: string
  }

  export type GamificationUpdateWithoutEtudiantInput = {
    point?: IntFieldUpdateOperationsInput | number
    espaceCours?: EspaceCoursUpdateOneRequiredWithoutGamificationNestedInput
  }

  export type GamificationUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type GamificationUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    espaceCoursId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatUpdateWithoutEtudiantInput = {
    point?: IntFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutResultatNestedInput
  }

  export type ResultatUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type ResultatUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
  }

  export type DepotUpdateWithoutEtudiantInput = {
    file?: StringFieldUpdateOperationsInput | string
    espaceDepot?: EspaceDepotUpdateOneRequiredWithoutDepotNestedInput
  }

  export type DepotUncheckedUpdateWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    espaceDepotId?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type DepotUncheckedUpdateManyWithoutEtudiantInput = {
    id?: IntFieldUpdateOperationsInput | number
    espaceDepotId?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
  }

  export type EspaceCoursCreateManyEnseingantInput = {
    id?: number
    nom: string
    image: string
    cleAccee: string
    niveauId: number
  }

  export type EspaceCoursUpdateWithoutEnseingantInput = {
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveau?: NiveauUpdateOneRequiredWithoutEspaceCoursNestedInput
    Theme?: ThemeUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateWithoutEnseingantInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
    Theme?: ThemeUncheckedUpdateManyWithoutEspaceCoursNestedInput
    BanqueQuestion?: BanqueQuestionUncheckedUpdateManyWithoutEspaceCoursNestedInput
    Gamification?: GamificationUncheckedUpdateManyWithoutEspaceCoursNestedInput
  }

  export type EspaceCoursUncheckedUpdateManyWithoutEnseingantInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cleAccee?: StringFieldUpdateOperationsInput | string
    niveauId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SpecialiteCountOutputTypeDefaultArgs instead
     */
    export type SpecialiteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NiveauCountOutputTypeDefaultArgs instead
     */
    export type NiveauCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NiveauCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspaceCoursCountOutputTypeDefaultArgs instead
     */
    export type EspaceCoursCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspaceCoursCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThemeCountOutputTypeDefaultArgs instead
     */
    export type ThemeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThemeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspaceDepotCountOutputTypeDefaultArgs instead
     */
    export type EspaceDepotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspaceDepotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RessourceCountOutputTypeDefaultArgs instead
     */
    export type RessourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RessourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestCountOutputTypeDefaultArgs instead
     */
    export type TestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanqueQuestionCountOutputTypeDefaultArgs instead
     */
    export type BanqueQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanqueQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtudiantCountOutputTypeDefaultArgs instead
     */
    export type EtudiantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtudiantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnseingantCountOutputTypeDefaultArgs instead
     */
    export type EnseingantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnseingantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialiteDefaultArgs instead
     */
    export type SpecialiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NiveauDefaultArgs instead
     */
    export type NiveauArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NiveauDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspaceCoursDefaultArgs instead
     */
    export type EspaceCoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspaceCoursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThemeDefaultArgs instead
     */
    export type ThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThemeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspaceDepotDefaultArgs instead
     */
    export type EspaceDepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspaceDepotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RessourceDefaultArgs instead
     */
    export type RessourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RessourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestDefaultArgs instead
     */
    export type TestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanqueQuestionDefaultArgs instead
     */
    export type BanqueQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanqueQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReponseDefaultArgs instead
     */
    export type ReponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentaireDefaultArgs instead
     */
    export type CommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtudiantDefaultArgs instead
     */
    export type EtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtudiantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnseingantDefaultArgs instead
     */
    export type EnseingantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnseingantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GamificationDefaultArgs instead
     */
    export type GamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResultatDefaultArgs instead
     */
    export type ResultatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResultatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestQuestionDefaultArgs instead
     */
    export type TestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepotDefaultArgs instead
     */
    export type DepotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepotDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}